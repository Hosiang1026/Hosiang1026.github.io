<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Access-Control-Allow-Origin" content="*"><script type="text/javascript">var start_time=(new Date).getTime()</script><meta http-equiv="Cache-Control" content="no-cache"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="google-site-verification" content="9Wt3lmnrT2bfjaHla5s16adhvcQcBHO7PtNf97n5Od0"><meta name="baidu-site-verification" content="RYlYHsgO7Y"><meta name="sogou_site_verification" content="MSmrTj7lHV"><meta name="shenma-site-verification" content="e4428ccce0f22fad61c3716193bf4bd7_1571416388"><meta name="baidu_union_verify" content="584bb6b4bd24108df082b6d20c7aa9be"><title>推荐系列-探讨 Git 代码托管平台的若干问题 - 2019 版 | 狂欢马克思</title><meta name="keywords" content="分享技术经验与交流"><meta name="description" content="&amp;emsp;&amp;emsp;关于 Git 版本控制软件种类繁多，维基百科收录的最早的版本控制系统是 1972 年贝尔实验室开发的 Source Code Control System。1986 年 Concurrent Versions System(CVS) 诞生，CVS 曾非常流行…"><meta property="og:type" content="article"><meta property="og:title" content="推荐系列-探讨 Git 代码托管平台的若干问题 - 2019 版"><meta property="og:url" content="https://www.hosiang.cn/18c2c48d/index.html"><meta property="og:site_name" content="狂欢马克思"><meta property="og:description" content="&amp;emsp;&amp;emsp;关于 Git 版本控制软件种类繁多，维基百科收录的最早的版本控制系统是 1972 年贝尔实验室开发的 Source Code Control System。1986 年 Concurrent Versions System(CVS) 诞生，CVS 曾非常流行…"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://github.com/fcharlie/pagesimage/raw/master/images/git-fetch-flow.png"><meta property="og:image" content="https://github.com/fcharlie/pagesimage/raw/master/images/git-fetch-flow.png"><meta property="article:published_time" content="2021-04-15T01:17:50.000Z"><meta property="article:modified_time" content="2022-05-11T09:55:21.100Z"><meta property="article:author" content="Howe Hsiang"><meta property="article:tag" content="Popular"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://github.com/fcharlie/pagesimage/raw/master/images/git-fetch-flow.png"><link rel="icon" href="/images/favicon.ico"><link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/font-awesome-animation/0.1.0/font-awesome-animation.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3cd8fa109426bf3f10bd5c362175bace";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.2.0"></head><script src="/js/jquery.min.js"></script><script src="/js/pace.min.js"></script><script src="/js/crypto-js.js"></script><script src="/js/cookie.js"></script><script src="/js/calendar.js"></script><script src="/js/festival.js"></script><script>getFestival()</script><body><script>window.onload=function(){document.getElementById("TimeShow").innerHTML="本站耗时 "+((new Date).getTime()-start_time)/1e3+" 秒 "}</script><div id="container"><header id="header"><div id="banner"></div><div id="header-outer"><div id="header-menu" class="header-menu-pos animated"><div class="header-menu-container"><a href="/" class="left"><span class="site-title">狂欢马克思</span></a><nav id="header-menu-nav" class="right"><a href="/" rel="external nofollow"><i class="fa fa-home"></i> <span>主页</span> </a><a href="/archives" rel="external nofollow"><i class="fa fa-archive"></i> <span>归档</span> </a><a href="/gitbook" rel="external nofollow"><i class="fa fa-columns"></i> <span>笔记</span> </a><a href="/music" rel="external nofollow"><i class="fa fa-music"></i> <span>音乐</span> </a><a href="/photo" rel="external nofollow"><i class="fa fa-picture-o"></i> <span>相册</span> </a><a href="/collection" rel="external nofollow"><i class="fa fa-envira"></i> <span>收藏</span> </a><a href="/about" rel="external nofollow"><i class="fa fa-user"></i> <span>关于</span></a></nav><a class="mobile-header-menu-button"><i class="fa fa-bars"></i></a></div></div><div id="header-row"><div id="logo"><a href="/"><img src="/../images/logo.png" alt="logo"></a></div><div class="header-info"><div id="header-title"><h2>狂欢马克思</h2></div><div id="header-description"><h3>专注Web开发</h3></div></div><nav class="header-nav"><div class="social"><a title="Github" target="_blank" href="//github.com/Hosiang1026" rel="external nofollow"><i class="fa fa-github fa-2x"></i></a> <a title="QQ" target="_blank" href="//wpa.qq.com/msgrd?v=3&uin=641904695&site=qq&menu=yes" rel="external nofollow"><i class="fa fa-qq fa-2x"></i></a> <a title="Weibo" target="_blank" href="//www.weibo.com/haoxiang969" rel="external nofollow"><i class="fa fa-weibo fa-2x"></i></a></div></nav></div><div id="noticeId" class="show" style="background:rgb(244,247,247,.3)"><marquee id="noticeMar" behavior="scoll" class="notice" direction="left" onmouseover="this.stop()" onmouseout="this.start()"></marquee></div><script type="text/javascript">function browserRedirect(){var i=navigator.userAgent.toLowerCase(),n="ipad"==i.match(/ipad/i),o="iphone os"==i.match(/iphone os/i),a="midp"==i.match(/midp/i),t="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),e="ucweb"==i.match(/ucweb/i),s="android"==i.match(/android/i),d="windows ce"==i.match(/windows ce/i),p="windows mobile"==i.match(/windows mobile/i),r="",c=randomColor(),r=n||o||a||t||e||s||d||p?($("#noticeId").css({"line-height":"1.6em"}),"<font style='color:"+c+"' face='新华宋体'  size='2'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='hitokoto'></span></span></span><span id='YQData'></font> "):($("#noticeId").css({"line-height":"3.6em","margin-top":"20px"}),"<font style='color:"+c+"' face='新华宋体'  size='6'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='hitokoto'></span></span><span id='YQData'></span></font> ");$("#noticeMar").html(r)}function randomColor(){for(var i="0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f".split(","),n="#",o=0;o<6;o++)n+=i[Math.floor(16*Math.random())];return n}$(function(){browserRedirect(),0<$("#hitokoto").length&&getHitokoto()})</script></div></header><script>console.log=function(){}</script><div class="outer"><section id="main" class="body-wrap"><article id="post-探讨 Git 代码托管平台的若干问题 - 2019 版" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="post-title" itemprop="name">推荐系列-探讨 Git 代码托管平台的若干问题 - 2019 版</h1><div class="post-title-bar"><ul><li><i class="fa fa-book"></i> <a href="/categories/热门文章/">热门文章</a></li><li><i class="fa fa-calendar"></i> 2021-04-15</li><li><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span></li><li><span class="post-count">字数统计: 10.4k字</span></li><li><span class="post-count">阅读时长: 39分钟</span></li></ul></div></header><div class="article-entry post-content" itemprop="articleBody"><p>&amp;emsp;&amp;emsp;关于 Git 版本控制软件种类繁多，维基百科收录的最早的版本控制系统是 1972 年贝尔实验室开发的 Source Code Control System。1986 年 Concurrent Versions System(CVS) 诞生，CVS 曾非常流行…</p><span id="more"></span><pre><code>                                                                                                                                                                                    #### 关于 Git 
</code></pre><p>版本控制软件种类繁多，维基百科收录的最早的版本控制系统是 1972 年贝尔实验室开发的 Source Code Control System。1986 年 Concurrent Versions System(CVS) 诞生，CVS 曾非常流行，但今时用之寥寥无几，不过 OpenBSD 仍在使用 CVS。2000 年 CollabNet 创建了 Subversion 项目，2009年，Subversion 被 Apache 基金会接受成为顶级项目并被命名为 Apache Subversion。2005 年 Linus Torvalds 创建了 Git，2007 Github 诞生后，Git 随着 Github 的发展愈发流行，14 年间，Git 成为了最流行的版本控制系统，无论是 Windows 还是 Linux 或是 Android，MySQL 等等大型软件都使用 git 进行版本控制。纵观版本控制系统流行史，前有 CVS 后有 SVN，今日 Git 更风流。俱往矣，数风流人物，还看今朝，版本控制系统莫不如斯。<br>与 CVS&#x2F;Subversion 这种集中式版本控制系统不同的是，Git 的存储库数据会被存储在本地，提交也是发生在本地，远程可以看作是本地存储库的一个镜像。而 CVS&#x2F;Subversion 的提交都是在线的。这就是分布式版本控制系统的核心特征。（理解这一问题的关联在于区分工作树 <code>java worktree</code> 和存储库 &#96;&#96;&#96;java<br>repository</p><p><code>。） Git 的源码托管在 git.kernel.org 上，Github 上也有只读镜像 github.com/git/git。Git 主页 https://git-scm.com 的网页源码则托管在 Github 上。通常给 git 提交 PR 需要注册 public-inbox.org 邮件列表，然后发送补丁。者通常比较麻烦，好在有微软开发者Johannes Schindelin 使用 TypeScript 开发 gitgitgadget ，当你在 Github 上像 gitgitgadget/git 提交 PR 时，gitgitgadget 会将你的 PR 发送到 public-inbox，一旦补丁被 git 维护者接受，gitgitgadget 则会关闭那个 PR。gitgitgadget 简化了给 git 贡献代码的难度，省去了注册 Inbox 的麻烦，这年头开发者大多都有 Github 帐号。我就使用 gitgitgadget 给 git 提交了一个补丁用于支持 HTTP/2。 Johannes Schindelin 此人也是 git-for-windows 的维护者。 Git 的维护者则是 Google 的开发者 Junio C Hamano。大多数 Git 开发者来自于 Google/Microsoft（包括 Github）。libgit2 的开发者主要来自 Microsoft（包括 Github）。而 JGit 的开发者则主要来自 Google。已故 JGit 的创始人 Shawn Pearce 还开发了著名的 Gerrit Code Review。这些开发者的无私奉献才能使我们用上这么优秀的版本控制系统，感谢他们的付出。 Git 与远程存储库之间的传输协议有 HTTP, GIT(</code>java<br>git:&#x2F;&#x2F;<br><code>)，SSH. 在 《Pro Git - 2nd Edition》4.1 Git on the Server - The Protocols 中有介绍。其中 HTTP 协议包括哑协议和智能协议，由于哑协议是只读协议，目前大多数代码托管平台均不再提供支持。HTTP 智能协议和 GIT 协议，SSH 协议类似，都是特定几组 客户端/服务端 git 命令之间的输入输出数据传输和交换。Git 传输协议较为简单，以智能传输协议 v1 为例，基本的</code>java<br>fetch&#x2F;push</p><p><code>流程如下： Git 拉取流程： ![Test](https://github.com/fcharlie/pagesimage/raw/master/images/git-fetch-flow.png &#39;探讨 Git 代码托管平台的若干问题 - 2019 版&#39;) Git 推送流程： ![Test](https://github.com/fcharlie/pagesimage/raw/master/images/git-fetch-flow.png &#39;探讨 Git 代码托管平台的若干问题 - 2019 版&#39;) 虽然在 2018 年 5 月，git 推出了</code>java<br>Wire Protocol</p><p><code>（即 Git v2 协议），增加了 Git 协议的复杂性，但在服务器上支持 git 协议（包括 v2 协议）仍然只需要在服务器上运行 git-upload-pack/git-receive-pack。这使得开发者很容易实现对 git 协议的支持。正因为 Git 协议表征的简单，所以针对不同的用户和存储库数量规模，Git 也都比 Subversion，Mercurial 有更多的选择。 Git 使用文件快照记录文件变更，当对象存储到松散文件目录时，每一次大小不变的文件修改相当于存储库中增加特定文件的大小，Git 使用 zlib deflate 压缩对象，对象头包括对象类型，原始大小。基于快照的方式使得 Git 在提交代码，检出文件时都比较高效，但存储库的占用缺比较高。但运行</code>java<br>git gc<br><code>时，Git 会将松散的对象打包到 pack 文件中，这个时候会使用特定的机制存储一部分文件的</code>java<br>OFS_DELTA</p><p><code>，这样就能节省一部分空间。 zlib（deflate） 压缩算法通常来说除了没有版权限制，无论是压缩比还是速度，CPU 使用率都不是一个最佳的选择，引用来自的 https://github.com/facebook/zstd 基准测试，zlib 看起来必后起之秀</code>java<br>brotli<br><code>/</code>java<br>zstd</p><p>&#96;&#96;&#96; 差多了：</p><p>Compressor name<br>Ratio<br>Compression<br>Decompress.</p><p>zstd 1.4.0 -1<br>2.884<br>530 MB&#x2F;s<br>1360 MB&#x2F;s</p><p>zlib 1.2.11 -1<br>2.743<br>110 MB&#x2F;s<br>440 MB&#x2F;s</p><p>brotli 1.0.7 -0<br>2.701<br>430 MB&#x2F;s<br>470 MB&#x2F;s</p><p>quicklz 1.5.0 -1<br>2.238<br>600 MB&#x2F;s<br>800 MB&#x2F;s</p><p>lzo1x 2.09 -1<br>2.106<br>680 MB&#x2F;s<br>950 MB&#x2F;s</p><p>lz4 1.8.3<br>2.101<br>800 MB&#x2F;s<br>4220 MB&#x2F;s</p><p>snappy 1.1.4<br>2.073<br>580 MB&#x2F;s<br>2020 MB&#x2F;s</p><p>lzf 3.6 -1<br>2.077<br>440 MB&#x2F;s<br>930 MB&#x2F;s</p><p>当开发者要将 git 集成到其他软件或者系统中时，可以通过命令行调用 git 命令捕获输出，也可以使用 libgit2&#x2F;JGit 等库。<br>libgit2 最初是由 Shawn Pearce 创建了初始 commit。目前主要维护者来自微软。libgit2 提供一些基础的 API，功能基本上是完整的，除了一部分实现性能没有 git 那么好，其他方面令人满意，并且有多种语言绑定，包括 C++&#x2F;D&#x2F;Golang&#x2F;Ruby&#x2F;.NET&#x2F;Node.js&#x2F;Perl&#x2F;Perl6&#x2F;Ruby&#x2F;Rust 等等。Gitee 原生钩子就使用了 libgit2，Gitee-gitlab 项目使用了 rugged。<br>JGit 也是有 Shawn Pearce 创建的，目前属于 Eclipse 基金会，运行在 JVM 上，国内腾讯的工峰的 TGit 也是使用的 JGit。<br>在 Git Rev News 第48期，编辑推荐了 gitbase 通过 SQL 的方式查询 git 存储库，这个工具基于 src-d&#x2F;go-git，go-git 是纯 Golang 实现的，如果基于 Golang 的项目需要简单的读写存储库，可以使用 go-git。与 libgit2 的 Golang 绑定 git2go 相比，不需要使用 CGO。<br>当然还有一些其他的 git 实现，大多是实验性的，不建议用于生产环境，比如基于 Rust 的 git-rs。</p><h4 id="不同伸缩性的-Git-代码托管平台"><a href="#不同伸缩性的-Git-代码托管平台" class="headerlink" title="不同伸缩性的 Git 代码托管平台"></a>不同伸缩性的 Git 代码托管平台</h4><h5 id="基于内置工具搭建-Git-代码托管服务"><a href="#基于内置工具搭建-Git-代码托管服务" class="headerlink" title="基于内置工具搭建 Git 代码托管服务"></a>基于内置工具搭建 Git 代码托管服务</h5><p>Git 最初由 Linus Torvalds 开发用来取代 BitKeeper 作为 Linux 内核源码的版本控制工具，所以 Git 一直和 Linux 内核源码托管在同一个服务器上。官方地址是：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://git.kernel.org/%E3%80%82%E5%9C%A8">https://git.kernel.org/。在</a> git.kernel.org 上，Git 代码托管功能是由 git 内置的工具实现的。用户使用 HTTPS 协议访问 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://git.kernel.org/">https://git.kernel.org/</a> 时，Nginx 会以 CGI 的方式将浏览器的请求转发到 GitWeb。GitWeb 是一个使用 Perl 编写的 CGI 程序，为用户提供简单的 git 在线交互图形界面。GitWeb 的源码地址可以在 Github Git 镜像 中查看。GitWeb 界面比较不够精美，相比于 Github 这样的代码托管平台，功能寥寥无几。当用户需要使用 HTTP&#x2F;HTTPS 协议拉取推送源码时，Nginx 会以 CGI的方式将请求转发给 git-http-backend 处理。git-http-backend 是 Git Over HTTP 的服务端实现。当用户 GIT 协议 ( &#96;&#96;&#96;java<br>git:&#x2F;&#x2F;</p><p><code>) 在 git.kernel.org 上拉取源码是，请求会被 git-daemon 处理。git-daemon 默默的监听 9418 端口，静静的等待 git 客户端的访问。 使用 Git 内置的 GitWeb/git-http-backend/git-daemon，我们能够搭建一个简易的 Git 代码托管服务器，但这里没有 SSH 协议支持。而实现 SSH 协议支持也非常简单，只需要在服务器上运行</code>java<br>sshd<br><code>(OpenSSH)，并允许命令</code>java<br>git-upload-pack&#x2F;git-receive-pack&#x2F;git-upload-archive<br><code>命令的运行，对于 SSH 协议的验证，我们则可以使用</code>java<br>authorized_keys<br><code>机制，将需要允许的用户的 SSH 公钥添加到</code>java<br>authorized_keys</p><p><code>文件。 这种方案通常使用 Gitolite 增强访问控制，Gitolite 主要使用 Perl 编写，这和 GitWeb 一致，ssh 的验证是将 gitolite-shell 添加到</code>java<br>~&#x2F;.ssh&#x2F;authorized_keys</p><p>&#96;&#96;&#96; 中被 sshd 调用实现的。git.kernenl.org 正是使用 Gitolite 实现 Git Over SSH 访问控制。<br><a target="_blank" rel="external nofollow noopener noreferrer" href="https://git.kernel.org/">https://git.kernel.org/</a> 网站托管了 Linux 内核源码，驱动，文档等大概有 1000 多个存储库，较大的存储库比如 Linux 内核源码磁盘占用大概是 2GB，因此在理想情况下，一块 2TB 磁盘的服务器便可支撑 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://git.kernel.org/">https://git.kernel.org/</a> 这个网站的运行（实际情况则并不是如此，由于 Linux 内核的流行，git.kernel.org 的请求将比较多，对硬件的需求将更高一点）。基于 Git 内置功能搭建的代码托管服务，麻雀虽小五脏俱全，不过回过头来说，这样的代码托管服务功能有限，可伸缩性和扩展性不佳。</p><h5 id="小型的-Git-代码托管平台"><a href="#小型的-Git-代码托管平台" class="headerlink" title="小型的 Git 代码托管平台"></a>小型的 Git 代码托管平台</h5><p>当用户需要搭建一个几人到几十几百人规模的 Git 代码托管服务，通常有非常多的选择，下面是几个目前仍然比较活跃的小型 Git 代码托管平台。</p><p>名称<br>平台<br>语言<br>技术概述</p><p>Bonobo Git Server<br>Windows Only<br>C#<br>基于 .Net Famework 4.6（迁移到 .Net Core 的建议在 2017 年便被提出，但截至目前仍为迁移到 .Net Core）。使用 LibGit2Sharp 操作存储库，但版本较老，不支持 SSH 协议访问。</p><p>Gogs<br>Cross Platform<br>Golang<br>基于 Golang 编写，Web 读写 Git 存储库由 git-module 封装 Git 命令实现，SSH 由 Golang crypto&#x2F;ssh 提供，支持多种数据库，是一个极简的代码托管平台，可以在 Raspberry Pi 上运行</p><p>Gitea<br>Cross Platform<br>Golang<br>是 Gogs 的开源分叉，Web 读写 Git 存储库使用了 src-d&#x2F;go-git，使用 gliderlabs&#x2F;ssh 提供 SSH 接入功能，支持多种数据库，可以在 Raspberry Pi 上运行。</p><p>GitBucket<br>Cross Platform<br>Scala&#x2F;Java<br>使用 Apache Mina SSHD 实现 SSH 功能。Mina SSHD 还专门针对 JGit 实现了一个 sshd-git 模块，但 GitBucket 是直接使用 JGit 的 &#96;&#96;&#96;java<br>transport</p><p>&#96;&#96;&#96; 相关类。Eclipse JGit 主要由 Google 开发者参与贡献。</p><p>除了上述定位为代码托管平台的服务，还有像 Phabricator 这样的 Web 软件也提供 Git 代码托管功能，但 Phabricator 的重点更多是缺陷追踪，代码审核。LLVM <a target="_blank" rel="external nofollow noopener noreferrer" href="https://reviews.llvm.org/">https://reviews.llvm.org/</a> 和 libssh <a target="_blank" rel="external nofollow noopener noreferrer" href="https://bugs.libssh.org/">https://bugs.libssh.org/</a> 就是基于 Phabricator。</p><h5 id="云服务级别的-Git-代码托管平台"><a href="#云服务级别的-Git-代码托管平台" class="headerlink" title="云服务级别的 Git 代码托管平台"></a>云服务级别的 Git 代码托管平台</h5><p>随着用户规模和存储库规模的增长，达到一定级别后，上述代码托管平台往往变得力不从心，而下面的代码托管平台却深耕于此，能够支撑巨大规模的用户量和存储库数量。<br>Github 是全球最大的代码托管平台，目前 Github 官方数据显示注册用户数量为 4000万，项目数量为 1亿。Github 网站主要的技术是 Ruby on Rails 内部进程名为 <code>java github-unicorn</code> ，最近他们将其升级到了 Rails 6.0。Github 使用 Spokes 负责文件系统上存储库的复制，同步和备份。Github 之前使用 libssh 开发 Git SSH 服务器，目前的 SSH 服务器的标识为 <code>java babeld-*</code> ，但不确定 babeld 是否依然基于 libssh。Git 验证服务为 <code>java github-gitauth</code> 。Github 的大多数服务都是闭源的，因此分析 Github 的技术内幕通常是 Github 官方的一些技术博客， 当然也可以分析 &#96;&#96;&#96;java<br>Github Enterprise</p><p>&#96;&#96;&#96; 去窥测 Github 内幕。<br>关于 Github Spokes 的大致原理可以阅读 Introducing DGit 和 Building resilience in Spokes。<br>在开发 Gitaly 之后， Gitlab 摆脱了 NFS 的禁锢，在平台的伸缩性方面得到了巨大的提升。要知道 Gitlab 使用 Gitaly 的原因可以阅读 The road to Gitaly v1.0。Gitaly 使用 RPC 将存储服务器上的 git 命令包转成前端服务机器上的 git 命令，并为 gitlab 服务提供存储库的读写。 Gitlab 的 SSH 功能仍然由 OpenSSH 提供，而一些静态资源，文件下载，附件等功能则由 Golang 编写的 gitlab-workhorse 实现，gitlab-workhorse 需要与 Gitaly 通信。<br>Bitbucket 是 Atlassian 开发的代码托管平台，与 Github&#x2F;Gitlab 不同，Bitbucket 还提供了原生 Mercurial 支持，不过最近，Bitbucket 宣布要逐步关闭 Mercurial 的支持。Atlassian 还开发了 Jira&#x2F;Sourcetree 这样著名的软件，Bitbucket 源码没有开发，推测主要使用 Java 技术栈（这个从一次 Bitbucket VFSForGit 安装包分析可得）。<br>Gitee 是目前国内最大的代码托管平台之一，早在 2015 年便开始了分布式改造，并编写了一系列服务实现分布式架构，编写了 Nginx 路由模块实现动态路由，基于 libssh 开发了 Basalt v1 SSH 服务器，基于 Golang 开发了 Basalt v2 SSH 服务器，还开发了 git-srv 智能服务后端，brzox Git HTTP&#x2F;Archive 服务。以及 git-diamond git 协议内部传输服务等等。Gitee 最初代码基于 Gitlab，几年之间已经与 Gitlab 有了很大的差异，现在 Gitee 已经逐步将一些功能从 gitlab 中剥离，实现云平台的微服务，比如目前的 git&#x2F;svn&#x2F;hook 验证服务是基于 Golang 编写的 banjo。Gitee 需要以有限的硬件实现更多的用户接入，所以在服务的设计上更倾向于提供资源使用率，对一些比较容易造成计算资源紧张的服务进行降级。</p><h4 id="Git-代码托管平台服务实现"><a href="#Git-代码托管平台服务实现" class="headerlink" title="Git 代码托管平台服务实现"></a>Git 代码托管平台服务实现</h4><p>Git 代码托管平台的基本服务应该包括浏览器接入支持和 git 客户端接入支持，前者需要平台开发网页提供若干���务供用户访问。后者需要支持 git 客户端推拉代码。通过网站访问存储库意味着 HTTP 服务需要通过一定的途径读写存储库，在 GitWeb 中，这通常使用 git 命令实现，比如使用 <code>java git tree</code> 查看 <code>java tree</code> ，使用 <code>java git archive</code> 打包文件等等。在 Gogs 中，使用的 git-module 同样使用了命令读写存储库。而 Gogs 的分叉 Gitea 则使用的是 src-d&#x2F;go-git 读写存储库。实际上我们常常有那种感觉，使用命令行可能会比直接调用 API 慢，并且错误难以处理，这通常是对的。比如我们查看 <code>java HEAD</code> 对应的引用，使用命令我们可以运行 <code>java git symbolic-ref HEAD</code> ，运行这个命令我们需要 fork 出一个进程，fork 成功后马上在子进程中执行 exec git symbolic-ref，为了读取 git symbolic-ref 的输出，我们还需要创建几对 Pipe，并检测 git symbolic-ref 的退出值。而使用 libgit2 API 我们只需要调用 <code>java git_repository_open</code> , <code>java git_reference_open</code> , <code>java git_reference_symbolic_target</code> 即可拿到对应的引用。而对于服务程序而言，fork-exec 的代价可能不小。当然你也可以直接使用 &#96;&#96;&#96;java<br>open(“&#x2F;path&#x2F;to&#x2F;.git&#x2F;HEAD”)</p><p><code>然后解析 HEAD 对应的引用。GitBucket 使用 JGit 读写存储库，Gitlab 曾经历了 Grit (Grit 部分命令部分 Git 纯 Ruby 实现，Github 曾经使用)。后来的 Rugged，到现在 Gitaly 的纯命令 + Ruby Repository（Gitlab 现在的架构我对其保留意见，至少 IO 复制将增加多次）。Github 目前使用 Rugged 读写存储库，当然一些更多的细节因为没有源码不得而知。Gitee 目前使用 Rugged，但一部分 libgit2 实现不佳的则直接采用 git 命令实现。 实现 Git Over HTTP，Gitlab 最初采用了 Grack, 运行在</code>java<br>unicorn</p><p>&#96;&#96;&#96; 中的 Grack 并发有限且容易影响 Web 访问（即 Git 请求较多时，Web 拒绝服务），而基于 Golang 开发的 Gogs，Gitea 使用 Golang 原生 HTTP 库编写 Git HTTP Server 功能，这要比 Grack 好要好很多，Golang HTTP 模型能够支撑更多的并发。目前 Gitee 的 Git HTTP Server Brzox 也是使用 Golang 编写。<br>实现 Git Over SSH，Gitlab 目前依然使用的是 OpenSSH，而不像 Github&#x2F;BitBucket&#x2F;Gitee 直接编写 SSH 服务器，直接编写 SSH 服务器可以禁用 SSH 登录，自定义错误消息，简化验证流程，减少数据拷贝。Github 早先是基于 libssh 编写的 SSH Server, 目前不得而知。BitBucket 技术上偏向 Java, 则有可能使用 Apache Mina SSHD, GitBucket 使用 Apache Mina SSHD + JGit 实现 Git Over SSH 功能。而 Gogs&#x2F;Gitea 在虽然使用 Golang crypto&#x2F;ssh 编写了 SSH 服务，但在实现时仍然使用了中间命令，这就导致数据拷贝次数的增加，观测 Gogs&#x2F;Gitea 的各种服务实现，这可能是设计不足的妥协吧。<br>实现 Git Over TCP （git:&#x2F;&#x2F; 协议）也非常简单，但 Git 协议并不提供验证机制，Git 代码托管平台提不提供 Git 协议支持也无关紧要，但 Git 协议无需加密，协议简单，作为平台内部传输服务倒是可以，目前 Gitee 使用 C++ Asio 编写 git-diamond 支持内部同步，企业存储库备份等功能。</p><h4 id="Git-代码托管平台的伸缩性"><a href="#Git-代码托管平台的伸缩性" class="headerlink" title="Git 代码托管平台的伸缩性"></a>Git 代码托管平台的伸缩性</h4><p>伸缩性是 Git 代码托管能否支撑成千上万用户&#x2F;存储库的重要指标。像 Gogs&#x2F;Gitea 这样的代码托管系统尽量认为自身运行在单一服务器上，因此这类 Git 代码托管平台伸缩性非常有限，当然如果使用 NFS&#x2F;Ceph 这类分布式文件系统能够在单一服务器上支持更多的存储库，但 NFS&#x2F;Ceph 这种分布式系统的做为 Git 代码托管系统的存储层，除了分布式文件系统带来的性能下降，还会带来内网带宽过高等更多的问题。<br>我们以使用 NFS 挂载实现伸缩性的平台和 Gitee 分布式模型 git 请求 对比，I&#x2F;O 细节简化如下：<br>NFS I&#x2F;O 细节：<br><img src="https://github.com/fcharlie/pagesimage/raw/master/images/git-fetch-flow.png" alt="Test" title="探讨 Git 代码托管平台的若干问题 - 2019 版"><br>Gitee Basalt I&#x2F;O 细节：<br><img src="https://github.com/fcharlie/pagesimage/raw/master/images/git-fetch-flow.png" alt="Test" title="探讨 Git 代码托管平台的若干问题 - 2019 版"><br>计算机是质朴的，流程的增加往往需要更多的计算资源，与 Basalt-GitSrv 相比，NFS 的 I&#x2F;O 拷贝要多一些，排除 Git 协议影响我们可能会认为 Basalt 的机制要比 NFS 更节省 I&#x2F;O。如果考虑到 Git 协议的影响，我们应该确信如此，git 推送或者拉取都需要耗费大量的 CPU 计算资源，而在 NFS 模型中，计算全部都是发生在前端服务器，当请求数量较多时，前端服务器则容易出现 CPU 竞争的局面，这将非常影响服务器性能，另外，对于 NFS 这样的文件系统，读写 Git 松散对象都是不得力的。另外，由于 NFS 的缓存机制，负载较高时会出现 &#96;&#96;&#96;java<br>master.lock</p><p><code>这样的锁定情况，导致用户使用异常。而对于 Basalt，git 则是在存储服务器上直接操作存储库，打包压缩，解压等对 CPU 需求较高的活动也在存储服务器上，这样意味着，CPU 计算被摊薄到存储服务器上了，另外 basalt-gitsrv 中间传输的是打包后的数据，这与 NFS 读写多个文件相比，网络数据量实际上是下降的。 Gitee 作为国内最早的 Git 代码托管平台之一，最开始使用 NFS 实现伸缩性，随着用户规模增长很快出现了上述所有 NFS 容易遇到的问题，后来尝试切换到 Ceph，git 松散对象给其致命一击，上线便宣告失败，出现了严重的宕机事故，数据被毁，只能从备份恢复。后来迁移到分布式架构后基本稳定运行至今（这种方案基本上增加机器即可，前端负载高加前端，存储满了加存储）。 Github 目前有大约 1亿个项目，我们假设 Github 上存储库大小平均为 10MB，目前 Github 存储库使用三副本机制，大概需要的磁盘容量为 2861 TB，按照硬盘出厂的规则（1000GB=1TB）,则是需要最小 3PB。这么大的磁盘容量并不是一个标准服务器能够提供的，按照目前企业级硬盘容量较大的每个 16TB, 则需要硬盘大概 188 块。你能想象到这样大的规模能够简单的运行在分布式文件系统上吗？目前的技术基本上不太现实。 实现 Git 代码托管平台的可伸缩性重要的是实现资源的分片，最开始 Gitee 分布式时使用的是基于用户（namespace）的资源分片，也就是存储库所在的机器与 namespace 所属的机器像匹配，这实际上是一种先入为主的设计，在使用 NFS 挂载的时代，Gitee 的存储库就是按照 namespace 的前两个字母分片存储到不同服务器上，挂载到前端服务器上。因此，基于 namespace 的分片带来了一些问题，比如用户转移存储库可能需要跨机器，fork 存储库也可能需要跨机器，这就无法实现高效的轻量级 fork 功能。从去年开始迁移到基于存储库的分片，基于存储库分片基本上可以解决这些问题，但由于历史原因，轻量级 fork 等功能道阻且长。 资源的分片和请求的路由相伴而生，将存储库存储到不同服务器上后，则需要在这些服务器上实现对应的服务支持前端的请求，而前端也需要实现特定的路由机制，关于 Gitee 的路由机制架构，可以参考相关演讲或者博客。Gitee 存储服务器上使用了 git-srv 作为 Git 传输协议后端服务，而 Github 则使用了 DGit/Spokes，Gitlab 使用了 Gitaly。不同平台的技术各有侧重，比如 Gitlab Gitaly 侧重兼容旧的 OpenSSH，而 Gitee 的 Basalt-GitSrv 针对实际情况优化，与 Gitaly 相比要少一次 I/O 拷贝。 Gitee 目前不足之处是存没有完全剥离 Web(基于早期 Gitlab 发展而来)，而 Gitaly 也有 Ruby 代码实现存储库读写（这块代码用 Golang 封装 I/O 多了一次拷贝）。与 Gitee 类似，Gitea 还有另一种方案，即将 Gitea 部署到多个服务器上共用 DB 支持分片，比如 gitea.com 便是这样的平台，但 gitea.com 似乎并不支持 SSH，因此并不能算有效的分片。 前端服务器的扩展性实际上要比存储服务器好，前端服务器的迁移一般不需要像存储服务器那样转移存储库，服务也一般更简单。 存储库分片之后还是无法避免特定存储库请求过多的问题，Github 的解决方案是使用三副本读写分离的 Spokes 机制，这一方案最多能够提供 3倍于单一服务器的并发读取能力，但不支持并发写入存储库。三副本机制需要解决分布式系统常见的一致性问题，引入并发写入可能会带来更多的数据冲突，破坏一致性，因此 Github 完全禁止并发写入存储库副本（即同时有不同的写存储库请求）。Gitlab 没有实现这样的技术，BitBucket 则没有披露相关资讯，Gitee 受限与硬件限制和开发资源限制，也没有实施。 github-dfs： ![Test](https://github.com/fcharlie/pagesimage/raw/master/images/git-fetch-flow.png &#39;探讨 Git 代码托管平台的若干问题 - 2019 版&#39;) 除了存储库的分片，代码托管平台还需要考虑数据库 SQL/NoSQL 能否支撑大规模并发，数据库的分布式集群是一个比较成熟的方案，而 Redis 最新的版���也��持集群，因此数据库的伸缩性一般不会存在太大问题，增加机器搭建集群即可。选择关系性数据库时还需要考虑许可证，数据库自身的功能等，比如 Gitlab 目前已经放弃对 MySQL 的支持，而是选择了 PostgreSQL，不过 Gitlab 的选择对于其他代码托管平台来说，也只能算作仅作参考。MariaDB 是 MySQL 的分支版本，随着 MySQL 被 Oracle 收购，开源社区渐渐丧失了对 MySQL 的兴趣，虽然 MySQL 8.0 发布已经很久，但采用 MySQL 8.0 的发行版本寥寥无几，很多还停留在 MySQL 5.X，有些发行版还使用 mariadb-connector-c 替代</code>java<br>libmysqlclient</p><p>&#96;&#96;&#96; 作为数据库连接器，使用 MySQL 的平台很容易迁移到 MariaDB 而不用修改客户端数据库连接代码 ，MariaDB 支持线程池，而 MySQL 仅在企业版中支持线程池。一些 MariaDB 与 MySQL 的对比这里不赘述了。Gogs&#x2F;Gitea 还支持使用 SQLite，但其使用 SQLite 时，基本上是放弃了伸缩性，不过目前有一个使用 Raft+libuv 实现的分布式 SQLite canonical&#x2F;dqlite，可以尝试一下。Redis 一般可以作为 Web 缓存或者任务队列的中间件，目前 Redis 虽然支持集群，但就单机 Redis 而言，由于它是单线程的服务，在将内存数据持久化到磁盘是还是可能出现超时，并且单线程服务性能终究有限，在 Github 上，KeyDB 是官方 Redis 的另一个选择，KeyDB 是 Redis 的分支，完全兼容 Redis 协议，KeyDB 支持多线程，有更好的内存效率和高吞吐量。</p><h4 id="Git-代码托管平台的增强功能"><a href="#Git-代码托管平台的增强功能" class="headerlink" title="Git 代码托管平台的增强功能"></a>Git 代码托管平台的增强功能</h4><p>除了支持用户通过 Git 协议或者通过网页方式读写远程存储库，代码托管平台一般还需要提供一些与开发相关的功能增强用户体验，这些功能在不同平台之间的对比时显得非常重要。</p><h5 id="缺陷追踪"><a href="#缺陷追踪" class="headerlink" title="缺陷追踪"></a>缺陷追踪</h5><p>SQLite3 使用 2007 年诞生的版本控制系统 Fossil 托管其源码，与前辈 Git 相比，它集成了 Bug 追踪，Wiki，论坛和技术报告。而对于 Git 来说，这些则需要 Git 代码托管平台自己实现，当然现在无论是 Github&#x2F;Gitee&#x2F;Gitlab&#x2F;BitBucket 还是 Gogs&#x2F;Gitea 都提供了 <code>java Issues</code> 这样的机制方便开发者第一时间报告软件缺陷或者提出功能建议。 <code>java Issues</code> 这样的功能实现主要在于让用户参与其中，也就是用的人多了，才有人气。而 Github 的 &#96;&#96;&#96;java<br>Issues</p><p>&#96;&#96;&#96; 相比其他平台是最活跃的。另外 Github 还提供依赖警报功能（详情可以阅读 Introducing security alerts on GitHub），另外 Github 还收购了 Semmle 代码分析用于连续漏洞检测 (参考：Securing software, together），这也是其他 Git 代码托管平台可以借鉴的功能。</p><h5 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h5><p>在微软收购 Github之后，Github 有了更充足的财力在给用户提供持续集成功能，今年以来 Github 推出了 GitHub Package Registry 和 Github Actions （相关文章：GitHub Actions now supports CI&#x2F;CD, free for public repositories，Introducing GitHub Package Registry），在推出 Github Actions 之前，开发者在 Github 上大多是通过第三方软件实现 CI&#x2F;CD 功能，比如我的 M2Team&#x2F;Privexec 就使用 Appveroy。Windows Terminal 则使用 Azure Pipeline。平台的生态繁荣得益于第三方的支持，而对于其他平台，这些 CI&#x2F;CD 支持就没有这么大的力度了，这也促使其他代码托管平台的 API 趋向 Github 化，WebHook 也逐步趋同，Github 形成了事实上的标准。比如 Gitee 的 APIv5 就保持了对 Github 的兼容。</p><h5 id="保护分支和只读目录"><a href="#保护分支和只读目录" class="headerlink" title="保护分支和只读目录"></a>保护分支和只读目录</h5><p>Gitee 很早就实现了类似 SVN 的保护分支功能，而 Github 目前也同样支持保护分支。实现保护分支的途径很很多条，通常通过服务端 Git 钩子实现，我曾写过 《服务端 Git 钩子的妙用》 介绍了如何通过钩子实现保护分支功能。<br>只读目录功能同样可以通过钩子实现，如果不通过钩子，而是在 git 命令中实现，则要面临修改 git 源码，需要投入大量人力维护的情况。《服务端 Git 钩子的妙用》和 《实现 Git 目录权限控制》对实现目录权限控制有详细介绍。</p><h5 id="其他版本控制系统接入"><a href="#其他版本控制系统接入" class="headerlink" title="其他版本控制系统接入"></a>其他版本控制系统接入</h5><p>将使用其他版本控制系统的存储库转为 Git 非常简单，git 自身提供了 <code>java git svn</code> 命令，可以将远程 svn 存储库一个个版本递归的转变为 Git 存储库，详细的操作可以参考 《Pro Git 2nd Edition》9.2 Git and Other Systems - Migrating to Git，这种方案的缺点比较是比较耗时，Gitee 开发者曾经帮助国内某汽车制造企业将 Subversion 存储库迁移到 Git，一开始使用 &#96;&#96;&#96;java<br>git svn</p><p><code>，发现耗费时间太长，于是我找到了一个开源工具： git-svn-fast-import，将其编译好并修复特定 BUG 交给相关同事，后来该企业的迁移工作顺利完成。这个工具直接解析存储库将其转换为 git 存储库，省去了网络传输的消耗。 除了支持从其他版本控制系统导入外，一些代码 Git 代码托管平台也支持其他协议接入，Github/Gitee 都支持 Subversion 接入，也就是同一个存储库同时��持 git 客户端和 svn 客户端接入（像 BitBucket 支持 Mercurial 的实现实际上是单独搭建 Mercurial 存储库，不属于此类情况）。实现 Subversion 的接入几个难点，一是 Subversion 各种传输协议细节完全不同，HTTP 基于 WebDAV，而 SVN 协议又是一种自定义的 ABNF 格式协议，如果在考虑支持 Subversion 接入时还需要考虑选择哪种协议，两类协议都支持通常是不现实的，费时费力。二是 Subversion 自身也在不断发展，但实际上在愿意在 Git 代码托管平台使用 svn 的毕竟还是少数，实现 Subversion 接入通常是费力不讨好，投入与产出不成正比。 Github 实现的是 svn HTTP 协议，将 git 存储库的 commit 映射到 svn 的 revs。Github 的实现并不完美，由于需要通过 commit 计算 svn 版本信息，第一次通过 svn 协议访问存储库时会比较慢，如果当存储库较大时，检出还很容易失败，并且一次检出操作可能需要发送的非常多的请求，大概是所有目录所有文件数目之和。 Gitee 使用了 git-as-svn 实现对 svn 的支持，支持的协议有</code>java<br>svn:&#x2F;&#x2F;<br><code>和</code>java<br>svn+ssh:&#x2F;&#x2F;<br><code>，</code>java<br>svn+ssh:&#x2F;&#x2F;<br><code>实际上是</code>java<br>svn:&#x2F;&#x2F;<br><code>协议通过 SSH 隧道传输，在 Gitee 中，当 Basalt 接收到客户端请求在远程服务器上运行</code>java<br>svnserve -t<br><code>命令，则会将请求转发到 git-as-svn。在 Gitea 开发者的贡献下，git-as-svn 增加了</code>java<br>svnserve<br><code>命令包装，即当 Gitea 接收到</code>java<br>svn+ssh:&#x2F;&#x2F;<br><code>协议请求时，则是启动包装的命令，进行一些列授权后然后在 shell 中与使用命令</code>java<br>exec 3&lt;&gt;&#x2F;dev&#x2F;tcp&#x2F;localhost&#x2F;3690</p><p>&#96;&#96;&#96; 与 git-as-svn 通信，Gitee 的设计简化了验证流程，能够支持分布式架构，Gitea 目前还不能做到。git-as-svn 的基于 Java 开发，早期，开发者似乎对 git 的理念研究不够透彻，git-as-svn 的内部实现细节变动非常大，早前的实现机制不太理想，性能不佳。在 Gitee 中，我们为了避免存储库较大时开启 svn 支持带来的性能下降，额外增加了对通过 svn 协议访问存储库的限制，目前是通过 svn 协议访问存储库时，存储库的大小限制为 400MB。<br>在早期，兼容其他版本控制系统可能是吸引用户的一大法宝，但随着 Git 的越来越流行，支持其他版本控制系统接入逐渐成了鸡肋，前人有言：“食之无肉，弃之可惜”，正是如此。像 Github&#x2F;Gitee 这样的平台虽然支持 svn，但 svn 访问的还是极少数，而支持 svn 则需要花费一些人力物力，并且在系统架构设计时增加了复杂度。如果现在开发一个 Git 代码托管平台则没有必要支持 svn。Gitee 虽然支持 svn，但 svn 每日的请求数不足 1%，在这 1% 中，又有 50% 以上的请求是特定的用户使用定时命令发送的。</p><h5 id="大文件大存储库"><a href="#大文件大存储库" class="headerlink" title="大文件大存储库"></a>大文件大存储库</h5><p>公共 Git 代码托管平台很多时候实际上是给用户提供免费服务，为了过多避免大文件大存储库占用平台资源，对其作出限制必不可少，通常是大文件限制 100MB, 存储库限制 1GB. 存储库的检测简单的遍历存储库 objects 目录即可，而大文件的检测则复杂一些。Gitee 最初使用 Grit 检测 commit 是否引入了 blob 原始大小大于限制的文件，但这种机制需要解析 Git 对象，检测容易坍塌（一是检测超时，二是检测逃逸，三是存储库体积膨胀），后开使用原生钩子，改变了检测机制，则避免了这些问题。详细情况可以阅读《服务端 Git 钩子的妙用》。<br>禁止大文件推送这只是堵，那么大文件应该如何存放呢？Github 推出了 LFS 方案，目前 LFS 功能已经被大多数平台支持，Github 将 LFS 存储到 AWS 上，而 Gitee&#x2F;Gitlab&#x2F;Gogs&#x2F;Gitea 大多使用自建的 LFS 服务器，存储在特定服务器上。<br>如果一个存储库自身就已经非常大了，如何去解决用户的访问难题呢？比如 Windows 源码超过 <code>java 300GB</code> ，如果用户克隆存储库，按照每秒 1MB&#x2F;s 的速度，需要 85 小时，这在任何代码托管平台都是不太现实的，好在微软 2017 年发布了 GVFS（现在叫 VFSforGit）,在使用 VFSforGit 获取远程存储库时，可以只获得目录结构，并在本地创建占位文件，但用户操作这些占位文件时，VFSforGit 客户端才会去请求服务器下载对应的对象，这大大改善了巨型存储库的操作体验。VFSforGit 本地涉及到的主要技术是 ProjFS，在 Windows 上，VFSforGit 会创建 &#96;&#96;&#96;java<br>IO_REPARSE_TAG_PROJFS</p><p><code>类型的 ReparsePoint（NTFS 重解析点），读写到这些重解析点时，ProjFS 驱动会转发到 VFSForGit 客户端下载相应的对象。微软很多开发者在 macOS 上开发，所以官方增加了对 macOS 的支持，而 Github 的 VFSForGit fork 则增加了对 Linux 的支持，不过离实用还有一些时日，Github ProjFS 实现库是 libprojfs。 Git 代码托管平台支持 VFSforGit 客户端比较容易，目前除了 Visual Studio Online，还有 BitBucket 也增加了对 VFSforGit 的支持。我曾用 libgit2 开发了一个</code>java<br>git-vfs-serve</p><p>&#96;&#96;&#96; 命令，用户访问 brzox 时，brzox 请求 git-srv，git-srv 执行 git-vfs-serve 便可以支持 VFSforGit 客户端的访问，不过并未上线。</p><h5 id="安全性增强"><a href="#安全性增强" class="headerlink" title="安全性增强"></a>安全性增强</h5><p>Github 最近宣布了支持 WebAuthn: GitHub supports Web Authentication (WebAuthn) for security keys，这种机制可以使用生物识别从而避免输入用户密码，随着信息技术的不断发展，一方面，安全机制不断完善，另一方面，用户面临的风险也会多样化，复杂化。代码托管平台管理了开发者的核心资产，因此在安全上绝不能掉以轻心。当然需要做的不仅仅是及时跟进新的安全机制，还需要对整个系统及时进行安全升级，淘汰旧的协议（比如 SSL3&#x2F;TLS1.1），旧的加密，哈希算法（DSA，MD5&#x2F;SHA1），及时采用新的协议（TLS1.3）,新的加密，哈希算法（ED25519，SHA3）等等。</p><h4 id="文件服务"><a href="#文件服务" class="headerlink" title="文件服务"></a>文件服务</h4><p>一个优秀的 Git 代码托管平台，应该在软件的开发整个周期都给用户提供帮助，比如下载源码，软件发布。源码下载主要指 Archive 功能，软件的发布则需要平台提供 Release&#x2F;附件下载功能。</p><h5 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h5><p>我们知道 git-archive 命令可以将存储库特定的 commit&#x2F;branch 打包成一个 zip&#x2F;tar 文件，而在 Git Over SSH（Git Over TCP） 实现中，只要我们允许 &#96;&#96;&#96;java<br>git-upload-archive</p><p>&#96;&#96;&#96; 命令在远程服务器上运行，就打包远程服务器上的存储库的特定分支。但由于 git-upload-archive 与 git-upload-pack&#x2F;git-receive-pack 存在一些不同，是的 HTTP 协议无法实现 archive 协商。提供 archive 下载则需要另辟蹊径。<br>我们在远程服务器上运行 git-archive 将其输出作为响应体的内容返回给 HTTP Client 便可实现 archive 下载功能，由于 archive 下载实际上是将 git tree&#x2F;blob 遍历然后写入到归档文件后压缩（tar.gz&#x2F;tar.bz2 …）或者是压缩后写入文件（zip），二者都非常消耗 CPU 资源，因此我们在实现 archive 下载功能的同时应该设计 archive 的缓存功能（当然缓存应该支持过期）。gitlab-workhorse 实现的 archive 下载功能便是先尝试命中缓存，如果没有缓存则调用 git 命令然后生成写入到缓存文件。Gitee 最近实现的 blaze-archive 也采用了类似的机制，但 blaze-archive 是一个独立的命令，这个命令实际上是被 git-srv 调用，brzox 与 git-srv 通信，brzox 将 archive 返回给 HTTP Client，而缓存的删除则是 blaze 负责的。</p><h5 id="附件，Release"><a href="#附件，Release" class="headerlink" title="附件，Release"></a>附件，Release</h5><p>附件，Release 可以选择云方案，如果要将附件和 LFS 统一管理，实际上国内的阿里云，腾讯云之类的并不合适，这些平台对并不支持类似 AWS <code>java x-amz-content-sha256</code> 这样的头部，而是 &#96;&#96;&#96;java<br>Content-MD5</p><p><code>因此这些云平台要支持 LFS 则要花费多一些功夫。选择国外的 AWS, Azure 则需要考虑经济，网络等问题。当然无论如何使用云平台都需要考虑经济问题。 平台自建附件，Release 功能可以使用分布式文件系统，如 FastDFS, 但 FastFDS 并不是一个好的选择，历史比较久，存储机制安全机制现在来说都不是很优秀。有个更好的选择是 Minio, minio 使用 Golang 开发，支持 AWS API。许可协议是</code>java<br>Apache 2.0</p><p>&#96;&#96;&#96; ，商用没有阻碍，因此是用来搭建附件，Release 以及 LFS 存储服务器的不二选择。</p><h4 id="Git-的未来"><a href="#Git-的未来" class="headerlink" title="Git 的未来"></a>Git 的未来</h4><p>Git 虽然是当前最受欢迎的代码托管系统，但 Git 也面临了一些难题，一类是如何支持大文件大存储库，这些问题有 Git LFS, VFSforGit 这样的第三方解决方案，也有微软，Google 开发者参与的官方 Partial Clone，部分克隆需要 Wire 协议支持，离可用还为时尚早。<br>2017年2月，Google 开发者宣布攻破 SHA1，这曾经给一些 git 用户带来了担忧，因为 git 使用 SHA1 计算对象 ID，但 git 使用的实际上是一种特殊的 SHA1，将对象类型对象长度以及对象内容合并在一起计算 SHA1，由于有长度校验，这使得 SHA1 的冲突可能被降低了，但无论如何，SHA1 也不再是安全的，Git 在源码中增加了 sha1collisiondetection 来避免 SHA1 冲突，并且增加了计划迁移到 SHA-256，并且将一些涉及到 Hash 的代码从单一的 SHA1 转变成 &#96;&#96;&#96;java<br>object_id</p><p>&#96;&#96;&#96; 。 关于 Hash 转换，可以查看文档 Git hash function transition。<br>Git 从 SHA1 迁移到 SHA-256 困难重重，从首次增加文档距今已经有两年时间，而 SHA-256 的实现还不见全貌。与 Hash 迁移相比，压缩算法的演进不重要更难实施，时至今日，zlib 压缩已经不再优秀，但 Git 可能还要负重前行。</p><h4 id="道路漫漫"><a href="#道路漫漫" class="headerlink" title="道路漫漫"></a>道路漫漫</h4><p>软件开发一直是一个飞速变化的领域，而代码托管也要不断面临新的挑战，道路漫漫，吾辈不休。</p><div class="post-copyright"><div class="content"><p>本文标题： 推荐系列-探讨 Git 代码托管平台的若干问题 - 2019 版</p><p>本文作者： OSChina</p><p>发布时间： 2021年04月15日 09:17</p><p>最后更新： 2022年05月11日 17:55</p><p>原始链接： <a class="post-url" href="/18c2c48d/" title="推荐系列-探讨 Git 代码托管平台的若干问题 - 2019 版">https://www.hosiang.cn/18c2c48d/</a></p><p>版权声明： 本文著作权归作者所有，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a>许可协议，转载请注明出处！</p><footer><a href="https://www.hosiang.cn"><img src="/../images/logo.png" alt="Howe Hsiang"> Howe Hsiang</a></footer></div></div><div class="page-reward"><a id="rewardBtn" href="javascript:;">赏</a></div><div id="reward" class="post-modal reward-lay"><a class="close" href="javascript:;" id="reward-close">×</a> <span class="reward-title"><i class="icon icon-quote-left"></i> 喜欢就赞赏一下呗！ <i class="icon icon-quote-right"></i></span><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="/images/threepay_code.jpg" alt="打赏二维码"></div><div class="reward-select"></div></div></div></div><footer class="article-footer"><div class="post-share"><a href="javascript:" id="share-sub" class="post-share-fab"><i class="fa fa-share-alt" style="padding-top:11px!important"></i></a><div class="post-share-list" id="share-list"><ul class="share-icons"><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.hosiang.cn/18c2c48d/" data-title="Facebook" rel="external nofollow noopener noreferrer"><i class="fa fa-facebook" style="padding-top:9px!important"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《推荐系列-探讨 Git 代码托管平台的若干问题 - 2019 版》 — 狂欢马克思&url=https://www.hosiang.cn/18c2c48d/&via=https://www.hosiang.cn" data-title="Twitter" rel="external nofollow noopener noreferrer"><i class="fa fa-twitter" style="padding-top:9px!important"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.hosiang.cn/18c2c48d/" data-title="Google+" rel="external nofollow noopener noreferrer"><i class="fa fa-google-plus" style="padding-top:9px!important"></i></a></li><li><a class="qq share-sns" target="_blank" href="https://connect.qq.com/widget/shareqq/index.html?url=https://www.hosiang.cn/18c2c48d/&title=《推荐系列-探讨 Git 代码托管平台的若干问题 - 2019 版》 — 狂欢马克思&source=&amp;emsp;&amp;emsp;关于 Git 版本控制软件种类繁多，维基百科收录的最早的版本控制系统是 1972 年贝尔实验室开发的 Source..." data-title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-qq" style="padding-top:9px!important"></i></a></li><li><a class="weixin share-sns" id="wxFab" href="javascript:" data-title="微信"><i class="fa fa-weixin" style="padding-top:9px!important"></i></a></li><li><a class="weibo share-sns" target="_blank" href="https://service.weibo.com/share/share.php?url=https://www.hosiang.cn/18c2c48d/&title=《推荐系列-探讨 Git 代码托管平台的若干问题 - 2019 版》 — 狂欢马克思&pic=https://static.oschina.net/uploads/img/201912/25114241_bkAd.jpg" data-title="微博" rel="external nofollow noopener noreferrer"><i class="fa fa-weibo" style="padding-top:9px!important"></i></a></li></ul></div></div><div class="post-modal wx-share" id="wxShare"><a class="close" href="javascript:" id="wxShare-close">×</a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://www.hosiang.cn/18c2c48d/" alt="微信分享二维码"></div><div class="mask"></div><ul class="article-footer-menu"><li class="article-footer-tags"><i class="fa fa-tags"></i> <a href="/tags/Popular/" class="color3">Popular</a></li></ul></footer></div></article><aside class="post-toc-pos post-toc-top" id="post-toc"><nav class="post-toc-wrap"><ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%8D%E5%90%8C%E4%BC%B8%E7%BC%A9%E6%80%A7%E7%9A%84-Git-%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0"><span class="post-toc-text">不同伸缩性的 Git 代码托管平台</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA-Git-%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1"><span class="post-toc-text">基于内置工具搭建 Git 代码托管服务</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%B0%8F%E5%9E%8B%E7%9A%84-Git-%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0"><span class="post-toc-text">小型的 Git 代码托管平台</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%BA%A7%E5%88%AB%E7%9A%84-Git-%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0"><span class="post-toc-text">云服务级别的 Git 代码托管平台</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Git-%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">Git 代码托管平台服务实现</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Git-%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7"><span class="post-toc-text">Git 代码托管平台的伸缩性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Git-%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%A2%9E%E5%BC%BA%E5%8A%9F%E8%83%BD"><span class="post-toc-text">Git 代码托管平台的增强功能</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BC%BA%E9%99%B7%E8%BF%BD%E8%B8%AA"><span class="post-toc-text">缺陷追踪</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90"><span class="post-toc-text">持续集成</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%BF%9D%E6%8A%A4%E5%88%86%E6%94%AF%E5%92%8C%E5%8F%AA%E8%AF%BB%E7%9B%AE%E5%BD%95"><span class="post-toc-text">保护分支和只读目录</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%85%A5"><span class="post-toc-text">其他版本控制系统接入</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A4%A7%E5%AD%98%E5%82%A8%E5%BA%93"><span class="post-toc-text">大文件大存储库</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E5%A2%9E%E5%BC%BA"><span class="post-toc-text">安全性增强</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1"><span class="post-toc-text">文件服务</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Archive"><span class="post-toc-text">Archive</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%99%84%E4%BB%B6%EF%BC%8CRelease"><span class="post-toc-text">附件，Release</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Git-%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="post-toc-text">Git 的未来</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%81%93%E8%B7%AF%E6%BC%AB%E6%BC%AB"><span class="post-toc-text">道路漫漫</span></a></li></ol></nav></aside><nav id="article-nav"><a href="/5759749e/" id="article-nav-newer" class="article-nav-link-wrap"><span class="article-nav-title"><i class="fa fa-hand-o-left" aria-hidden="true"></i> 推荐系列-如何优雅地运用位运算实现产品需求- </span></a><a href="/d0852414/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">推荐系列-解Bug之路-记一次存储故障的排查过程</span> <i class="fa fa-hand-o-right" aria-hidden="true"></i></a></nav><div id="gitalk"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({repo:"bolg-comment",owner:"Hosiang1026",admin:"Hosiang1026",clientID:"37a2dd4473e8970cecc2",clientSecret:"e30efa17d86d9de4f4ab810872dc62a7b2e7e634",pagerDirection:"last",distractionFreeMode:!0,createIssueManually:!1});gitalk.render("gitalk")</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"><script id="_wau78w">var _wau=_wau||[];_wau.push(["small","5dnguv4c2n","78w"])</script><script async src="//waust.at/s.js"></script><p><span id="busuanzi_container_site_uv" style="display:none"><span class="post-count">总字数：<span>1777.3k</span> </span>总访客数：<span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" style="display:none">总访问量：<span id="busuanzi_value_site_pv"></span></span><br><span id="TimeShow">本站</span><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br>Copyright&copy; 2018 - 2022 狂欢马克思 <a href="https://beian.miit.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">京ICP备17060439号</a></p></div></div><script>var now=new Date;function createtime(){var n=new Date("2017/09/18");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",800)</script></footer><script>var mihoConfig={root:"https://www.hosiang.cn",animate:"true",isHome:"false",share:"true",reward:" 1"}</script><div class="sidebar"><div id="sidebar-search" title="Search"><i class="fa fa-search"></i></div><div id="sidebar-category" title="Categories"><i class="fa fa-book"></i></div><div id="sidebar-tag" title="Tags"><i class="fa fa-tags"></i></div><div id="sidebar-top"><span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span></div></div><div class="sidebar-menu-box" id="sidebar-menu-box"><div class="sidebar-menu-box-container"><div id="sidebar-menu-box-categories"><a class="category-link" href="/categories/%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD/">兴趣爱好</a><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/">其他开发</a><a class="category-link" href="/categories/%E5%89%8D%E6%B2%BF%E5%BC%80%E5%8F%91/">前沿开发</a><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a><a class="category-link" href="/categories/%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/">升级版本</a><a class="category-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">博客教程</a><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="category-link" href="/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</a><a class="category-link" href="/categories/%E7%83%AD%E9%97%A8%E6%96%87%E7%AB%A0/">热门文章</a></div><div id="sidebar-menu-box-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:17.5px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:15px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12.5px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Java/" style="font-size:12.5px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:17.5px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12.5px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:17.5px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div><a href="javascript:" class="sidebar-menu-box-close">&times;</a></div><div class="mobile-header-menu-nav" id="mobile-header-menu-nav"><div class="mobile-header-menu-container"><span class="title">导航</span><ul class="mobile-header-menu-navbar"><li><a href="/"><i class="fa fa-home"></i><span>主页</span></a></li><li><a href="/archives"><i class="fa fa-archive"></i><span>归档</span></a></li><li><a href="/gitbook"><i class="fa fa-columns"></i><span>笔记</span></a></li><li><a href="/music"><i class="fa fa-music"></i><span>音乐</span></a></li><li><a href="/photo"><i class="fa fa-picture-o"></i><span>相册</span></a></li><li><a href="/collection"><i class="fa fa-envira"></i><span>收藏</span></a></li><li><a href="/about"><i class="fa fa-user"></i><span>关于</span></a></li></ul></div><div class="mobile-header-tag-container"><span class="title">标签</span><div id="mobile-header-container-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:17.5px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:15px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12.5px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Java/" style="font-size:12.5px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:17.5px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12.5px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:17.5px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div></div><div class="search-wrap"><span class="search-close">&times;</span> <a href="javascript:" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input class="search-field" placeholder="Search..." id="keywords"> <a id="search-submit" href="javascript:"><i class="fa fa-search"></i></a><div class="search-container" id="search-container"><ul class="search-result" id="search-result"></ul></div></div><div id="search-tpl"><li class="search-result-item"><a href="{url}" class="search-item-li"><span class="search-item-li-title" title="{title}">{title}</span></a></li></div><script src="/js/search.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script><div id="particles"></div><script src="/js/particles.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css"><script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script><script src="/js/animate.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0,scale:.5},log:!1})</script></body></html>