<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Access-Control-Allow-Origin" content="*"><script type="text/javascript">var start_time=(new Date).getTime()</script><meta http-equiv="Cache-Control" content="no-cache"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="google-site-verification" content="9Wt3lmnrT2bfjaHla5s16adhvcQcBHO7PtNf97n5Od0"><meta name="baidu-site-verification" content="RYlYHsgO7Y"><meta name="sogou_site_verification" content="MSmrTj7lHV"><meta name="shenma-site-verification" content="e4428ccce0f22fad61c3716193bf4bd7_1571416388"><meta name="baidu_union_verify" content="584bb6b4bd24108df082b6d20c7aa9be"><title>推荐系列-实战 - 使用 Kotlin Flow 构建数据流 -管道- | 狂欢马克思</title><meta name="keywords" content="分享技术经验与交流"><meta name="description" content="&amp;emsp;&amp;emsp;ow 是一种基于流的编程模型，本文我们将向大家介绍响应式编程以及其在 Android 开发中的实践，您将了解到如何将生命周期、旋转及切换到后台等状态绑定到 Flow 中，并且测试它们是否能按照预…"><meta property="og:type" content="article"><meta property="og:title" content="推荐系列-实战 - 使用 Kotlin Flow 构建数据流 -管道-"><meta property="og:url" content="https://www.hosiang.cn/5842f04c/index.html"><meta property="og:site_name" content="狂欢马克思"><meta property="og:description" content="&amp;emsp;&amp;emsp;ow 是一种基于流的编程模型，本文我们将向大家介绍响应式编程以及其在 Android 开发中的实践，您将了解到如何将生命周期、旋转及切换到后台等状态绑定到 Flow 中，并且测试它们是否能按照预…"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-01-12T03:53:55.000Z"><meta property="article:modified_time" content="2022-05-19T04:45:10.445Z"><meta property="article:author" content="Howe Hsiang"><meta property="article:tag" content="Popular"><meta name="twitter:card" content="summary"><link rel="icon" href="/images/favicon.ico"><link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/font-awesome-animation/0.1.0/font-awesome-animation.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3cd8fa109426bf3f10bd5c362175bace";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.2.0"></head><script src="/js/jquery.min.js"></script><script src="/js/pace.min.js"></script><script src="/js/crypto-js.js"></script><script src="/js/cookie.js"></script><script src="/js/calendar.js"></script><script src="/js/festival.js"></script><script>getFestival()</script><body><script>window.onload=function(){document.getElementById("TimeShow").innerHTML="本站耗时 "+((new Date).getTime()-start_time)/1e3+" 秒 "}</script><div id="container"><header id="header"><div id="banner"></div><div id="header-outer"><div id="header-menu" class="header-menu-pos animated"><div class="header-menu-container"><a href="/" class="left"><span class="site-title">狂欢马克思</span></a><nav id="header-menu-nav" class="right"><a href="/" rel="external nofollow"><i class="fa fa-home"></i> <span>主页</span> </a><a href="/archives" rel="external nofollow"><i class="fa fa-archive"></i> <span>归档</span> </a><a href="/gitbook" rel="external nofollow"><i class="fa fa-columns"></i> <span>笔记</span> </a><a href="/music" rel="external nofollow"><i class="fa fa-music"></i> <span>音乐</span> </a><a href="/photo" rel="external nofollow"><i class="fa fa-picture-o"></i> <span>相册</span> </a><a href="/love" rel="external nofollow"><i class="fa fa-heart"></i> <span>恋爱</span> </a><a href="/collection" rel="external nofollow"><i class="fa fa-envira"></i> <span>收藏</span> </a><a href="/about" rel="external nofollow"><i class="fa fa-user"></i> <span>关于</span></a></nav><a class="mobile-header-menu-button"><i class="fa fa-bars"></i></a></div></div><div id="header-row"><div id="logo"><a href="/"><img src="/../images/logo.png" alt="logo"></a></div><div class="header-info"><div id="header-title"><h2>狂欢马克思</h2></div><div id="header-description"><h3>专注Web开发</h3></div></div><nav class="header-nav"><div class="social"><a title="Github" target="_blank" href="//github.com/Hosiang1026" rel="external nofollow"><i class="fa fa-github fa-2x"></i></a> <a title="QQ" target="_blank" href="//wpa.qq.com/msgrd?v=3&uin=641904695&site=qq&menu=yes" rel="external nofollow"><i class="fa fa-qq fa-2x"></i></a> <a title="Weibo" target="_blank" href="//www.weibo.com/haoxiang969" rel="external nofollow"><i class="fa fa-weibo fa-2x"></i></a></div></nav></div><div id="noticeId" class="show" style="background:rgb(244,247,247,.3)"><marquee id="noticeMar" behavior="scoll" class="notice" direction="left" onmouseover="this.stop()" onmouseout="this.start()"></marquee></div><script type="text/javascript">function browserRedirect(){var n=navigator.userAgent.toLowerCase(),a="ipad"==n.match(/ipad/i),i="iphone os"==n.match(/iphone os/i),o="midp"==n.match(/midp/i),e="rv:1.2.3.4"==n.match(/rv:1.2.3.4/i),s="ucweb"==n.match(/ucweb/i),t="android"==n.match(/android/i),d="windows ce"==n.match(/windows ce/i),p="windows mobile"==n.match(/windows mobile/i),r="",c=randomColor(),r=a||i||o||e||s||t||d||p?($("#noticeId").css({"line-height":"1.6em"}),"<font style='color:"+c+"' face='新华宋体'  size='2'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='hitokoto'></span></span></span><span id='YQData'></font> "):($("#noticeId").css({"line-height":"3.6em","margin-top":"20px"}),"<font style='color:"+c+"' face='新华宋体'  size='6'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='hitokoto'></span></span><span id='YQData'></span></font> ");$("#noticeMar").html(r)}function randomColor(){for(var n="0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f".split(","),a="#",i=0;i<6;i++)a+=n[Math.floor(16*Math.random())];return a}$(function(){browserRedirect()})</script></div></header><script>console.log=function(){}</script><div class="outer"><section id="main" class="body-wrap"><article id="post-实战 - 使用 Kotlin Flow 构建数据流 -管道-" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="post-title" itemprop="name">推荐系列-实战 - 使用 Kotlin Flow 构建数据流 -管道-</h1><div class="post-title-bar"><ul><li><i class="fa fa-book"></i> <a href="/categories/热门文章/">热门文章</a></li><li><i class="fa fa-calendar"></i> 2022-01-12</li><li><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span></li><li><span class="post-count">字数统计: 5.3k字</span></li><li><span class="post-count">阅读时长: 19分钟</span></li></ul></div></header><div class="article-entry post-content" itemprop="articleBody"><p>&amp;emsp;&amp;emsp;ow 是一种基于流的编程模型，本文我们将向大家介绍响应式编程以及其在 Android 开发中的实践，您将了解到如何将生命周期、旋转及切换到后台等状态绑定到 Flow 中，并且测试它们是否能按照预…</p><span id="more"></span><p>Flow 是一种基于流的编程模型，本文我们将向大家介绍响应式编程以及其在 Android 开发中的实践，您将了解到如何将生命周期、旋转及切换到后台等状态绑定到 Flow 中，并且测试它们是否能按照预期执行。<br>如果您更喜欢通过视频了解此内容，请 点击此处 查看。</p><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>△ 加载数据流的过程<br>每款 Android 应用都需要以某种方式收发数据，比如从数据库获取用户名、从服务器加载文档，以及对用户进行身份验证等。接下来，我们将介绍如何将数据加载到 Flow，然后经过转换后暴露给视图进行展示。<br>为了大家更方便地理解 Flow，我们以 Pancho (潘乔) 的故事来展开。当住在山上的 Pancho 想从湖中获取淡水时，会像大多数新手一开始一样，拿个水桶走到湖边取水，然后再走回来。</p><p>△ 山上的 Pancho<br>但有时 Pahcho 不走运，走到湖边时发现湖水已经干涸，于是就不得不再去别处寻找水源。发生了几次这种情况后，Pancho 意识到，搭建一些基础设施可以解决这个问题。于是他在湖边安装了一些管道，当湖中有水时，只用拧开水龙头就能取到水。知道了如何安装管道，就能很自然地想到从多个水源地把管道组合，这样一来 Pancho 就不必再检查湖水是否已经干涸。</p><p>△ 铺设管道<br>在 Android 应用中您可以简单地在每次需要时请求数据，例如我们可以使用挂起函数来实现在每次视图启动时向 ViewModel 请求数据，而后 ViewModel 又向数据层请求数据，接下来这一切又在相反的方向上发生。不过这样过了一段时间之后，像 Pancho 这样的开发者们往往会想到，其实有必要投入一些成本来构建一些基础设施，我们就可以不再请求数据而改为观察数据。观察数据就像安装取水管道一样，部署完成后对数据源的任何更新都将自动向下流动到视图中，Pancho 再也不用走到湖边去了。</p><p>△ 传统的请求数据与单向数据流</p><h4 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h4><p>我们将这类观察者会自动对被观察者对象的变化而作出反应的系统称之为响应式编程，它的另一个设计要点是保持数据只在一个方向上流动，因为这样更容易管理且不易出错。<br>某个示例应用界面的 “数据流动” 如下图所示，身份认证管理器会告诉数据库用户已登录，而数据库又必须告诉远程数据源来加载一组不同的数据；与此同时这些操作在获取新数据时都会告诉视图显示一个转圈的加载图标。对此我想说这虽然是可行的，但容易出现错误。</p><p>△ 错综复杂的 “数据流动”<br>更好的方式则是让数据只在一个方向上流动，并创建一些基础设施 (像 Pancho 铺设管道那样) 来组合和转换这些数据流，这些管道可以随着状态的变化而修改，比如在用户退出登录时重新安装管道。</p><p>△ 单向数据绑定</p><h4 id="使用-Flow"><a href="#使用-Flow" class="headerlink" title="使用 Flow"></a>使用 Flow</h4><p>可以想象对于这些组合和转换来说，我们需要一个成熟的工具来完成这些操作。在本文中我们将使用 Kotlin Flow 来实现。Flow 并不是唯一的数据流构建器，不过得益于它是协程的一部分并且得到了很好的支持。我们刚才一直用作比喻的水流，在协程库里称之为 Flow 类型，我们用泛形 T 来指代数据流承载的用户数据或者页面状态等任何类型。</p><p>△ 生产者和消费者<br>生产者会将数据 emit (发送) 到数据流中，而消费者则从数据流中 collect (收集) 这些数据。在 Android 中数据源或存储区通常是应用数据的生产者；消费者则是视图，它会把数据显示在屏幕上。<br>大多数情况下您都无需自行创建数据流，因为数据源中依赖的库，例如 DataStore、Retrofit、Room 或 WorkManager 等常见的库都已经与协程及 Flow 集成在一起了。这些库就像是水坝，它们使用 Flow 来提供数据，您无需了解数据是如何生成的，只需 “接入管道” 即可。</p><p>△ 提供 Flow 支持的库<br>我们来看一个 Room 的例子。您可以通过导出指定类型的数据流来获取数据库中发生变更的通知。在本例中，Room 库是生产者，它会在每次查询后发现有更新时发送内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@DAO</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CodelabsDAO</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Query(&quot;SELECT * FROM codelabs&quot;)</span></span><br><span class="line">    fun <span class="title function_">getAllCodelabs</span><span class="params">()</span>: Flow&lt;List&lt;Codelab&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建 Flow<br>如果您要自己创建数据流，有一些方案可供选择，比如数据流构建器。假设我们处于<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserMessagesDataSource</span><br></pre></td></tr></table></figure><br>中，当您希望频繁地在应用内检查新消息时，可以将用户消息暴露为消息列表类型的数据流。我们使用数据流构建器来创建数据流，因为 Flow 是在协程上下文环境中运行的，它以挂起代码块作为参数，这也意味着它能够调用挂起函数，我们可以在代码块中使用 while(true)来循环执行我们的逻辑。<br>在示例代码中，我们首先从 API 获取消息，然后使用 emit 挂起函数将结果添加到 Flow 中，这将挂起协程直到收集器接收到数据项，最后我们将协程挂起一段时间。在 Flow 中，操作会在同一个协程中顺序执行，使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><br>循环可以让 Flow 持续获取新消息直到观察者停止收集数据。传递给数据流构建器的挂起代码块通常被称为 “生产者代码块”。<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">UserMessagesDataSource</span>(</span><br><span class="line">    <span class="keyword">private</span> val messagesApi: MessagesApi,</span><br><span class="line">    <span class="keyword">private</span> val refreshIntervalMs: Long = <span class="number">5000</span></span><br><span class="line">) &#123;</span><br><span class="line">    val latestMessages: Floa&lt;List&lt;Message&gt;&gt; = flow &#123;</span><br><span class="line">        white(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">userMessages</span> <span class="operator">=</span> messagesApi.fetchLatestMessages()</span><br><span class="line">            emit(userMessages) <span class="comment">// 将结果发送给 Flow</span></span><br><span class="line">            delay(refreshIntervalMs) <span class="comment">// ⏰ 挂起一段时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>转换 Flow<br>在 Android 中，生产者和消费者之间的层可以使用中间运算符修改数据流来适应下一层的要求。<br>在本例中，我们将<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latestMessages</span><br></pre></td></tr></table></figure><br>流作为数据流的起点，则可以使用 map 运算符将数据转换为不同的类型，例如我们可以使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map</span><br></pre></td></tr></table></figure><br>lambda 表达式将来自数据源的原始消息转换为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessagesUiModel</span><br></pre></td></tr></table></figure><br>，这一操作可以更好地抽象当前层级，每个运算符都应根据其功能创建一个新的 Flow 来发送数据。我们还可以使用 filter 运算符过滤数据流来获得包含重要通知的数据流。而 catch 运算符则可以捕获上游数据流中发生的异常，上游数据流是指在生产者代码块和当前运算符之间调用的运算符产生的数据流，而在当前运算符之后生成的数据流则被称为下游数据流。catch 运算符还可以在有需要的时候再次抛出异常或者发送新值，我们在示例代码中可以看到其在捕获到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IllegalArgumentExceptions</span><br></pre></td></tr></table></figure><br>时将其重新抛出，并且在发生其他异常时发送一个空列表:<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val importantUserMessages: Flow&lt;MessageUiModel&gt; = </span><br><span class="line">  userMessageDataSource.latestMessages</span><br><span class="line">      .map &#123; userMessage -&gt;</span><br><span class="line">          userMessages.toUiModel()</span><br><span class="line">      &#125;</span><br><span class="line">      .filter &#123; messageUiModel -&gt;</span><br><span class="line">          messagesUiModel.containsImportantNotifications()</span><br><span class="line">      &#125;</span><br><span class="line">      .<span class="keyword">catch</span> &#123; e -&gt;</span><br><span class="line">          analytics.log(<span class="string">&quot;Error loading reserved event&quot;</span>)</span><br><span class="line">          <span class="keyword">if</span> (e is IllegalArgumentException) <span class="keyword">throw</span> e</span><br><span class="line">          <span class="keyword">else</span> emit(emptyList())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>收集 Flow<br>现在我们已经了解过如何生成和修改数据流，接下来了解一下如何收集数据流。收集数据流通常发生在视图层，因为这是我们想要在屏幕上显示数据的地方。<br>在本例中，我们希望列表中能够显示最新消息以便 Pancho 能够了解最新动态。我们可以使用终端运算符<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect</span><br></pre></td></tr></table></figure><br>来监听数据流发送的所有值，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect</span><br></pre></td></tr></table></figure><br>接收一个函数作为参数，每个新值都会调用该参数，并且由于它是一个挂起函数，因此需要在协程中执行。<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  userMessages.collect &#123; messages -&gt;</span><br><span class="line">    listAdapter.submitList(messages)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 Flow 中使用终端运算符将按需创建数据流并开始发送值，而相反的是中间操作符只是设置了一个操作链，其会在数据被发送到数据流时延迟执行。每次对<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMessages</span><br></pre></td></tr></table></figure><br>调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect</span><br></pre></td></tr></table></figure><br>时都会创建一个新的数据流，其生产者代码块将根据自己的时间间隔开始刷新来自 API 的���息。在协程中我们将这种按需创建并且只有在被观察时才会发送数据的数据流称之为 冷流 (Cold Stream)。<p></p><h4 id="在-Android-视图上收集数据流"><a href="#在-Android-视图上收集数据流" class="headerlink" title="在 Android 视图上收集数据流"></a>在 Android 视图上收集数据流</h4><p>在 Android 的视图中收集数据流要注意两点，第一是在后台运行时不应浪费资源，第二是配置变更。<br>安全收集<br>假设我们在<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessagesActivity</span><br></pre></td></tr></table></figure><br>中，如果希望在屏幕上显示消息列表，则应该当界面没有显示在屏幕上时停止收集，就像是 Pancho 在刷牙或者睡觉时应该关上水龙头一样。我们有多种具有生命周期感知能力的方案，来实现当信息不在屏幕上展示就不从数据流中收集信息的功能，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">androidx.lifecycle:lifecycle-runtime-ktx</span><br></pre></td></tr></table></figure><br>包中的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lifecycle.repeatOnLifecycle(state)</span><br></pre></td></tr></table></figure><br>和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flow&lt;T&gt;.flowWithLifecycle(lifecycle, state)</span><br></pre></td></tr></table></figure><br>。您还可以在 ViewModel 中使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">androidx.lifecycle:lifecycle-livedata-ktx</span><br></pre></td></tr></table></figure><br>包里的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flow&lt;T&gt;.asLiveData(): LiveData</span><br></pre></td></tr></table></figure><br>将数据流转换为 LiveData，这样就可以像往常一样使用 LiveData 来实现这件事情。不过为了简单起见，这里推荐使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeatOnLifecycle</span><br></pre></td></tr></table></figure><br>从界面层收集数据流。<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeatOnLifecycle</span><br></pre></td></tr></table></figure><p>是一个接收<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lifecycle.State</span><br></pre></td></tr></table></figure><br>作为参数的挂起函数，该 API 具有生命周期感知能力，所以能够在当生命周期进入响应状态时自动使用传递给它的代码块启动新的协程，并且在生命周期离开该状态时取消该协程。在上面的例子中，我们使用了 Activity 的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope</span><br></pre></td></tr></table></figure><br>来启动协程，由于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeatOnLifecycle</span><br></pre></td></tr></table></figure><br>是挂起函数，所以它需要在协程中被调用。最佳实践是在生命周期初始化时调用该函数，就像上面的例子中我们在 Activity 的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onCreate</span><br></pre></td></tr></table></figure><br>中调用一样:<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> androidx.lifecycle.repeatOnLifecycle</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessagesActivity</span> : AppCompatActivity() &#123;</span><br><span class="line"> </span><br><span class="line">    val viewModel: MessagesViewModel by <span class="title function_">viewModels</span><span class="params">()</span></span><br><span class="line"> </span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">           </span><br><span class="line">            lifecycleScope.launch &#123;</span><br><span class="line">                repeatOnLifecycle(Lifecycle.State.STARTED)</span><br><span class="line">                    viewModel.userMessages.collect &#123; messages -&gt;</span><br><span class="line">                        listAdapter.submitList(messages)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 协程将会在 lifecycle 进入 DESTROYED 后被恢复</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeatOnLifecycle</span><br></pre></td></tr></table></figure><p>的可重启行为充分考虑了界面的生命周期，不过需要注意的是，直到生命周期进入<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESTROYED</span><br></pre></td></tr></table></figure><br>，调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeatOnLifecycle</span><br></pre></td></tr></table></figure><br>的协程都不会恢复执行，因此如果您需要从多个数据流中进行收集，则应在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeatOnLifecycle</span><br></pre></td></tr></table></figure><br>代码块内多次使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launch</span><br></pre></td></tr></table></figure><br>来创建协程:<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  lifecycleScope.launch &#123;</span><br><span class="line">    repeatOnLifecycle(Lifecycle.State.STARTED) &#123;</span><br><span class="line"> </span><br><span class="line">            launch &#123;</span><br><span class="line">                viewModel.userMessages.collect &#123; … &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            launch &#123;</span><br><span class="line">                otherFlow.collect &#123; … &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果只需从一个数据流中进行收集，则可使用<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowWithLifecycle</span><br></pre></td></tr></table></figure><br>来收集数据，它能够在生命周期进入目标状态时发送数据，并在离开目标状态时取消内部的生产者:<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  lifecycleScope.launch &#123;</span><br><span class="line">    viewModel.userMessages</span><br><span class="line">        .flowWithLifecycle(lifecycle, State.STARTED)</span><br><span class="line">        .collect &#123; messages -&gt;</span><br><span class="line">            listAdapter.submitList(messages)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了能够直观地展示具体的运作过程，我们来探索一下此 Activity 的生命周期，首先是创建完成并向用户可见；接下来用户按下了主屏幕按钮将应用退到后台，此时 Activity 会收到<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onStop</span><br></pre></td></tr></table></figure><br>信号；当重新打开应用时又��调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onStart</span><br></pre></td></tr></table></figure><br>。如果您调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeatOnLifecycle</span><br></pre></td></tr></table></figure><br>并传入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STARTED</span><br></pre></td></tr></table></figure><br>状态，界面就只会在屏幕上显示时收集数据流发出的信号，并且在应用转到后台时取消收集。<p></p><p>△ Activity 的生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeatOnLifecycle</span><br></pre></td></tr></table></figure><p>和<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowWithLifecycle</span><br></pre></td></tr></table></figure><br>是 lifecycle-runtime-ktx 库在 2.4.0 稳定版中新增的 API，在没有这些 API 之前您可能已经以其他方式从 Android 界面中收集数据流，例如像上面的代码一样直接从 lifecycleScope.launch 启动的协程中收集，虽然这样看起来也能工作但不一定安全，因为这种方式将持续从数据流中收集数据并更新界面元素，即便是应用退出到后台时也一样。如果使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchWhenStarted</span><br></pre></td></tr></table></figure><br>替代它的话，情况会稍微好一些，因为它会在处于后台时将收集挂起。但这样会在让数据流生产者保持活跃状态，有可能会在后台持续发出不需要在屏幕上显示的数据项，从而将内存占满。由于界面并不知道数据流生产者的实现方式，所以最好谨慎一些，使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeatOnLifecycle</span><br></pre></td></tr></table></figure><br>或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowWithLifecycle</span><br></pre></td></tr></table></figure><br>来避免界面在处于后台时收集数据或保持数据流生产者处于活跃状态。<br>下面是一段不安全的使用方式示例:<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">MessagesActivity</span> : AppCompatActivity() &#123;</span><br><span class="line"> </span><br><span class="line">    val viewModel: MessagesViewModel by <span class="title function_">viewModels</span><span class="params">()</span></span><br><span class="line"> </span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// ❌ 危险的操作</span></span><br><span class="line">            lifecycleScope.launch &#123;</span><br><span class="line">                viewModel.userMessage.collect &#123; messages -&gt;</span><br><span class="line">                    listAdapter.submitList(messages)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// ❌ 危险的操作</span></span><br><span class="line">            LifecycleCoroutineScope.launchWhenX &#123;</span><br><span class="line">                flow.collect &#123; … &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置变更<br>当您向视图暴露数据流时，必须要考虑到您正在尝试在具有不同生命周期的两个元素之间传递数据，并不是所有生命周期都会出现问题，但在 Activity 和 Fragment 的生命周期里会比较棘手。当设备旋转或者接收到配置变更时，所有的 Activity 都可能会重启但 ViewModel 却能被保留，因此您不能把任意数据流都简单地从 ViewModel 中暴露出来。</p><p>△ 旋转屏幕会重建 Activity 但能够保留 ViewModel<br>以如下代码中的冷流为例，由于每次收集冷流时它都会重启，所以在设备旋转之后会再次调用<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repository.fetchItem()</span><br></pre></td></tr></table></figure><br>。我们需要某种缓冲区机制来保障无论重新收集多少次都可以保持数据，并在多个收集器之间共享数据，而<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StateFlow</span><br></pre></td></tr></table></figure><br>正是为了此用途而设计的。在我们的湖泊比喻中，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StateFlow</span><br></pre></td></tr></table></figure><br>就好比水箱，即使没有收集器它也能持有数据。因为它可以多次被收集，所以能够放心地将其与 Activity 或 Fragment 一起使用。<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  val result: Flow&lt;Result&lt;UiState&gt;&gt; = flow &#123;</span><br><span class="line">    emit(repository.fetchItem())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>您可以使用<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StateFlow</span><br></pre></td></tr></table></figure><br>的可变版本，并随时根据需要在协程中更新它的值，但这样做可能不太符合响应式编程的风格，如下代码所示:<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="type">val</span> <span class="variable">_myUiState</span> <span class="operator">=</span> MutableStateFlow&lt;MyUiState&gt;()</span><br><span class="line"> </span><br><span class="line">val myUiState: StateFlow&lt;MyUiState&gt; = _myUiState</span><br><span class="line"> </span><br><span class="line">init &#123;</span><br><span class="line">    viewModelScope.launch &#123;</span><br><span class="line">        _muUiState.value = Result.Loading</span><br><span class="line">        _myUiState.value = repository.fetchStuff()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Pancho 会建议您将各种类型的数据流都转换为<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StateFlow</span><br></pre></td></tr></table></figure><br>来改进��个问题，这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StateFlow</span><br></pre></td></tr></table></figure><br>将接收来自上游数据流的所有更新并存储最新的值，并且收集器的数量可以是 0 至任意多个，因此非常适合与<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewModel</span><br></pre></td></tr></table></figure><br>一起使用。当然，除此之外还有一些其他类型的 Flow，但推荐您使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StateFlow</span><br></pre></td></tr></table></figure><br>，因为我们可以对它进行非常精确的优化。<p></p><p>△ 将任意数据流转换为 StateFlow<br>要将数据流转换为<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StateFlow</span><br></pre></td></tr></table></figure><br>可以使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stateIn</span><br></pre></td></tr></table></figure><br>运算符，它需要传入三个参数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initinalValue</span><br></pre></td></tr></table></figure><br>、<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scope</span><br></pre></td></tr></table></figure><br>及<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">started</span><br></pre></td></tr></table></figure><br>。其中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initialValue</span><br></pre></td></tr></table></figure><br>是因为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StateFlow</span><br></pre></td></tr></table></figure><br>必须有值；而协程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scope</span><br></pre></td></tr></table></figure><br>则是用于控制何时开始共享，在上面的例子中我们使用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewModelScope</span><br></pre></td></tr></table></figure><br>；最后的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">started</span><br></pre></td></tr></table></figure><br>是个有趣的参数，我们后面会聊到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WhileSubscribed(<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><br>的作用，先看这部分的代码:<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val result: StateFlow&lt;Result&lt;UiState&gt;&gt; = someFlow</span><br><span class="line">  .stateIn(</span><br><span class="line">      initialValue = Result.<span class="type">Loading</span></span><br><span class="line">      <span class="variable">scope</span> <span class="operator">=</span> viewModelScope,</span><br><span class="line">      started = WhileSubscribed(<span class="number">5000</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们来看看这两个场景: 第一种场景是旋转，在该场景中 Activity (也就是数据流收集器) 在短时间内被销毁然后重建；第二个场景是回到主屏幕，这将会使我们的应用进入后台。在旋转场景中我们不希望重启任何数据流以便尽可能快地完成过渡，而在回到主屏幕的场景中我们则希望停止所有数据流以便节省电量和其他资源。<br>我们可以通过设置超时时间来正确判断不同的场景，当停止收集 StateFlow时，不会立即停止所有上游数据流，而是会等待一段时间，如果在超时前再次收集数据则不会取消上游数据流，这就是<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WhileSubscribed(<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><br>的作用。当设置了超时时间后，如果按下主屏幕按钮会让视图立即结束收集，但<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StateFlow</span><br></pre></td></tr></table></figure><br>会经过我们设置的超时时间之后才会停止其上游数据流，如果用户再次打开应用则会自动重启上游数据流。而在旋转场景中视图只停止了很短的时间，无论如何都不会超过 5 秒钟，因此 StateFlow 并不会重启，所有的上游数据流都将会保持在活跃状态，就像什么都没有发生一样可以做到即时向用户呈现旋转后的屏幕。<p></p><p>△ 设置超时时间来应对不同的场景<br>总的来说，建议您使用<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StateFlow</span><br></pre></td></tr></table></figure><br>来通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewModel</span><br></pre></td></tr></table></figure><br>暴露数据流，或者使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asLiveData</span><br></pre></td></tr></table></figure><br>来实现同样的目的，关于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StateFlow</span><br></pre></td></tr></table></figure><br>或其父类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharedFlow</span><br></pre></td></tr></table></figure><br>的更多详细信息，请参阅: StateFlow 和 SharedFlow。<p></p><h4 id="测试数据流"><a href="#测试数据流" class="headerlink" title="测试数据流"></a>测试数据流</h4><p>测试数据流可能会比较复杂，因为要处理的对象是流式数据，这里介绍在两个不同的场景中有用的小技巧:<br>首先是第一个场景，被测单元依赖了数据流，那对此类场景进行测试最简单的方法就是用模拟生产者替代依赖项。在本例中，您可以对这个模拟源进行编程以对不同的测试用例发送其所需要的内容。您可以像上面的例子一样实现一个简单的冷流，测试本身会对受测对象的输出进行断言，输出的内容可以是数据流或其他任何类型。</p><p>△ ��测单元依赖数据流的测试技巧<br>模拟被测单元所依赖的数据流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">MyFakeRepository</span> : MyRepository &#123;</span><br><span class="line">    fun <span class="title function_">observeCount</span><span class="params">()</span> = flow &#123;</span><br><span class="line">        emit(ITEM_1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果受测单元暴露一个数据流，并且您希望验证该值或一系列值，那么您可以通过多种方式收集它们。您可以对数据流调用 first() 方法以进行收集并在接收到第一个数据项后停止收集。您还可以调用 take(5) 并使用 toList 终端操作符来收集恰好 5 条消息，这种方法可能非常有帮助。</p><p>△ 测试数据流的技巧<br>测试数据流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">fun <span class="title function_">myTest</span><span class="params">()</span> = runBlocking &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 收集第一个数据然后停止收集</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">firstItem</span> <span class="operator">=</span> repository.counter.first()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 收集恰好 5 条消息</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">first</span> <span class="operator">=</span> repository.messages.take(<span class="number">5</span>).toList()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>感谢阅读本文，希望您通过本文内容已经了解到为什么响应式架构值得投资，以及如何使用 Kotlin Flow 构建您的基础设施。文末提供了有关这方面的资料，包括涵盖基础知识的指南以及深入探讨某些主题的文章。另外您还可以通过 Google I&#x2F;O 应用了解这些内容的详细信息，我们在早些时候为其更新了很多有关数据流的内容。</p><p>指南: Android 上的 Kotlin 数据流<br>使用更为安全的方式收集 Android UI 数据流<br>从 LiveData 迁移到 Kotlin 数据流<br>Flow 操作符 shareIn 和 stateIn 使用须知<br>设计 repeatOnLifecycle API 背后的故事<br>示例代码: Google I&#x2F;O 应用</p><p>欢迎您 点击这里 向我们提交反馈，或分享您喜欢的内容、发现的问题。您的反馈对我们非常重要，感谢您的支持！</p><div class="post-copyright"><div class="content"><p>本文标题： 推荐系列-实战 - 使用 Kotlin Flow 构建数据流 -管道-</p><p>本文作者： OSChina</p><p>发布时间： 2022年01月12日 11:53</p><p>最后更新： 2022年05月19日 12:45</p><p>原始链接： <a class="post-url" href="/5842f04c/" title="推荐系列-实战 - 使用 Kotlin Flow 构建数据流 -管道-">https://www.hosiang.cn/5842f04c/</a></p><p>版权声明： 本文著作权归作者所有，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a>许可协议，转载请注明出处！</p><footer><a href="https://www.hosiang.cn"><img src="/../images/logo.png" alt="Howe Hsiang"> Howe Hsiang</a></footer></div></div><div class="page-reward"><a id="rewardBtn" href="javascript:;">赏</a></div><div id="reward" class="post-modal reward-lay"><a class="close" href="javascript:;" id="reward-close">×</a> <span class="reward-title"><i class="icon icon-quote-left"></i> 喜欢就赞赏一下呗！ <i class="icon icon-quote-right"></i></span><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="/images/threepay_code.jpg" alt="打赏二维码"></div><div class="reward-select"></div></div></div></div><footer class="article-footer"><div class="post-share"><a href="javascript:" id="share-sub" class="post-share-fab"><i class="fa fa-share-alt" style="padding-top:11px!important"></i></a><div class="post-share-list" id="share-list"><ul class="share-icons"><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.hosiang.cn/5842f04c/" data-title="Facebook" rel="external nofollow noopener noreferrer"><i class="fa fa-facebook" style="padding-top:9px!important"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《推荐系列-实战 - 使用 Kotlin Flow 构建数据流 -管道-》 — 狂欢马克思&url=https://www.hosiang.cn/5842f04c/&via=https://www.hosiang.cn" data-title="Twitter" rel="external nofollow noopener noreferrer"><i class="fa fa-twitter" style="padding-top:9px!important"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.hosiang.cn/5842f04c/" data-title="Google+" rel="external nofollow noopener noreferrer"><i class="fa fa-google-plus" style="padding-top:9px!important"></i></a></li><li><a class="qq share-sns" target="_blank" href="https://connect.qq.com/widget/shareqq/index.html?url=https://www.hosiang.cn/5842f04c/&title=《推荐系列-实战 - 使用 Kotlin Flow 构建数据流 -管道-》 — 狂欢马克思&source=&amp;emsp;&amp;emsp;ow 是一种基于流的编程模型，本文我们将向大家介绍响应式编程以及其在 Android 开发中的实践，您将了解到如何..." data-title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-qq" style="padding-top:9px!important"></i></a></li><li><a class="weixin share-sns" id="wxFab" href="javascript:" data-title="微信"><i class="fa fa-weixin" style="padding-top:9px!important"></i></a></li><li><a class="weibo share-sns" target="_blank" href="https://service.weibo.com/share/share.php?url=https://www.hosiang.cn/5842f04c/&title=《推荐系列-实战 - 使用 Kotlin Flow 构建数据流 -管道-》 — 狂欢马克思&pic=https://devrel.andfun.cn/devrel/posts/2022/03/lSSdLk.png" data-title="微博" rel="external nofollow noopener noreferrer"><i class="fa fa-weibo" style="padding-top:9px!important"></i></a></li></ul></div></div><div class="post-modal wx-share" id="wxShare"><a class="close" href="javascript:" id="wxShare-close">×</a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://www.hosiang.cn/5842f04c/" alt="微信分享二维码"></div><div class="mask"></div><ul class="article-footer-menu"><li class="article-footer-tags"><i class="fa fa-tags"></i> <a href="/tags/Popular/" class="color3">Popular</a></li></ul></footer></div></article><aside class="post-toc-pos post-toc-top" id="post-toc"><nav class="post-toc-wrap"><ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="post-toc-text">单向数据流</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="post-toc-text">响应式编程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8-Flow"><span class="post-toc-text">使用 Flow</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9C%A8-Android-%E8%A7%86%E5%9B%BE%E4%B8%8A%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="post-toc-text">在 Android 视图上收集数据流</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="post-toc-text">测试数据流</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9B%9E%E9%A1%BE"><span class="post-toc-text">回顾</span></a></li></ol></nav></aside><nav id="article-nav"><a href="/f279a8b9/" id="article-nav-newer" class="article-nav-link-wrap"><span class="article-nav-title"><i class="fa fa-hand-o-left" aria-hidden="true"></i> 推荐系列-eBay 基于 Apache Kyuubi 构建统一 Serverless Spark 网关的实践 </span></a><a href="/b337f0f5/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">推荐系列-字节跳动流式数据集成基于Flink Checkpoint两阶段提交的实践和优化</span> <i class="fa fa-hand-o-right" aria-hidden="true"></i></a></nav><div id="gitalk"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({repo:"bolg-comment",owner:"Hosiang1026",admin:"Hosiang1026",clientID:"37a2dd4473e8970cecc2",clientSecret:"e30efa17d86d9de4f4ab810872dc62a7b2e7e634",pagerDirection:"last",distractionFreeMode:!0,createIssueManually:!1});gitalk.render("gitalk")</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"><script id="_wau78w">var _wau=_wau||[];_wau.push(["small","5dnguv4c2n","78w"])</script><script async src="//waust.at/s.js"></script><p><span id="busuanzi_container_site_uv" style="display:none"><span class="post-count">总字数：<span>1777.3k</span> </span>总访客数：<span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" style="display:none">总访问量：<span id="busuanzi_value_site_pv"></span></span><br><span id="TimeShow">本站</span><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br>Copyright&copy; 2018 - 2022 狂欢马克思 <a href="https://beian.miit.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">京ICP备17060439号</a></p></div></div><script>var now=new Date;function createtime(){var n=new Date("2017/09/18");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",800)</script></footer><script>var mihoConfig={root:"https://www.hosiang.cn",animate:"true",isHome:"false",share:"true",reward:" 1"}</script><div class="sidebar"><div id="sidebar-search" title="Search"><i class="fa fa-search"></i></div><div id="sidebar-category" title="Categories"><i class="fa fa-book"></i></div><div id="sidebar-tag" title="Tags"><i class="fa fa-tags"></i></div><div id="sidebar-top"><span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span></div></div><div class="sidebar-menu-box" id="sidebar-menu-box"><div class="sidebar-menu-box-container"><div id="sidebar-menu-box-categories"><a class="category-link" href="/categories/%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD/">兴趣爱好</a><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/">其他开发</a><a class="category-link" href="/categories/%E5%89%8D%E6%B2%BF%E5%BC%80%E5%8F%91/">前沿开发</a><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a><a class="category-link" href="/categories/%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/">升级版本</a><a class="category-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">博客教程</a><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="category-link" href="/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</a><a class="category-link" href="/categories/%E7%83%AD%E9%97%A8%E6%96%87%E7%AB%A0/">热门文章</a></div><div id="sidebar-menu-box-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:17.5px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:15px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12.5px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Java/" style="font-size:12.5px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:17.5px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12.5px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:17.5px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div><a href="javascript:" class="sidebar-menu-box-close">&times;</a></div><div class="mobile-header-menu-nav" id="mobile-header-menu-nav"><div class="mobile-header-menu-container"><span class="title">导航</span><ul class="mobile-header-menu-navbar"><li><a href="/"><i class="fa fa-home"></i><span>主页</span></a></li><li><a href="/archives"><i class="fa fa-archive"></i><span>归档</span></a></li><li><a href="/gitbook"><i class="fa fa-columns"></i><span>笔记</span></a></li><li><a href="/music"><i class="fa fa-music"></i><span>音乐</span></a></li><li><a href="/photo"><i class="fa fa-picture-o"></i><span>相册</span></a></li><li><a href="/love"><i class="fa fa-heart"></i><span>恋爱</span></a></li><li><a href="/collection"><i class="fa fa-envira"></i><span>收藏</span></a></li><li><a href="/about"><i class="fa fa-user"></i><span>关于</span></a></li></ul></div><div class="mobile-header-tag-container"><span class="title">标签</span><div id="mobile-header-container-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:17.5px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:15px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12.5px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Java/" style="font-size:12.5px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:17.5px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12.5px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:17.5px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div></div><div class="search-wrap"><span class="search-close">&times;</span> <a href="javascript:" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input class="search-field" placeholder="Search..." id="keywords"> <a id="search-submit" href="javascript:"><i class="fa fa-search"></i></a><div class="search-container" id="search-container"><ul class="search-result" id="search-result"></ul></div></div><div id="search-tpl"><li class="search-result-item"><a href="{url}" class="search-item-li"><span class="search-item-li-title" title="{title}">{title}</span></a></li></div><script src="/js/search.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script><div id="particles"></div><script src="/js/particles.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css"><script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script><script src="/js/animate.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0,scale:.5},log:!1})</script></body></html>