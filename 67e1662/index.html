<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Access-Control-Allow-Origin" content="*"><script type="text/javascript">var start_time=(new Date).getTime()</script><meta http-equiv="Cache-Control" content="no-cache"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="baidu-site-verification" content="codeva-JcuFKkCTW2"><meta name="google-site-verification" content="GOa_MDr6Uz7cL7SHoNQIoPhiBCMp1WMlUeUa8avuIOg"><meta name="360-site-verification" content="2a299bcaf5d0e17606cbc47c55252c34"><meta name="baidu_union_verify" content="7fdc0fcf59a6c750e39da4f72040c01e"><title>推荐系列- 自动化回归测试平台 AREX Agent 源码再阅读 | 狂欢马克思</title><meta name="keywords" content="分享技术经验与交流"><meta name="description" content="&amp;emsp;&amp;emsp;EX 启动过程 通用 Java Agent 的启动过程 Java Agent 是一种 Java 应用程序，它可以在 Java 应用程序启动时动态地注入到 JVM 中，并在应用程序运行时监视和修改应用程序的行为。Java Agen…"><meta property="og:type" content="article"><meta property="og:title" content="推荐系列- 自动化回归测试平台 AREX Agent 源码再阅读"><meta property="og:url" content="https://haoxiang.eu.org/67e1662/index.html"><meta property="og:site_name" content="狂欢马克思"><meta property="og:description" content="&amp;emsp;&amp;emsp;EX 启动过程 通用 Java Agent 的启动过程 Java Agent 是一种 Java 应用程序，它可以在 Java 应用程序启动时动态地注入到 JVM 中，并在应用程序运行时监视和修改应用程序的行为。Java Agen…"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-05-24T01:23:09.000Z"><meta property="article:modified_time" content="2023-06-29T07:10:21.048Z"><meta property="article:author" content="Howe Hsiang"><meta property="article:tag" content="Popular"><meta name="twitter:card" content="summary"><link rel="icon" href="/images/favicon.ico"><link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/font-awesome-animation/0.1.0/font-awesome-animation.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3cd8fa109426bf3f10bd5c362175bace";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.3.0"></head><script src="/js/jquery.min.js"></script><script src="/js/pace.min.js"></script><script src="/js/crypto-js.js"></script><script src="/js/cookie.js"></script><script src="/js/calendar.js"></script><script src="/js/festival.js"></script><script>getFestival()</script><body><script>window.onload=function(){document.getElementById("TimeShow").innerHTML="本站耗时 "+((new Date).getTime()-start_time)/1e3+" 秒 "}</script><div id="container"><header id="header"><div id="banner"></div><div id="header-outer"><div id="header-menu" class="header-menu-pos animated"><div class="header-menu-container"><a href="/" class="left"><span class="site-title">狂欢马克思</span></a><nav id="header-menu-nav" class="right"><a href="/" rel="external nofollow"><i class="fa fa-home"></i> <span>主页</span> </a><a href="/archives" rel="external nofollow"><i class="fa fa-archive"></i> <span>归档</span> </a><a href="/gitbook" rel="external nofollow"><i class="fa fa-columns"></i> <span>笔记</span> </a><a href="/photo" rel="external nofollow"><i class="fa fa-picture-o"></i> <span>相册</span> </a><a href="/love" rel="external nofollow"><i class="fa fa-heart"></i> <span>恋爱</span> </a><a href="/collection" rel="external nofollow"><i class="fa fa-envira"></i> <span>收藏</span> </a><a href="/about" rel="external nofollow"><i class="fa fa-user"></i> <span>关于</span></a></nav><a class="mobile-header-menu-button"><i class="fa fa-bars"></i></a></div></div><div id="header-row"><div id="logo"><a href="/"><img src="/../images/logo.png" alt="logo"></a></div><div class="header-info"><div id="header-title"><h2>狂欢马克思</h2></div><div id="header-description"><h3>专注Web开发</h3></div></div><nav class="header-nav"><div class="social"><a title="Github" target="_blank" href="//github.com/Hosiang1026" rel="external nofollow"><i class="fa fa-github fa-2x"></i></a> <a title="QQ" target="_blank" href="//wpa.qq.com/msgrd?v=3&uin=641904695&site=qq&menu=yes" rel="external nofollow"><i class="fa fa-qq fa-2x"></i></a> <a title="Weibo" target="_blank" href="//www.weibo.com/haoxiang969" rel="external nofollow"><i class="fa fa-weibo fa-2x"></i></a></div></nav></div><script type="text/javascript" src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><div id="noticeId" class="show" style="background:rgb(244,247,247,.3)"><marquee id="noticeMar" behavior="scoll" class="notice" direction="left" onmouseover="this.stop()" onmouseout="this.start()"></marquee></div><script type="text/javascript">function browserRedirect(){var i=navigator.userAgent.toLowerCase(),n="ipad"==i.match(/ipad/i),e="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),a="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),s="ucweb"==i.match(/ucweb/i),t="android"==i.match(/android/i),r="windows ce"==i.match(/windows ce/i),c="windows mobile"==i.match(/windows mobile/i),d="",m=randomColor(),d=n||e||o||a||s||t||r||c?($("#noticeId").css({"line-height":"1.6em"}),"<font style='color:"+m+"' face='新华宋体'  size='2'>官宣：<span id='msg'></span><span id='timer'></span><span id='jinrishici-sentence'></span></font> "):($("#noticeId").css({"line-height":"3.6em","margin-top":"20px"}),"<font style='color:"+m+"' face='新华宋体'  size='6'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='jinrishici-sentence'></span></font> ");$("#noticeMar").html(d)}function randomColor(){for(var i="0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f".split(","),n="#",e=0;e<6;e++)n+=i[Math.floor(16*Math.random())];return n}$(function(){browserRedirect()})</script></div></header><script>console.log=function(){}</script><div class="outer"><section id="main" class="body-wrap"><article id="post-sync/ 自动化回归测试平台 AREX Agent 源码再阅读" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="post-title" itemprop="name">推荐系列- 自动化回归测试平台 AREX Agent 源码再阅读</h1><div class="post-title-bar"><ul><li><i class="fa fa-book"></i> <a href="/categories/热门文章/">热门文章</a></li><li><i class="fa fa-calendar"></i> 2023-05-24</li><li><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span></li><li><span class="post-count">字数统计: 4.6k字</span></li><li><span class="post-count">阅读时长: 17分钟</span></li></ul></div></header><div class="article-entry post-content" itemprop="articleBody"><p>&amp;emsp;&amp;emsp;EX 启动过程 通用 Java Agent 的启动过程 Java Agent 是一种 Java 应用程序，它可以在 Java 应用程序启动时动态地注入到 JVM 中，并在应用程序运行时监视和修改应用程序的行为。Java Agen…</p><span id="more"></span><pre><code>                                                                                                                                                                                    ### AREX 启动过程 
</code></pre><h4 id="通用-Java-Agent-的启动过程"><a href="#通用-Java-Agent-的启动过程" class="headerlink" title="通用 Java Agent 的启动过程"></a>通用 Java Agent 的启动过程</h4><p>Java Agent 是一种 Java 应用程序，它可以在 Java 应用程序启动时动态地注入到 JVM 中，并在应用程序运行时监视和修改应用程序的行为。Java Agent 通常用于性能分析、代码覆盖率、安全检查等方面。<br>以下是 Java Agent 的启动过程：</p><p>编写 Java Agent 程序，实现<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">premain </span><br></pre></td></tr></table></figure><br>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">premain </span><br></pre></td></tr></table></figure><br>方法是 Java Agent 的入口方法，它会在 Java 应用程序启动时被调用。在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">premain </span><br></pre></td></tr></table></figure><br>方法中，可以进行一些初始化操作，如设置代理、加载配置文件等。<br>将 Java Agent 打包成 jar 文件，并在 MANIFEST.MF 文件中指定<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Premain-Class </span><br></pre></td></tr></table></figure><br>属性，该属性指定了 Java Agent 的入口类。<br>在启动Java应用程序时，通过 -javaagent 参数指定 Java Agent 的 jar 文件路径。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:/path/to/agent.jar -jar myapp.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>在上面的命令中，&#x2F;path&#x2F;to&#x2F;agent.jar 是 Java Agent 的 jar 文件路径，myapp.jar 是 Java 应用程序的 jar 文件路径。<br>当 Java 应用程序启动时，JVM 会加载 Java Agent 的 jar 文件，并调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">premain </span><br></pre></td></tr></table></figure><br>方法。在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">premain </span><br></pre></td></tr></table></figure><br>方法中，Java Agent 可以使用 Java Instrumentation API 来修改 Java 应用程序的字节���，实现对应用程序的监视和修改。<p></p><h4 id="AREX-源码视角的启动过程"><a href="#AREX-源码视角的启动过程" class="headerlink" title="AREX 源码视角的启动过程"></a>AREX 源码视角的启动过程</h4><h5 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h5><p>在<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arex-agent <span class="keyword">module</span> </span><br></pre></td></tr></table></figure><br>的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pom.xml</span><br></pre></td></tr></table></figure><br>文件中，通过配置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manifestEntries</span><br></pre></td></tr></table></figure><br>，将<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Premain-Class</span><br></pre></td></tr></table></figure><br>属性设置为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.arex.agent.ArexJavaAgent</span><br></pre></td></tr></table></figure><br>。这意味着在构建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arex-agent.jar</span><br></pre></td></tr></table></figure><br>时，将在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manifest</span><br></pre></td></tr></table></figure><br>文件中指定<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArexJavaAgent</span><br></pre></td></tr></table></figure><br>类作为 Agent 的入口点。<p></p><h5 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h5><p>在<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArexJavaAgent</span><br></pre></td></tr></table></figure><br>类中，实现了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">premain</span><br></pre></td></tr></table></figure><br>方法作为Agent的入口方法。在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">premain</span><br></pre></td></tr></table></figure><br>方法中，它调用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agentmain</span><br></pre></td></tr></table></figure><br>方法。在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agentmain</span><br></pre></td></tr></table></figure><br>方法中，进一步调用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init(Instrumentation inst, String agentArgs)</span><br></pre></td></tr></table></figure><br>函数。这个函数接受一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instrumentation</span><br></pre></td></tr></table></figure><br>对象和一个字符串参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agentArgs</span><br></pre></td></tr></table></figure><br>。<p></p><h5 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h5><p>在<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init</span><br></pre></td></tr></table></figure><br>函数中，有两个重要的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installBootstrapJar()</span><br></pre></td></tr></table></figure><br>和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AgentInitializer.initialize()</span><br></pre></td></tr></table></figure><br>。<p></p><h6><a href="#" class="headerlink"></a></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installBootstrapJar()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installBootstrapJar()</span><br></pre></td></tr></table></figure><p>函数根据<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AgentInitializer.class</span><br></pre></td></tr></table></figure><br>找到其所在的 jar 包，并通过调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inst.appendToBootstrapClassLoaderSearch(jar)</span><br></pre></td></tr></table></figure><br>将其添加到Bootstrap ClassLoader的搜索路径中。Bootstrap ClassLoader是Java虚拟机中负责加载核心类库（如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang</span><br></pre></td></tr></table></figure><br>和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util</span><br></pre></td></tr></table></figure><br>等）的特殊类加载器。通过调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendToBootstrapClassLoaderSearch</span><br></pre></td></tr></table></figure><br>方法，可以将自定义的类库添加到Bootstrap ClassLoader的搜索路径中，从而使得Java应用程序能够使用这些自定义的类库。<br>如要根据 class 对象或者 jar 包的实现，获取一个类所在的 jar 包，可以按照以下步骤进行：<p></p><p>获取该类的<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class</span><br></pre></td></tr></table></figure><br>对象。<br>调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class</span><br></pre></td></tr></table></figure><br>对象的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getProtectionDomain()</span><br></pre></td></tr></table></figure><br>方法获取该类的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProtectionDomain</span><br></pre></td></tr></table></figure><br>对象。<br>调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProtectionDomain</span><br></pre></td></tr></table></figure><br>对象的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getCodeSource()</span><br></pre></td></tr></table></figure><br>方法获取该类的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CodeSource</span><br></pre></td></tr></table></figure><br>对象。<br>调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CodeSource</span><br></pre></td></tr></table></figure><br>对象的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getLocation()</span><br></pre></td></tr></table></figure><br>方法获取该类所在的jar包的URL。<br>通过URL对象的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getFile()</span><br></pre></td></tr></table></figure><br>方法获取该jar包的路径。<p></p><h6 id="-1"><a href="#-1" class="headerlink"></a></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AgentInitializer.initialize()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AgentInitializer.initialize()</span><br></pre></td></tr></table></figure><p>函数是根据<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArexJavaAgent.class</span><br></pre></td></tr></table></figure><br>找到其所在的jar包（<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AgentInitializer.java</span><br></pre></td></tr></table></figure><br>文件），然后设置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arex.agent.jar.file.path</span><br></pre></td></tr></table></figure><br>变量，即代理jar包所在的目录。<br>接下来，它会在该目录下查找<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/extensions/</span><br></pre></td></tr></table></figure><br>子目录，并读取该目录下的所有jar包文件，这些文件是扩展包所在的位置。<br>然后，调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createAgentClassLoader(agent jar, 扩展包.jar)</span><br></pre></td></tr></table></figure><br>函数，创建一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AgentClassLoader</span><br></pre></td></tr></table></figure><br>对象，它是AREX自定义的类加载器。使用自定义的类加载器是为了隔离，防止应用程序能够访问AREX Agent的代码。<br>接着，调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createAgentInstaller()</span><br></pre></td></tr></table></figure><br>函数，该函数使用前面生成的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AgentClassLoader</span><br></pre></td></tr></table></figure><br>加载类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.arex.agent.instrumentation.InstrumentationInstaller</span><br></pre></td></tr></table></figure><br>，获取其构造函数并创建实例，然后返回指向<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AgentInstaller</span><br></pre></td></tr></table></figure><br>接口的对象。<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdviceClassesCollector</span><br></pre></td></tr></table></figure><p>收集代理jar文件和扩展jar文件。<br>使用指向<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AgentInstaller</span><br></pre></td></tr></table></figure><br>接口的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installer</span><br></pre></td></tr></table></figure><br>（前面返回的对象）调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install()</span><br></pre></td></tr></table></figure><br>函数，实际上会调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseAgentInstaller</span><br></pre></td></tr></table></figure><br>类的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install()</span><br></pre></td></tr></table></figure><br>函数，该函数调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init(String agentArgs)</span><br></pre></td></tr></table></figure><br>进行初始化。<br>在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseAgentInstaller</span><br></pre></td></tr></table></figure><br>类的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install()</span><br></pre></td></tr></table></figure><br>函数中，调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init()</span><br></pre></td></tr></table></figure><br>函数执行以下操作：<p></p><p>初始化<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TraceContextManager</span><br></pre></td></tr></table></figure><br>，生成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDGenerator</span><br></pre></td></tr></table></figure><br>用于生成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransactionID</span><br></pre></td></tr></table></figure><br>。<br>初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installSerializer</span><br></pre></td></tr></table></figure><br>。<br>初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RecordLimiter</span><br></pre></td></tr></table></figure><br>，设置录制频率限制。<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigService</span><br></pre></td></tr></table></figure><p>加载代理配置，包括设置调试模式、动态类配置、排除操作配置、Dubbo回放阈值、记录速率配置等。<br>初始化数据收集器，根据运行模式进行判断，并启动数据收集器。<br>再次从服务器获取代理配置，进行三次重试，然后解析配置并进行再次设置和更新（注意：存在一个BUG，第二次从服务器获取配置后，并没有看到Dubbo的回放阈值得到更新）。</p><p>在<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseAgentInstaller</span><br></pre></td></tr></table></figure><br>类的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install()</span><br></pre></td></tr></table></figure><br>函数中，调用了名为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform()</span><br></pre></td></tr></table></figure><br>的抽象函数。实际上，这个抽象函数的具体实现在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InstrumentationInstaller</span><br></pre></td></tr></table></figure><br>类的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform()</span><br></pre></td></tr></table></figure><br>函数中。<br>通过这些配置和操作，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArexJavaAgent</span><br></pre></td></tr></table></figure><br>类将被作为Agent的入口点，在Java应用程序启动时被加载，并对Bootstrap ClassLoader进行扩展，使得应用程序能够使用自定义的类库。<p></p><h5 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h5><p>在 InstrumentationInstaller 类的 transform() 函数中实现了对目标应用程序的代码注入操作。</p><p>通过 getAgentBuilder() 获取了 ByteBuddy 的 AgentBuilder。<br>通过 SPI 函数获取了所有标识为 ModuleInstrumentation.class 的类的列表，这些类使用了 com.google.auto.service 注解 @AutoService(ModuleInstrumentation.class)。<br>根据上文获取的List, 逐个调用 InstallModule()，即使用步骤 6.a 中获取的 AgentBuilder 和 ModuleInstrumentation 注册模块。<br>在 ModuleInstrumentation 类中获取了 TypeInstrumentation 的列表，针对每个 TypeInstrumentation，找到其对应的 MethodInstrumentation 列表。<br>对于每个 MethodInstrumentation，调用 AgentBuilder.Identified 的 transform() 函数进行代码注入。</p><p>简而言之，这一步过程是实现了模块化的插桩功能。通过实现 ModuleInstrumentation 接口，可以定义需要进行代码注入的模块。在每个模块中，通过实现 TypeInstrumentation 接口可以定义需要注入代码的具体类型。而在每个类型中，通过实现 MethodInstrumentation 接口可以定义需要注入代码的具体方法。这样，AREX Agent 就可以根据这些定义，将录制和回放的代码注入到相应的方法中，实现了对应功能的记录和重放。</p><h5 id="步骤五"><a href="#步骤五" class="headerlink" title="步骤五"></a>步骤五</h5><p>完成所有类的注入，完成 AREX 的启动后 AREX 开始运行。</p><h3 id="AREX-录制回放"><a href="#AREX-录制回放" class="headerlink" title="AREX 录制回放"></a>AREX 录制回放</h3><h4 id="录制回放概述"><a href="#录制回放概述" class="headerlink" title="录制回放概述"></a>录制回放概述</h4><p>AREX的录制功能不仅仅是单独录制请求报文，而是将请求、应答报文以及内部调用的请求和应答一并保存下来。核心目标是将请求、应答和内部调用的请求应答一一关联起来保存。AREX采用类似 OpenTelemetry 的 Tracing 技术，实现全链路跟踪并保存关联的 Tracing ID。</p><h5 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h5><p>录制分为入口录制和内部调用录制两部分。入口请求中没有Tracing ID，需要生成唯一的Tracing ID，并记录下来。入口录制保存请求和Tracing ID。内部调用录制保存Tracing ID和内部调用的请求、应答。<br>入口请求的响应报文也需要记录，即入口调用的应答和Tracing ID（这里提到的 Tracing ID 在后文中称为 AREX Record ID）。</p><h5 id="回放"><a href="#回放" class="headerlink" title="回放"></a>回放</h5><p>回放过程中，入口请求中包含AREX-Replay-ID和Record ID的报文。根据Record ID从数据库中获取相应的应答，并返回给调用方。同时，关联Replay ID记录回放过程中的数据并保存到数据库。<br>在内部调用过程中，如果检测到当前处于回放状态，则根据Record ID从数据库中获取数据返回（模拟应答），并记录内部调用的请求，关联Replay ID并保存到数据库。<br>根据Replay ID，找到入口调用��应答报文以及内部调用的请求报文，并进行录制场景和回放场景的差异比对。<br>最后输出差异结果，结束回放过程。</p><h4 id="AREX-Servlet-的入口录制和回放"><a href="#AREX-Servlet-的入口录制和回放" class="headerlink" title="AREX Servlet 的入口录制和回放"></a>AREX Servlet 的入口录制和回放</h4><p>代码所在目录 arex-agent-java\arex-instrumentation\servlet</p><h5 id="AREX-注入代码三要素"><a href="#AREX-注入代码三要素" class="headerlink" title="AREX 注入代码三要素"></a>AREX 注入代码三要素</h5><p>ModuleInstrumentation: FilterModuleInstrumentationV3<br>TypeInstrumentation: FilterInstrumentationV3<br>MethodInstrumentation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;MethodInstrumentation&gt; <span class="title function_">methodAdvices</span><span class="params">()</span> &#123;</span><br><span class="line">    ElementMatcher&lt;MethodDescription&gt; matcher = named(<span class="string">&quot;doFilter&quot;</span>)</span><br><span class="line">            .and(takesArgument(<span class="number">0</span>, named(<span class="string">&quot;javax.servlet.ServletRequest&quot;</span>)))</span><br><span class="line">            .and(takesArgument(<span class="number">1</span>, named(<span class="string">&quot;javax.servlet.ServletResponse&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MethodInstrumentation</span>(matcher, FilterAdvice.class.getName()));</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="录制回放的步骤"><a href="#录制回放的步骤" class="headerlink" title="录制回放的步骤"></a>录制回放的步骤</h5><p>改写 javax.servlet.Filter 类的 doFilter(request, response) 函数。<br>在函数入口处（OnMethodEnter）进行改写，并获取两个参数，0 位是 request，1 位是 response。 a. 调用 ServletAdviceHelper.onServiceEnter()，传入请求和应答。 b. 调用 CaseEventDispatcher.onEvent(CaseEvent.ofEnterEvent())，其中包括调用了 TimeCache.remove()、TraceContextManager.remove() 和 ContextManager.overdueCleanUp()。 c. 调用 CaseEventDispatcher.onEvent(CaseEvent.ofCreateEvent())，其中包括调用了 initContext(source) 和 initClock()。 initContext() 函数调用设置 ArexContext，入口处会生成 TraceID。ContextManager.currentContext(true, source.getCaseId()) 中的 createIfAbsent 参数传入 True，会调用 TRACE_CONTEXT.set(messageId)。 initClock() 函数判断当前是否处于回放状态，如果是则解析时间并调用TimeCache.put(millis)。如果当前是录制状态（即ArexContext不为空且不处于回放状态ContextManager.needRecord()），则调用RecordMocker。<br>在函数出口处（OnMethodExit）进行改写，调用ServletAdviceHelper.onServiceExit()。 调用 new ServletExtractor&lt;&gt;(adapter, httpServletRequest, httpServletResponse).execute() 函数。 然后调用 doExecute()，构建 Mocker 对象，并为 Mocker 对象设置请求头、Body 和属性。同时为 Mocker 对象设置响应对象、Body 和 Type。 如果当前处于回放状态，则回放 Mocker 数据。如果当前处于录制状态，则保存 Mocker 数据。</p><p>类似的实现方式也适用于入口录制和回放，原理类似，不再赘述。</p><p>对于 Dubbo，可以在 DubboProviderExtractor 类的 onServiceEnter() 中实现。<br>对于 Netty，可以在io.netty.channel.DefaultChannelPipeline 类中的 add 前缀函数和 replace 函数中实现。</p><h4 id="AREX-内部调用的录制回放"><a href="#AREX-内部调用的录制回放" class="headerlink" title="AREX 内部调用的录制回放"></a>AREX 内部调用的录制回放</h4><p>代码所在目录 arex-agent-java\arex-instrumentation\netty\arex-netty-v4</p><h5 id="AREX-注入代码三要素-1"><a href="#AREX-注入代码三要素-1" class="headerlink" title="AREX 注入代码三要素:"></a>AREX 注入代码三要素:</h5><p>ModuleInstrumentation: NettyModuleInstrumentation<br>TypeInstrumentation: ChannelPipelineInstrumentation<br>MethodInstrumentation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;MethodInstrumentation&gt; <span class="title function_">methodAdvices</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> singletonList(<span class="keyword">new</span> <span class="title class_">MethodInstrumentation</span>(</span><br><span class="line">            isMethod().and(nameStartsWith(<span class="string">&quot;add&quot;</span>).or(named(<span class="string">&quot;replace&quot;</span>)))</span><br><span class="line">                    .and(takesArgument(<span class="number">1</span>, String.class))</span><br><span class="line">                    .and(takesArgument(<span class="number">2</span>, named(<span class="string">&quot;io.netty.channel.ChannelHandler&quot;</span>))),</span><br><span class="line">            AddHandlerAdvice.class.getName()));</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="录制回放的步骤-1"><a href="#录制回放的步骤-1" class="headerlink" title="录制回放的步骤"></a>录制回放的步骤</h5><p>在 Java Netty 中，ChannelPipeline 是一个事件处理机制，用于处理入站和出站事件。它是Netty的核心组件之一，用于管理 ChannelHandler 的处理流程。当一个事件被触发时，它会被传递给ChannelPipeline，然后由Pipeline中的每个 ChannelHandler 依���处理。每个 ChannelHandler 都可以对事件进行处理或者转发给下一个 ChannelHandler。addAfter方法是用于向ChannelPipeline中添加一个新的ChannelHandler，并将其插入到指定的 ChannelHandler 之后。这个方法可以用于动态地修改 ChannelPipeline 中的处理流程，以便在运行时根据需要添加或删除处理器。<br>在改写 io.netty.channel.DefaultChannelPipeline 类的 add 前缀函数或者 replace 函数时，我们可以在函数 OnMethodExit 时获取当前对象的 ChannelPipeline，以及参数 1 handleNamer 和参数 2 handler。<br>我们可以进行以下判断和处理：</p><p>如果 handler 是HttpRequestDecoder实例，则调用RequestTracingHandler()来处理回放的数据。<br>如果handler是HttpResponseEncoder实例，则调用ResponseTracingHandler()来处理录制的数据。<br>如果handler是HttpServerCodec实例，则调用ServerCodecTracingHandler()来处理。HttpServerCodec是Java Netty中的一个ChannelHandler，用于将HTTP请求和响应消息编码和解码为HTTP消息。它实现了HTTP协议的编解码，可以将HTTP请求和响应消息转换为字节流，以便在网络中传输。</p><h4 id="异步访问的处理"><a href="#异步访问的处理" class="headerlink" title="异步访问的处理"></a>异步访问的处理</h4><p>在Java生态系统中存在多种异步框架和类库，如Reactor、RxJava等，同时还有一些类库提供了异步访问的实现，例如 lettuce 提供了同步和异步访问 Redis 的方式。不同的场景通常需要不同的解决方案。<br>以 ApacheAsyncClient 为例，它是通过在固定运行的线程中监听响应并发起回调（Callback）来实现异步处理。在整个调用、监听和回调的过程中，需要确保多个跨线程的 Trace 传递。<br>在注入代码中，需要使用 FutureCallbackWrapper 中的 TraceTransmitter 来传递 Trace。具体的注入位置如下：</p><p>ModuleInstrumentation: SyncClientModuleInstrumentation<br>TypeInstrumentation: InternalHttpAsyncClientInstrumentation（用于异步情况）、InternalHttpClientInstrumentation<br>MethodInstrumentation: 注入到org.apache.http.impl.nio.client.InternalHttpAsyncClient类的execute函数，使用named(“execute”)方法进行识别。</p><h5 id="录制回放的步骤-2"><a href="#录制回放的步骤-2" class="headerlink" title="录制回放的步骤"></a>录制回放的步骤</h5><p>在注入函数中，我们针对org.apache.http.impl.nio.client.InternalHttpAsyncClient类的execute函数进行操作，使用函数名named(“execute”)来标识该函数。<br>首先，我们获取execute函数的第三个参数FutureCallback，并将其赋值给AREX实现的封装类FutureCallbackWrapper的callback参数。FutureCallback接口定义了两个方法：onSuccess和onFailure。当异步操作成功完成时，onSuccess方法将被调用，并传递异步操作的结果作为参数。当异步操作失败时，onFailure方法将被调用，并传递异常作为参数。<br>然后，我们进行以下判断：</p><p>如果需要进行录制，则 FutureCallbackWrapper 的封装类重写了 completed(T) 函数，在 completed 函数中保存响应数据，然后调用原始的 FutureCallback 的 completed 方法。同样地，FutureCallbackWrapper 的封装类也重写了 failed() 函数，在 failed 函数中记录响应数据，并调用原始的 FutureCallback 的 failed 方法。<br>如果需要进行回放，则获取回放数据并将其保存在本地的 mockResult 变量中。</p><p>最后，在注入函数的出口处，如果 mockResult 变量的数据不为空，并且 callback 是 AREX 封装类的实例，那么调用封装类的 replay 函数进行回放操作。<br>通过以上操作，我们在 execute 函数的入口和出口处对跨线程的 Trace 传递进行了处理，包括录制和回放功能的实现。</p><h4 id="AREX-录制频率设置"><a href="#AREX-录制频率设置" class="headerlink" title="AREX 录制频率设置"></a>AREX 录制频率设置</h4><p>在 ServletAdviceHelper 类的 onServiceEnter 函数中（就是 Servlet 进入的函数中），实现了 AREX 的录制频率设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  CaseEventDispatcher.onEvent(CaseEvent.ofEnterEvent());</span><br><span class="line"><span class="keyword">if</span> (shouldSkip(adapter, httpServletRequest)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，根据报文头和配置进行录制判断：</p><p>如果请求报文头中有caseID字段，查询配置项arex.disable.replay，如果该配置项的值为true，则直接跳过录制。<br>如果请求报文头中存在arex-force-record字段，并且该字段的值为true，则不能跳过录制。<br>如果请求报文头中存在arex-replay-warm-up字段，并且该字段的值为true，则跳过录制。</p><p>接下来，会解析请求报文：</p><p>如果请求URL为空，则跳过录制。<br>如果请求URL在配置中的录制忽略列表中，则跳过录制。</p><p>接着，会调用Config类的invalidRecord方法进行录制有效性的检查：</p><p>如果配置处于debug状态，则不能跳过录制，直接返回false。<br>如果配置的录制速率小于0，则跳过录制。</p><p>最后，根据请求的路径和录制速率判断是否需要跳过录制，这里使用 com.google.common.util.concurrent.RateLimiter 类的 acquire 函数。RateLimiter 是 Google Guava 库中的一个类，用于限制操作的频率。它可以用于控制某个操作在一定时间内最多能执行多少次，或者在一定时间内最多能执行多少次操作。使用<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RateLimiter</span><br></pre></td></tr></table></figure><br>类，需要先创建一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RateLimiter</span><br></pre></td></tr></table></figure><br>对象，并指定它的速率限制。然后，我们可以使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acquire() </span><br></pre></td></tr></table></figure><br>方法获取一个许可证，表示可以执行一个操作。<p></p><p>如果当前速率已经达到了限制，acquire 函数会阻塞等待，直到能够获取到许可证为止。<br>如果能够获取到许可证，则不跳过录制。</p><h3 id="AREX-代码隔离"><a href="#AREX-代码隔离" class="headerlink" title="AREX 代码隔离"></a>AREX 代码隔离</h3><p>在Java虚拟机中，判断两个类是否相等时，不仅会比较它们的全限定名，还会比较它们的加载器。如果两个类的全限定名相同，但加载它们的ClassLoader不同，Java虚拟机会认为这是两个不同的类。<br>这种设计有助于保证Java虚拟机的安全性和隔离性。不同的ClassLoader可以加载同一个类，但它们加载的类是相互独立的，互相不可见的。这样可以避免不同应用程序或模块之间的类冲突和干扰。<br>在 AREX 中，涉及的 ClassLoader 有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arex-agent</span><br></pre></td></tr></table></figure><p>：由 AppClassLoader 加载，用于加载 AREX Agent 的核心组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arex-agent-bootstrap</span><br></pre></td></tr></table></figure><p>：由引导类加载器（Bootstrap ClassLoader）加载，用于加载 AREX Agent 的引导类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arex-agent-core</span><br></pre></td></tr></table></figure><p>：由 AgentClassLoader 加载，这是 AREX 自定义的 ClassLoader，负责加载 arex-agent-core 等 jar。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arex-instrumentation</span><br></pre></td></tr></table></figure><p>：由 UserClassLoader 加载，用于加载 AREX 的 Instrumentation、Module 和 Advice 等组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXX Instrumentation &amp; Module &amp; Advice</span><br></pre></td></tr></table></figure><p>：由 AgentClassLoader 加载，用于加载具体的 Instrumentation、Module 和 Advice 等实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arex-instrumentation-api</span><br></pre></td></tr></table></figure><p>：由 AgentClassLoader 加载，包括 API 和 Runtime 两部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api</span><br></pre></td></tr></table></figure><p>：由 AgentClassLoader 加载，提供给用户使用的 API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime</span><br></pre></td></tr></table></figure><p>：由 AppClassLoader 加载，用于 AREX 运行时的一些功能。</p><p>arex-instrumentation-foundation&#96;：由 AgentClassLoader 加载，用于加载 AREX 的基础功能，如后端实现等。</p><p>这些不同的 ClassLoader 之间具有隔离性，确保了各个组件的独立性和安全性。<br>其中：</p><p>AgentClassLoader：AREX 自定义的 ClassLoader。<br>Bootstrap ClassLoader: Java Instrumentation API 是 Java SE 5 中引入的一个功能强大的工具，它允许在运行时修改Java类的行为。 其中，Instrumentation类是Java Instrumentation API的核心类之一，它提供了一些方法来监测和修改Java应用程序的运行状态。 其中，appendToBootstrapClassLoaderSearch方法是Instrumentation类中的一个方法，它的作用是将指定的jar文件添加到Bootstrap ClassLoader的搜索路径中。 Bootstrap ClassLoader是Java虚拟机中的一个特殊的类加载器，它负责加载Java运行时环境中的核心类库，如java.lang和java.util等。 通过调用appendToBootstrapClassLoaderSearch方法，可以将自定义的类库添加到Bootstrap ClassLoader的搜索路径中，从而使得Java应用程序可以使用这些自定义的类库。 需要注意的是，由于appendToBootstrapClassLoaderSearch 方法会修改 Java 虚拟机的运行状态，因此只有具有足够权限的用户才能调用该方法。<br>AppClassLoader是Java应用程序默认的ClassLoader，它负责加载应用程序的类。AppClassLoader会从CLASSPATH环境变量或者系统属性java.class.path指定的路径中加载类文件。 如果需要加载的类不在AppClassLoader的搜索路径中，它会委托给父ClassLoader进行加载，直到BootstrapClassLoader为止。<br>UserClassLoader 用户自定义ClassLoader,如SPIUtil类中Load方法如下获取ClassLoader加载<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><div class="post-copyright"><div class="content"><p>本文标题： 推荐系列- 自动化回归测试平台 AREX Agent 源码再阅读</p><p>本文作者： OSChina</p><p>发布时间： 2023年05月24日 09:23</p><p>最后更新： 2023年06月29日 07:10</p><p>原始链接： <a class="post-url" href="/67e1662/" title="推荐系列- 自动化回归测试平台 AREX Agent 源码再阅读">https://haoxiang.eu.org/67e1662/</a></p><p>版权声明： 本文著作权归作者所有，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a>许可协议，转载请注明出处！</p><footer><a href="https://haoxiang.eu.org"><img src="/../images/logo.png" alt="Howe Hsiang"> Howe Hsiang</a></footer></div></div><div class="page-reward"><a id="rewardBtn" href="javascript:;">赏</a></div><div id="reward" class="post-modal reward-lay"><a class="close" href="javascript:;" id="reward-close">×</a> <span class="reward-title"><i class="icon icon-quote-left"></i> 喜欢就赞赏一下呗！ <i class="icon icon-quote-right"></i></span><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="/images/threepay_code.jpg" alt="打赏二维码"></div><div class="reward-select"></div></div></div></div><footer class="article-footer"><div class="post-share"><a href="javascript:" id="share-sub" class="post-share-fab"><i class="fa fa-share-alt" style="padding-top:11px!important"></i></a><div class="post-share-list" id="share-list"><ul class="share-icons"><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://haoxiang.eu.org/67e1662/" data-title="Facebook" rel="external nofollow noopener noreferrer"><i class="fa fa-facebook" style="padding-top:9px!important"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《推荐系列- 自动化回归测试平台 AREX Agent 源码再阅读》 — 狂欢马克思&url=https://haoxiang.eu.org/67e1662/&via=https://haoxiang.eu.org" data-title="Twitter" rel="external nofollow noopener noreferrer"><i class="fa fa-twitter" style="padding-top:9px!important"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://haoxiang.eu.org/67e1662/" data-title="Google+" rel="external nofollow noopener noreferrer"><i class="fa fa-google-plus" style="padding-top:9px!important"></i></a></li><li><a class="qq share-sns" target="_blank" href="https://connect.qq.com/widget/shareqq/index.html?url=https://haoxiang.eu.org/67e1662/&title=《推荐系列- 自动化回归测试平台 AREX Agent 源码再阅读》 — 狂欢马克思&source=&amp;emsp;&amp;emsp;EX 启动过程 通用 Java Agent 的启动过程 Java Agent 是一种 Java 应用程序，它可以在..." data-title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-qq" style="padding-top:9px!important"></i></a></li><li><a class="weixin share-sns" id="wxFab" href="javascript:" data-title="微信"><i class="fa fa-weixin" style="padding-top:9px!important"></i></a></li><li><a class="weibo share-sns" target="_blank" href="https://service.weibo.com/share/share.php?url=https://haoxiang.eu.org/67e1662/&title=《推荐系列- 自动化回归测试平台 AREX Agent 源码再阅读》 — 狂欢马克思&pic=https://api.ixiaowai.cn/gqapi/gqapi.php" data-title="微博" rel="external nofollow noopener noreferrer"><i class="fa fa-weibo" style="padding-top:9px!important"></i></a></li></ul></div></div><div class="post-modal wx-share" id="wxShare"><a class="close" href="javascript:" id="wxShare-close">×</a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://haoxiang.eu.org/67e1662/" alt="微信分享二维码"></div><div class="mask"></div><ul class="article-footer-menu"><li class="article-footer-tags"><i class="fa fa-tags"></i> <a href="/tags/Popular/" class="color3">Popular</a></li></ul></footer></div></article><aside class="post-toc-pos post-toc-top" id="post-toc"><nav class="post-toc-wrap"><ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%80%9A%E7%94%A8-Java-Agent-%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="post-toc-text">通用 Java Agent 的启动过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AREX-%E6%BA%90%E7%A0%81%E8%A7%86%E8%A7%92%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="post-toc-text">AREX 源码视角的启动过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%80"><span class="post-toc-text">步骤一</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C"><span class="post-toc-text">步骤二</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%89"><span class="post-toc-text">步骤三</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link"><span class="post-toc-text"></span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#-1"><span class="post-toc-text"></span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%AD%A5%E9%AA%A4%E5%9B%9B"><span class="post-toc-text">步骤四</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%94"><span class="post-toc-text">步骤五</span></a></li></ol></li></ol><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AREX-%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE"><span class="post-toc-text">AREX 录制回放</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE%E6%A6%82%E8%BF%B0"><span class="post-toc-text">录制回放概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BD%95%E5%88%B6"><span class="post-toc-text">录制</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%9B%9E%E6%94%BE"><span class="post-toc-text">回放</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AREX-Servlet-%E7%9A%84%E5%85%A5%E5%8F%A3%E5%BD%95%E5%88%B6%E5%92%8C%E5%9B%9E%E6%94%BE"><span class="post-toc-text">AREX Servlet 的入口录制和回放</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#AREX-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="post-toc-text">AREX 注入代码三要素</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="post-toc-text">录制回放的步骤</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AREX-%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E7%9A%84%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE"><span class="post-toc-text">AREX 内部调用的录制回放</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#AREX-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E4%B8%89%E8%A6%81%E7%B4%A0-1"><span class="post-toc-text">AREX 注入代码三要素:</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE%E7%9A%84%E6%AD%A5%E9%AA%A4-1"><span class="post-toc-text">录制回放的步骤</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%A4%84%E7%90%86"><span class="post-toc-text">异步访问的处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE%E7%9A%84%E6%AD%A5%E9%AA%A4-2"><span class="post-toc-text">录制回放的步骤</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AREX-%E5%BD%95%E5%88%B6%E9%A2%91%E7%8E%87%E8%AE%BE%E7%BD%AE"><span class="post-toc-text">AREX 录制频率设置</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AREX-%E4%BB%A3%E7%A0%81%E9%9A%94%E7%A6%BB"><span class="post-toc-text">AREX 代码隔离</span></a></li></nav></aside><nav id="article-nav"><a href="/2476c406/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">推荐系列--MaxCompute-基于Package跨项目访问资源实践</span> <i class="fa fa-hand-o-right" aria-hidden="true"></i></a></nav><div id="gitalk"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({repo:"bolg-comment",owner:"Hosiang1026",admin:"Hosiang1026",clientID:"37a2dd4473e8970cecc2",clientSecret:"e30efa17d86d9de4f4ab810872dc62a7b2e7e634",pagerDirection:"last",distractionFreeMode:!0,createIssueManually:!1});gitalk.render("gitalk")</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"><script id="_wau78w">var _wau=_wau||[];_wau.push(["small","5dnguv4c2n","78w"])</script><script async src="//waust.at/s.js"></script><p><span id="busuanzi_container_site_uv" style="display:none"><span class="post-count">总字数：<span>1841.6k</span> </span>总访客数：<span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" style="display:none">总访问量：<span id="busuanzi_value_site_pv"></span></span><br><span id="TimeShow">本站</span><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br>Copyright&copy; 2018 - 2023 狂欢马克思 <a href="https://beian.miit.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">京ICP备17060439号</a></p></div></div><script>var now=new Date;function createtime(){var n=new Date("2017/09/18");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",800)</script></footer><script>var mihoConfig={root:"https://haoxiang.eu.org",animate:"true",isHome:"false",share:"true",reward:" 1"}</script><div class="sidebar"><div id="sidebar-search" title="Search"><i class="fa fa-search"></i></div><div id="sidebar-category" title="Categories"><i class="fa fa-book"></i></div><div id="sidebar-tag" title="Tags"><i class="fa fa-tags"></i></div><div id="sidebar-top"><span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span></div></div><div class="sidebar-menu-box" id="sidebar-menu-box"><div class="sidebar-menu-box-container"><div id="sidebar-menu-box-categories"><a class="category-link" href="/categories/%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD/">兴趣爱好</a><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/">其他开发</a><a class="category-link" href="/categories/%E5%89%8D%E6%B2%BF%E5%BC%80%E5%8F%91/">前沿开发</a><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a><a class="category-link" href="/categories/%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/">升级版本</a><a class="category-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">博客教程</a><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="category-link" href="/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</a><a class="category-link" href="/categories/%E7%83%AD%E9%97%A8%E6%96%87%E7%AB%A0/">热门文章</a></div><div id="sidebar-menu-box-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:17.5px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:15px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12.5px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Java/" style="font-size:12.5px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:17.5px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12.5px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NAS/" style="font-size:10px">NAS</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:17.5px">Spring</a> <a href="/tags/System/" style="font-size:10px">System</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div><a href="javascript:" class="sidebar-menu-box-close">&times;</a></div><div class="mobile-header-menu-nav" id="mobile-header-menu-nav"><div class="mobile-header-menu-container"><span class="title">导航</span><ul class="mobile-header-menu-navbar"><li><a href="/"><i class="fa fa-home"></i><span>主页</span></a></li><li><a href="/archives"><i class="fa fa-archive"></i><span>归档</span></a></li><li><a href="/gitbook"><i class="fa fa-columns"></i><span>笔记</span></a></li><li><a href="/photo"><i class="fa fa-picture-o"></i><span>相册</span></a></li><li><a href="/love"><i class="fa fa-heart"></i><span>恋爱</span></a></li><li><a href="/collection"><i class="fa fa-envira"></i><span>收藏</span></a></li><li><a href="/about"><i class="fa fa-user"></i><span>关于</span></a></li></ul></div><div class="mobile-header-tag-container"><span class="title">标签</span><div id="mobile-header-container-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:17.5px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:15px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12.5px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Java/" style="font-size:12.5px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:17.5px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12.5px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NAS/" style="font-size:10px">NAS</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:17.5px">Spring</a> <a href="/tags/System/" style="font-size:10px">System</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div></div><div class="search-wrap"><span class="search-close">&times;</span> <a href="javascript:" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input class="search-field" placeholder="Search..." id="keywords"> <a id="search-submit" href="javascript:"><i class="fa fa-search"></i></a><div class="search-container" id="search-container"><ul class="search-result" id="search-result"></ul></div></div><div id="search-tpl"><li class="search-result-item"><a href="{url}" class="search-item-li"><span class="search-item-li-title" title="{title}">{title}</span></a></li></div><script src="/js/search.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script><div id="particles"></div><script src="/js/particles.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css"><script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script><script src="/js/animate.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0,scale:.5},log:!1})</script></body></html>