<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Access-Control-Allow-Origin" content="*"><script type="text/javascript">var start_time=(new Date).getTime()</script><meta http-equiv="Cache-Control" content="no-cache"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="google-site-verification" content="9Wt3lmnrT2bfjaHla5s16adhvcQcBHO7PtNf97n5Od0"><meta name="baidu-site-verification" content="RYlYHsgO7Y"><meta name="sogou_site_verification" content="MSmrTj7lHV"><meta name="shenma-site-verification" content="e4428ccce0f22fad61c3716193bf4bd7_1571416388"><meta name="baidu_union_verify" content="584bb6b4bd24108df082b6d20c7aa9be"><title>推荐系列-Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册 | 狂欢马克思</title><meta name="keywords" content="分享技术经验与交流"><meta name="description" content="&amp;emsp;&amp;emsp;Dubbo服务发布 Dubbo服务发布影响流程的主要包括三个部分，依次是： 服务暴露 心跳 服务注册 服务暴露是对外提供服务及暴露端口，以便消费端可以正常调通服务。心跳机制保证服务器端及客户端…"><meta property="og:type" content="article"><meta property="og:title" content="推荐系列-Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"><meta property="og:url" content="https://www.hosiang.cn/c1aba8a6/index.html"><meta property="og:site_name" content="狂欢马克思"><meta property="og:description" content="&amp;emsp;&amp;emsp;Dubbo服务发布 Dubbo服务发布影响流程的主要包括三个部分，依次是： 服务暴露 心跳 服务注册 服务暴露是对外提供服务及暴露端口，以便消费端可以正常调通服务。心跳机制保证服务器端及客户端…"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="og:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><meta property="article:published_time" content="2021-04-15T01:19:21.000Z"><meta property="article:modified_time" content="2022-03-27T01:29:07.606Z"><meta property="article:author" content="Howe Hsiang"><meta property="article:tag" content="Popular"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg"><link rel="icon" href="/images/favicon.ico"><link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/font-awesome-animation/0.1.0/font-awesome-animation.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3cd8fa109426bf3f10bd5c362175bace";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 5.4.1"></head><script src="/js/jquery.min.js"></script><script src="/js/pace.min.js"></script><script src="/js/crypto-js.js"></script><script src="/js/cookie.js"></script><script src="/js/calendar.js"></script><script src="/js/festival.js"></script><script>getFestival()</script><body><script>window.onload=function(){document.getElementById("TimeShow").innerHTML="本站耗时 "+((new Date).getTime()-start_time)/1e3+" 秒 "}</script><div id="container"><header id="header"><div id="banner"></div><div id="header-outer"><div id="header-menu" class="header-menu-pos animated"><div class="header-menu-container"><a href="/" class="left"><span class="site-title">狂欢马克思</span></a><nav id="header-menu-nav" class="right"><a href="/" rel="external nofollow"><i class="fa fa-home"></i> <span>主页</span> </a><a href="/archives" rel="external nofollow"><i class="fa fa-archive"></i> <span>归档</span> </a><a href="/gitbook" rel="external nofollow"><i class="fa fa-columns"></i> <span>笔记</span> </a><a href="/music" rel="external nofollow"><i class="fa fa-music"></i> <span>音乐</span> </a><a href="/photo" rel="external nofollow"><i class="fa fa-picture-o"></i> <span>相册</span> </a><a href="/collection" rel="external nofollow"><i class="fa fa-envira"></i> <span>收藏</span> </a><a href="/about" rel="external nofollow"><i class="fa fa-user"></i> <span>关于</span></a></nav><a class="mobile-header-menu-button"><i class="fa fa-bars"></i></a></div></div><div id="header-row"><div id="logo"><a href="/"><img src="/../images/logo.png" alt="logo"></a></div><div class="header-info"><div id="header-title"><h2>狂欢马克思</h2></div><div id="header-description"><h3>专注Web开发</h3></div></div><nav class="header-nav"><div class="social"><a title="Github" target="_blank" href="//github.com/Hosiang1026" rel="external nofollow"><i class="fa fa-github fa-2x"></i></a> <a title="QQ" target="_blank" href="//wpa.qq.com/msgrd?v=3&uin=641904695&site=qq&menu=yes" rel="external nofollow"><i class="fa fa-qq fa-2x"></i></a> <a title="Weibo" target="_blank" href="//www.weibo.com/haoxiang969" rel="external nofollow"><i class="fa fa-weibo fa-2x"></i></a></div></nav></div><div id="noticeId" class="show" style="background:rgb(244,247,247,.3)"><marquee id="noticeMar" behavior="scoll" class="notice" direction="left" onmouseover="this.stop()" onmouseout="this.start()"></marquee></div><script type="text/javascript">function browserRedirect(){var i=navigator.userAgent.toLowerCase(),n="ipad"==i.match(/ipad/i),o="iphone os"==i.match(/iphone os/i),a="midp"==i.match(/midp/i),t="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),e="ucweb"==i.match(/ucweb/i),s="android"==i.match(/android/i),d="windows ce"==i.match(/windows ce/i),p="windows mobile"==i.match(/windows mobile/i),r="",c=randomColor(),r=n||o||a||t||e||s||d||p?($("#noticeId").css({"line-height":"1.6em"}),"<font style='color:"+c+"' face='新华宋体'  size='2'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='hitokoto'></span></span></span><span id='YQData'></font> "):($("#noticeId").css({"line-height":"3.6em","margin-top":"20px"}),"<font style='color:"+c+"' face='新华宋体'  size='6'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='hitokoto'></span></span><span id='YQData'></span></font> ");$("#noticeMar").html(r)}function randomColor(){for(var i="0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f".split(","),n="#",o=0;o<6;o++)n+=i[Math.floor(16*Math.random())];return n}$(function(){browserRedirect(),0<$("#hitokoto").length&&getHitokoto()})</script></div></header><script>console.log=function(){}</script><div class="outer"><section id="main" class="body-wrap"><article id="post-Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="post-title" itemprop="name">推荐系列-Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册</h1><div class="post-title-bar"><ul><li><i class="fa fa-book"></i> <a href="/categories/热门文章/">热门文章</a></li><li><i class="fa fa-calendar"></i> 2021-04-15</li><li><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span></li><li><span class="post-count">字数统计: 6.4k字</span></li><li><span class="post-count">阅读时长: 32分钟</span></li></ul></div></header><div class="article-entry post-content" itemprop="articleBody"><p>&emsp;&emsp;Dubbo服务发布 Dubbo服务发布影响流程的主要包括三个部分，依次是： 服务暴露 心跳 服务注册 服务暴露是对外提供服务及暴露端口，以便消费端可以正常调通服务。心跳机制保证服务器端及客户端…<br><span id="more"></span></p><h3 id="Dubbo服务发布"><a href="#Dubbo服务发布" class="headerlink" title="Dubbo服务发布"></a>Dubbo服务发布</h3><p>Dubbo服务发布影响流程的主要包括三个部分，依次是：</p><p>服务暴露<br>心跳<br>服务注册</p><p>服务暴露是对外提供服务及暴露端口，以便消费端可以正常调通服务。心跳机制保证服务器端及客户端正常长连接的保持，服务注册是向注册中心注册服务暴露服务的过程。</p><h4 id="Dubbo服务暴露"><a href="#Dubbo服务暴露" class="headerlink" title="Dubbo服务暴露"></a>Dubbo服务暴露</h4><p>此处只记录主要代码部分以便能快速定位到主要的核心代码：<br>ServiceConfig.java中代码</p><pre><code class="java">  <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; registryURLs.size() &gt; <span class="number">0</span>
        &amp;&amp; url.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>)) &#123;
    <span class="comment">// 循环祖册中心 URL 数组 registryURLs</span>
    <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;
        <span class="comment">// "dynamic" ：服务是否动态注册，如果设为false，注册后将显示后disable状态，需人工启用，并且服务提供者停止时，也不会自动取消册，需人工禁用。</span>
        url = url.addParameterIfAbsent(<span class="string">"dynamic"</span>, registryURL.getParameter(<span class="string">"dynamic"</span>));
        <span class="comment">// 获得监控中心 URL</span>
        URL monitorUrl = loadMonitor(registryURL);
        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;
            <span class="comment">// 将监控中心的 URL 作为 "monitor" 参数添加到服务提供者的 URL 中，并且需要编码。通过这样的方式，服务提供者的 URL 中，包含了监控中心的配置。</span>
            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());
        &#125;
        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;
            logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + url + <span class="string">" to registry "</span> + registryURL);
        &#125;
        <span class="comment">// 使用 ProxyFactory 创建 Invoker 对象</span>
        <span class="comment">// 调用 URL#addParameterAndEncoded(key, value) 方法，将服务体用这的 URL 作为 "export" 参数添加到注册中心的 URL 中。通过这样的方式，注册中心的 URL 中，包含了服务提供者的配置。</span>
        <span class="comment">// 创建 Invoker 对象。该 Invoker 对象，执行 #invoke(invocation) 方法时，内部会调用 Service 对象( ref )对应的调用方法。</span>
        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
        <span class="comment">// 使用 Protocol 暴露 Invoker 对象</span>
        <span class="comment">/**</span>
<span class="comment">         * Protocol$Adaptive =&gt; ProtocolFilterWrapper =&gt; ProtocolListenerWrapper =&gt; RegistryProtocol</span>
<span class="comment">         * =&gt;</span>
<span class="comment">         * Protocol$Adaptive =&gt; ProtocolFilterWrapper =&gt; ProtocolListenerWrapper =&gt; DubboProtocol</span>
<span class="comment">         */</span>
        Exporter&lt;?&gt; exporter = protocol.export(invoker);
        <span class="comment">// 添加到 `exporters`</span>
        exporters.add(exporter);
    &#125;
&#125;
</code></pre><p>循环注册中心，对每个注册中心都执行代码块中的执行过程<br>1.如果url中没有dynamic 参数，则从registerUrl中取值，并赋予url dynamic是服务动态注册的标识，默认为true，如果设置为false,则服务注册后显示disable状态，需人工启动<br>2.加载注册中心对应的监控中心配置<br>3.如果注册中心不为空则设置url的 monitor参数<br>4.Invoker proxyFactory.getInvoker proxyFactory 默认为JavassistProxyFactory对象，这段代码为创建 ref 服务对象的代理对象。 proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString())); 获取ref的代理对象并在registryURL 中添加export属性，代理对象中属性参数如下 <img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"><br>5.protocol.export(invoker) 为暴露服务的核心实现部分,协议的调用链如下：</p><p>其中DubboProtocol 实现了服务暴露及心跳检测功能 RegistryProtocol 调用了DubboProtocol及注册服务<br>接下来经过两个扩展类(包装器) ProtocolFilterWrapper和ProtocolListenerWrapper 进入RegistryProtocol 核心代码如下：</p><pre><code class="java">  <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;
    <span class="comment">// 暴露服务</span>
    <span class="comment">//export invoker</span>
    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);

    <span class="comment">//registry provider</span>
    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);
    <span class="comment">// 获得服务提供者 URL</span>
    <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);

    registry.register(registedProviderUrl);
    <span class="comment">// 订阅override数据</span>
    <span class="comment">// FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span>
    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);
    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);
    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);
    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
    <span class="comment">//保证每次export都返回一个新的exporter实例</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Exporter&lt;T&gt;() &#123;
        <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;
            <span class="keyword">return</span> exporter.getInvoker();
        &#125;

        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;
            <span class="keyword">try</span> &#123;
                exporter.unexport();
            &#125; <span class="keyword">catch</span> (Throwable t) &#123;
                logger.warn(t.getMessage(), t);
            &#125;
            <span class="keyword">try</span> &#123;
                registry.unregister(registedProviderUrl);
            &#125; <span class="keyword">catch</span> (Throwable t) &#123;
                logger.warn(t.getMessage(), t);
            &#125;
            <span class="keyword">try</span> &#123;
                overrideListeners.remove(overrideSubscribeUrl);
                registry.unsubscribe(overrideSubscribeUrl, overrideSubscribeListener);
            &#125; <span class="keyword">catch</span> (Throwable t) &#123;
                logger.warn(t.getMessage(), t);
            &#125;
        &#125;
    &#125;;
&#125;
</code></pre><pre><code class="java">  <span class="comment">/**</span>
<span class="comment"> * 暴露服务。</span>
<span class="comment"> *</span>
<span class="comment"> * 此处的 Local 指的是，本地启动服务，但是不包括向注册中心注册服务的意思。</span>
<span class="comment"> * <span class="doctag">@param</span> originInvoker</span>
<span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span>
<span class="comment"> * <span class="doctag">@return</span></span>
<span class="comment"> */</span>
<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
<span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> </span>&#123;
    <span class="comment">// 获得在 `bounds` 中的缓存 Key</span>
    <span class="comment">//dubbo://192.168.20.218:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;default.accepts=1000&amp;default.threadpool=fixed&amp;default.threads=100&amp;default.timeout=5000&amp;dubbo=2.0.0&amp;generic=false&amp;</span>
    <span class="comment">// interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;owner=uce&amp;pid=1760&amp;side=provider&amp;timestamp=1530150456618</span>
    String key = getCacheKey(originInvoker);
    ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);
    <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;
        <span class="keyword">synchronized</span> (bounds) &#123;
            exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);
            <span class="comment">// 未暴露过，进行暴露服务</span>
            <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;
                <span class="comment">// InvokerDelegete 实现 com.alibaba.dubbo.rpc.protocol.InvokerWrapper 类，主要增加了 #getInvoker() 方法，获得真实的，非 InvokerDelegete 的 Invoker 对象。</span>
                <span class="comment">// 因为，可能会存在 InvokerDelegete.invoker 也是 InvokerDelegete 类型的情况。  getProviderUrl 同上 key = getCacheKey</span>
                <span class="keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));
                <span class="comment">// 暴露服务，创建 Exporter 对象</span>

                Exporter&lt;T&gt; export = (Exporter&lt;T&gt;) protocol.export(invokerDelegete);
                <span class="comment">// 使用 创建的Exporter对象 + originInvoker ，创建 ExporterChangeableWrapper 对象</span>
                exporter = <span class="keyword">new</span> ExporterChangeableWrapper&lt;T&gt;(export, originInvoker);
                bounds.put(key, exporter);
            &#125;
        &#125;
    &#125;
    <span class="keyword">return</span> exporter;
&#125;
</code></pre><p>1.代用同步锁+double-check的方式来保证同样的服务不重复暴露。<br>2.new InvokerDelegete<t>(originInvoker, getProviderUrl(originInvoker)); InvokerDelegete 实现 com.alibaba.dubbo.rpc.protocol.InvokerWrapper（invoke） 类，主要增加了 #getInvoker() 方法，获得真实的，非 InvokerDelegete 的 Invoker 对象。 <img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"><br>3.调用protocol.export接��� 经过ProtocolFilterWrapper.invoker方法 创过滤器链再暴露服务：<br>protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</t></p><pre><code class="java">  <span class="comment">/**</span>
<span class="comment"> * 构建过滤器链</span>
<span class="comment"> * <span class="doctag">@param</span> invoker injvm://127.0.0.1/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;default.accepts=1000&amp;default.threadpool=fixed&amp;default.threads=100&amp;default.timeout=5000&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;owner=uce&amp;pid=9932&amp;side=provider&amp;timestamp=1527930395583</span>
<span class="comment"> * <span class="doctag">@param</span> key service.filter 该参数用于获得 ServiceConfig 或 ReferenceConfig 配置的自定义过滤器</span>
<span class="comment"> *            以 ServiceConfig 举例子，例如 url = injvm://127.0.0.1/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;bind.ip=192.168.3.17&amp;bind.port=20880&amp;default.delay=-1&amp;default.retries=0&amp;default.service.filter=demo&amp;delay=-1&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=81844&amp;qos.port=22222&amp;service.filter=demo&amp;side=provider&amp;timestamp=1520682156043 中，</span>
<span class="comment"> *            service.filter=demo，这是笔者配置自定义的 DemoFilter 过滤器。</span>
<span class="comment"> *            &lt;dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" filter="demo" /&gt;</span>
<span class="comment"> * <span class="doctag">@param</span> group provider  属性，分组</span>
<span class="comment"> *              在暴露服务时，group = provider 。</span>
<span class="comment"> *              在引用服务时，group = consumer 。</span>
<span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span>
<span class="comment"> * <span class="doctag">@return</span></span>
<span class="comment"> */</span>
<span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;
    Invoker&lt;T&gt; last = invoker;
    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter<span class="class">.<span class="keyword">class</span>).<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">key</span>, <span class="title">group</span>)</span>;
   <span class="comment">/* EchoFilter</span>
<span class="comment">      ClassLoaderFilter</span>
<span class="comment">      GenericFilter</span>
<span class="comment">      ContextFilter</span>
<span class="comment">      TraceFilter</span>
<span class="comment">      TimeoutFilter</span>
<span class="comment">      MonitorFilter</span>
<span class="comment">      ExceptionFilter</span>
<span class="comment">      DemoFilter 【自定义】*/</span>
    <span class="comment">//倒序循环 Filter ，创建带 Filter 链的 Invoker 对象。因为是通过嵌套声明匿名类循环调用的方式，所以要倒序。可以手工模拟下这个过程。通过这样的方式，实际过滤的顺序，还是我们上面看到的正序</span>
    <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;
            <span class="keyword">final</span> Filter filter = filters.get(i);
            <span class="keyword">final</span> Invoker&lt;T&gt; next = last;
            last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;

                <span class="meta">@Override</span>
                <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;
                    <span class="keyword">return</span> invoker.getInterface();
                &#125;
                <span class="meta">@Override</span>
                <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;
                    <span class="keyword">return</span> invoker.getUrl();
                &#125;
                <span class="meta">@Override</span>
                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;
                    <span class="keyword">return</span> invoker.isAvailable();
                &#125;
                <span class="meta">@Override</span>
                <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;
                    <span class="keyword">return</span> filter.invoke(next, invocation);
                &#125;
                <span class="meta">@Override</span>
                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;
                    invoker.destroy();
                &#125;
                <span class="meta">@Override</span>
                <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;
                    <span class="keyword">return</span> invoker.toString();
                &#125;
            &#125;;
        &#125;
    &#125;
    <span class="keyword">return</span> last;
&#125;
</code></pre><p>List<filter>filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group); 获取Active的属于指定组的过过滤器列表 参考文章：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://my.oschina.net/LucasZhu/blog/1835048">https://my.oschina.net/LucasZhu/blog/1835048</a><br>接下来执行DubboProrocol进行服务暴露的过程。</filter></p><pre><code class="java">  <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;
    URL url = invoker.getUrl();

    <span class="comment">// export service.</span>
    String key = serviceKey(url);
    <span class="comment">// 创建 DubboExporter 对象，并添加到 `exporterMap` 。</span>
    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);
    exporterMap.put(key, exporter);

    <span class="comment">//export an stub service for dispaching event</span>
    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);
    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);
    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;
        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);
        <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;
            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;
                logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> + url.getParameter(Constants.INTERFACE_KEY) +
                        <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));
            &#125;
        &#125; <span class="keyword">else</span> &#123;
            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);
        &#125;
    &#125;
    <span class="comment">// 启动服务器</span>
    openServer(url);
    <span class="keyword">return</span> exporter;
&#125;
</code></pre><p>1.获取invoker的 URL信息 2.获取key信息 为URL中interface与暴露端口的拼装字符串：com.alibaba.dubbo.demo.DemoService:20880 3.创建DubboExporter对象 并且入参为exporterMap 4.将exporter对象添加到exporterMap中</p><pre><code class="java">   <span class="comment">/**</span>
<span class="comment">  * 启动服务器</span>
<span class="comment">  *</span>
<span class="comment">  * <span class="doctag">@param</span> url URL</span>
<span class="comment">  */</span>
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;
    <span class="comment">// find server.</span>
    String key = url.getAddress();
    <span class="comment">//client 也可以暴露一个只有server可以调用的服务。</span>
    <span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class="keyword">true</span>);
    <span class="keyword">if</span> (isServer) &#123;
        ExchangeServer server = serverMap.get(key);
        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;
            serverMap.put(key, createServer(url));
        &#125; <span class="keyword">else</span> &#123;
            <span class="comment">//server支持reset,配合override功能使用</span>
            server.reset(url);
        &#125;
    &#125;
&#125;
</code></pre><p>调用createServer()方法 并存入DubboProtocol的serverMap中</p><pre><code class="java">  <span class="function"><span class="keyword">private</span> ExchangeServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;
    <span class="comment">//默认开启server关闭时发送readonly事件</span>
    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());
    <span class="comment">//默认开启heartbeat</span>
    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));
    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);
    <span class="comment">// 校验 Server 的 Dubbo SPI 拓展是否存在</span>
    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">str</span>))</span>
        throw new RpcException("Unsupported server type: " + str + ", url: " + url);
    <span class="comment">// 设置codec为 `"Dubbo"`</span>
    url = url.addParameter(Constants.CODEC_KEY, Version.isCompatibleVersion() ? COMPATIBLE_CODEC_NAME : DubboCodec.NAME);
    ExchangeServer server;
    <span class="keyword">try</span> &#123;
        server = Exchangers.bind(url, requestHandler);
    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to start server(url: "</span> + url + <span class="string">") "</span> + e.getMessage(), e);
    &#125;
    str = url.getParameter(Constants.CLIENT_KEY);
    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;
        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">getSupportedExtensions</span>()</span>;
        <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;
            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str);
        &#125;
    &#125;
    <span class="keyword">return</span> server;
&#125;
</code></pre><p>1.默认开启server 关闭时发送readonly事件：channel.readonly.sent : true 2.默认开启 heartbeat 3.获取服务暴露的 server 传输 ， 默认为netty 4.设置编码器为Dubbo也就是 DubboCountCodec 5.Exchangers#bind(url, requestHandler) 启动服务器，requestHandler结构如下<br><img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"><br>具体实现代码如下：</p><pre><code class="java">  <span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;

    <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;
        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;
            Invocation inv = (Invocation) message;
            Invoker&lt;?&gt; invoker = getInvoker(channel, inv);
            <span class="comment">//如果是callback 需要处理高版本调用低版本的问题</span>
            <span class="keyword">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;
                String methodsStr = invoker.getUrl().getParameters().get(<span class="string">"methods"</span>);
                <span class="keyword">boolean</span> hasMethod = <span class="keyword">false</span>;
                <span class="keyword">if</span> (methodsStr == <span class="keyword">null</span> || methodsStr.indexOf(<span class="string">","</span>) == -<span class="number">1</span>) &#123;
                    hasMethod = inv.getMethodName().equals(methodsStr);
                &#125; <span class="keyword">else</span> &#123;
                    String[] methods = methodsStr.split(<span class="string">","</span>);
                    <span class="keyword">for</span> (String method : methods) &#123;
                        <span class="keyword">if</span> (inv.getMethodName().equals(method)) &#123;
                            hasMethod = <span class="keyword">true</span>;
                            <span class="keyword">break</span>;
                        &#125;
                    &#125;
                &#125;
                <span class="keyword">if</span> (!hasMethod) &#123;
                    logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"The methodName "</span> + inv.getMethodName() + <span class="string">" not found in callback service interface ,invoke will be ignored. please update the api interface. url is:"</span> + invoker.getUrl()) + <span class="string">" ,invocation is :"</span> + inv);
                    <span class="keyword">return</span> <span class="keyword">null</span>;
                &#125;
            &#125;
            RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());
            <span class="keyword">return</span> invoker.invoke(inv);
        &#125;
        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Unsupported request: "</span> + message == <span class="keyword">null</span> ? <span class="keyword">null</span> : (message.getClass().getName() + <span class="string">": "</span> + message) + <span class="string">", channel: consumer: "</span> + channel.getRemoteAddress() + <span class="string">" --&gt; provider: "</span> + channel.getLocalAddress());
    &#125;

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;
        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;
            reply((ExchangeChannel) channel, message);
        &#125; <span class="keyword">else</span> &#123;
            <span class="keyword">super</span>.received(channel, message);
        &#125;
    &#125;

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;
        invoke(channel, Constants.ON_CONNECT_KEY);
    &#125;

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;
        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;
            logger.info(<span class="string">"disconected from "</span> + channel.getRemoteAddress() + <span class="string">",url:"</span> + channel.getUrl());
        &#125;
        invoke(channel, Constants.ON_DISCONNECT_KEY);
    &#125;

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Channel channel, String methodKey)</span> </span>&#123;
        Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);
        <span class="keyword">if</span> (invocation != <span class="keyword">null</span>) &#123;
            <span class="keyword">try</span> &#123;
                received(channel, invocation);
            &#125; <span class="keyword">catch</span> (Throwable t) &#123;
                logger.warn(<span class="string">"Failed to invoke event method "</span> + invocation.getMethodName() + <span class="string">"(), cause: "</span> + t.getMessage(), t);
            &#125;
        &#125;
    &#125;

    <span class="function"><span class="keyword">private</span> Invocation <span class="title">createInvocation</span><span class="params">(Channel channel, URL url, String methodKey)</span> </span>&#123;
        String method = url.getParameter(methodKey);
        <span class="keyword">if</span> (method == <span class="keyword">null</span> || method.length() == <span class="number">0</span>) &#123;
            <span class="keyword">return</span> <span class="keyword">null</span>;
        &#125;
        RpcInvocation invocation = <span class="keyword">new</span> RpcInvocation(method, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], <span class="keyword">new</span> Object[<span class="number">0</span>]);
        invocation.setAttachment(Constants.PATH_KEY, url.getPath());
        invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));
        invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));
        invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY));
        <span class="keyword">if</span> (url.getParameter(Constants.STUB_EVENT_KEY, <span class="keyword">false</span>)) &#123;
            invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString());
        &#125;
        <span class="keyword">return</span> invocation;
    &#125;
&#125;;
</code></pre><p>Exchangeers.bind(URL url, ExchangeHandler handler)</p><pre><code class="java">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;
    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);
    &#125;
    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);
    &#125;
    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);
    <span class="keyword">return</span> getExchanger(url).bind(url, handler);
&#125;
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(URL url)</span> </span>&#123;
    String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);
    <span class="keyword">return</span> getExchanger(type);
&#125;
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(String type)</span> </span>&#123;
    <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Exchanger<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">type</span>)</span>;
&#125;
</code></pre><p>接口作用是设置exchanger params为header 并且获取Exchanger.class的header扩展接口HeaderExchanger， 并调用bind方法：</p><pre><code class="java">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchanger</span> <span class="keyword">implements</span> <span class="title">Exchanger</span> </span>&#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"header"</span>;
    <span class="function"><span class="keyword">public</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;
        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>);
    &#125;
    <span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;
        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));
    &#125;
&#125;
</code></pre><p>先将 DubboProtocol入参 传过来的ExchangeHandler对象ExchangeHandlerAdapter() 进行包装组成handler链：最后返回ChannelHandler对象，接下来调用：Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))) Server Transporters.bind(URL url, ChannelHandler… handlers) Transpoter$Adaptive.bind()<br><img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"><br>数据透传 NettyTransporter.java Server NettyTransporter.bind(URL url, ChannelHandler listener)</p><pre><code class="java">  <span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;
    <span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, listener);
&#125;
</code></pre><p>作用是：<br>返回一个NettyServer实例：</p><pre><code class="java">  <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;
    <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));
&#125;
</code></pre><p>ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)) 只用是生成获取ThreadName的名称 为URL添加threadname的param ChannelHandlers.wrap(ChannelHandler handler, URL url) 代码如下：</p><pre><code class="java">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHandlers</span> </span>&#123;

    <span class="keyword">private</span> <span class="keyword">static</span> ChannelHandlers INSTANCE = <span class="keyword">new</span> ChannelHandlers();

    <span class="function"><span class="keyword">protected</span> <span class="title">ChannelHandlers</span><span class="params">()</span> </span>&#123;
    &#125;
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelHandler <span class="title">wrap</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;
        <span class="keyword">return</span> ChannelHandlers.getInstance().wrapInternal(handler, url);
    &#125;
    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> ChannelHandlers <span class="title">getInstance</span><span class="params">()</span> </span>&#123;
        <span class="keyword">return</span> INSTANCE;
    &#125;
    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTestingChannelHandlers</span><span class="params">(ChannelHandlers instance)</span> </span>&#123;
        INSTANCE = instance;
    &#125;
    <span class="function"><span class="keyword">protected</span> ChannelHandler <span class="title">wrapInternal</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;
        <span class="keyword">return</span> <span class="keyword">new</span> MultiMessageHandler(<span class="keyword">new</span> HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher<span class="class">.<span class="keyword">class</span>)</span>
<span class="class">                .<span class="title">getAdaptiveExtension</span>().<span class="title">dispatch</span>(<span class="title">handler</span>, <span class="title">url</span>)))</span>;
    &#125;
&#125;
</code></pre><p>ExtensionLoader.getExtensionLoader(Dispatcher.class).getAdaptiveExtension().dispatch(handler, url)： <img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"><br>获取到AllDispatcher分发器进行透传：</p><pre><code class="java">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span> </span>&#123;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"all"</span>;

    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;
        <span class="keyword">return</span> <span class="keyword">new</span> AllChannelHandler(handler, url);
    &#125;
&#125;
</code></pre><p>结构如图所示：<img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"><br>调用WrappedChannelHandler的构造方法：</p><pre><code class="java">  <span class="function"><span class="keyword">public</span> <span class="title">WrappedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;
    <span class="keyword">this</span>.handler = handler;
    <span class="keyword">this</span>.url = url;
    executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;

    String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY;
    <span class="keyword">if</span> (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) &#123;
        componentKey = Constants.CONSUMER_SIDE;
    &#125;
    DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;
    dataStore.put(componentKey, Integer.toString(url.getPort()), executor);
&#125;
</code></pre><p>这段代码的功能为：<br>1.将 之前头创的DecoderHandler对象再进包装 包装为AllChannelHandler 2.生成线程池对象Executor对象 3.获取默认的DataStore对象，并将线程池对象放入DataStore 中 key为 : java.util.concurrent.ExecutorService 字符串和服务暴露的端口 值为线程池对象<br>return new MultiMessageHandler(new HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher.class) .getAdaptiveExtension().dispatch(handler, url))); 接下来将返回的AllChannelHandler对象用HeartbeatHandler 和 MultiMessageHandler 进行包装处理并返回ChannelHandler.wrap() 的上一端。<br>NettyTransporter.bind(URL url, ChannelHandler listener) -&gt; new NettyServer(URL url, ChannelHandler handler) -&gt; super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME))); 接下来是创建NettyServer对象的最后一步：</p><pre><code class="java">  NettyServer ==&gt;
<span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;
    <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));
&#125;
AbstractServer==&gt;
<span class="function"><span class="keyword">public</span> <span class="title">AbstractServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;
    <span class="keyword">super</span>(url, handler);
    localAddress = getUrl().toInetSocketAddress();
    String host = url.getParameter(Constants.ANYHOST_KEY, <span class="keyword">false</span>)
            || NetUtils.isInvalidLocalHost(getUrl().getHost())
            ? NetUtils.ANYHOST : getUrl().getHost();
    bindAddress = <span class="keyword">new</span> InetSocketAddress(host, getUrl().getPort());
    <span class="keyword">this</span>.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);
    <span class="keyword">this</span>.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);
    <span class="keyword">try</span> &#123;
        doOpen();
        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;
            logger.info(<span class="string">"Start "</span> + getClass().getSimpleName() + <span class="string">" bind "</span> + getBindAddress() + <span class="string">", export "</span> + getLocalAddress());
        &#125;
    &#125; <span class="keyword">catch</span> (Throwable t) &#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(url.toInetSocketAddress(), <span class="keyword">null</span>, <span class="string">"Failed to bind "</span> + getClass().getSimpleName()
                + <span class="string">" on "</span> + getLocalAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);
    &#125;
    <span class="comment">//fixme replace this with better method</span>
    DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;
    executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));
&#125;

AbstractEndpoint ==&gt;
<span class="function"><span class="keyword">public</span> <span class="title">AbstractEndpoint</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;
    <span class="keyword">super</span>(url, handler);
    <span class="keyword">this</span>.codec = getChannelCodec(url);
    <span class="keyword">this</span>.timeout = url.getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
    <span class="keyword">this</span>.connectTimeout = url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT);
&#125;
AbstractPeer==&gt;
<span class="function"><span class="keyword">public</span> <span class="title">AbstractPeer</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;
    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);
    &#125;
    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);
    &#125;
    <span class="keyword">this</span>.url = url;
    <span class="keyword">this</span>.handler = handler;
&#125;
</code></pre><p>调用栈如上所示： 因为之前设置了codec为dubbo 所以返回DubboCountCodec实例 获取超时时间timeout ,和链接的超时时间connectTimeout localAddress为本地IP:PORT port为服务暴露的端口 host 为0.0.0.0 bindAddress为 host:port port为服务暴露的端口 this.accept 为默认获取最大连接数 idleTimeout为 url中 idle.timeout 核心代码：doOpen()</p><pre><code class="java">  <span class="meta">@Override</span>
<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;
    NettyHelper.setNettyLoggerFactory();
    ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));
    ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));
    ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));
    bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);

    <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);
    channels = nettyHandler.getChannels();
    <span class="comment">// https://issues.jboss.org/browse/NETTY-365</span>
    <span class="comment">// https://issues.jboss.org/browse/NETTY-379</span>
    <span class="comment">// final Timer timer = new HashedWheelTimer(new NamedThreadFactory("NettyIdleTimer", true));</span>
    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;
        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;
            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);
            ChannelPipeline pipeline = Channels.pipeline();
            <span class="comment">/*int idleTimeout = getIdleTimeout();</span>
<span class="comment">            if (idleTimeout &gt; 10000) &#123;</span>
<span class="comment">                pipeline.addLast("timer", new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));</span>
<span class="comment">            &#125;*/</span>
            pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());
            pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());
            pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);
            <span class="keyword">return</span> pipeline;
        &#125;
    &#125;);
    <span class="comment">// bind</span>
    channel = bootstrap.bind(getBindAddress());
&#125;

</code></pre><p>1.首先进行Netty的日志配置 接下来先生成 NettyCodecAdapter 入参为之前生成的codec , URL信息(主要用到buffer属性配置Netty缓冲区)及 this (Handler) 对象 接下来就是设置Netty的Encoder Decoder 来进行数据的编码与解码 其会调用 this的handler链来进行数据处理。Dubbo2.5.6采用的是Netty3来进行通讯的，此处就不进行赘述。<br>AbstractServer 接下来获取到从DataStore对象中获取之前缓存的线程池 ，设置 NettyServer的 executor属性。<br>自此，Dubbo服务暴露的代码解析完毕，NettyServer的类结构图如下：<br><img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"></p><h4 id="心跳服务"><a href="#心跳服务" class="headerlink" title="心跳服务"></a>心跳服务</h4><p>Dubbo provider的心跳服务是 HeaderExchanger bind代码执行的最后一步：参数是上面生成的Server对象 (NettyServer)。<br><img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"></p><pre><code class="java">  <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeServer</span><span class="params">(Server server)</span> </span>&#123;
    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"server == null"</span>);
    &#125;
    <span class="keyword">this</span>.server = server;
    <span class="keyword">this</span>.heartbeat = server.getUrl().getParameter(Constants.HEARTBEAT_KEY, <span class="number">0</span>);
    <span class="keyword">this</span>.heartbeatTimeout = server.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="number">3</span>);
    <span class="keyword">if</span> (heartbeatTimeout &lt; heartbeat * <span class="number">2</span>) &#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"heartbeatTimeout &lt; heartbeatInterval * 2"</span>);
    &#125;
    startHeatbeatTimer();
&#125;
</code></pre><p>1.初始化 server信息 2.获取server URL中heartbeat信息 及心跳超时信息，默认为heartbeat的三倍 3.执行心跳代码 startHeatbeatTimer()</p><pre><code class="java">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeatbeatTimer</span><span class="params">()</span> </span>&#123;
    stopHeartbeatTimer();
    <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) &#123;
        heatbeatTimer = scheduled.scheduleWithFixedDelay(
                <span class="keyword">new</span> HeartBeatTask(<span class="keyword">new</span> HeartBeatTask.ChannelProvider() &#123;
                    <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;
                        <span class="keyword">return</span> Collections.unmodifiableCollection(
                                HeaderExchangeServer.<span class="keyword">this</span>.getChannels());
                    &#125;
                &#125;, heartbeat, heartbeatTimeout),
                heartbeat, heartbeat, TimeUnit.MILLISECONDS);
    &#125;
&#125;
</code></pre><p>1.停止定时任务——首先停止定时器中所有任务，置空 beatbeatTimer； 2.重新设置定时器 ， ���环��测<br>接下来在DubboProtocol的openServer(URL) 方法中将创建的ExchangeServer对象放入 DubboProtocol的 serverMap 集合对象中 key为服务的ip:port 如 192.168.20.218:20880 value为之前创建的ExchangeServer对象<br>DubboProtocol export方法到此执行完毕，最终返回的是 DubboExporter对象包装了入参的invoker对象，serviceKey信息，及服务暴露的 exporterMap对象。<br><img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"><br><img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"></p><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><p>我们接着来看RegistryProtocol 接下来的执行代码：</p><pre><code class="java">  <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;
    <span class="comment">// 暴露服务</span>
    <span class="comment">//export invoker</span>
    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);

    <span class="comment">//registry provider 添加定时任务  ping request response</span>
    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);
    <span class="comment">// 获得服务提供者 URL</span>
    <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);

    registry.register(registedProviderUrl);
    <span class="comment">// 订阅override数据</span>
    <span class="comment">// FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span>
    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);
    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);
    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);
    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
    <span class="comment">//保证每次export都返回一个新的exporter实例</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Exporter&lt;T&gt;() &#123;
        <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;
            <span class="keyword">return</span> exporter.getInvoker();
        &#125;

        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;
            <span class="keyword">try</span> &#123;
                exporter.unexport();
            &#125; <span class="keyword">catch</span> (Throwable t) &#123;
                logger.warn(t.getMessage(), t);
            &#125;
            <span class="keyword">try</span> &#123;
                registry.unregister(registedProviderUrl);
            &#125; <span class="keyword">catch</span> (Throwable t) &#123;
                logger.warn(t.getMessage(), t);
            &#125;
            <span class="keyword">try</span> &#123;
                overrideListeners.remove(overrideSubscribeUrl);
                registry.unsubscribe(overrideSubscribeUrl, overrideSubscribeListener);
            &#125; <span class="keyword">catch</span> (Throwable t) &#123;
                logger.warn(t.getMessage(), t);
            &#125;
        &#125;
    &#125;;
&#125;
</code></pre><p>1.ExporterChangeableWrapper<t>doLocalExport(final Invoker<t>originInvoker) 为暴露服务的执行过程，上面流程已经走过。 返回的数据格式如下： <img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"><br>2.根据originInvoker中注册中心信息获取对应的Registry对象,因为这里是zookeeper协议，所以为ZookeeperRegistry对象 3.从注册中心的URL中获得 export 参数对应的值，即服务提供者的URL. 4.registry.register(registedProviderUrl); 用之前创建的注册中心对象注册服务 5.<br>// TODO</t></t></p><p>上面提到 Registry getRegistry(final Invoker&lt;?&gt; originInvoker) 是根据invoker的地址获取registry实例代码如下：</p><pre><code class="java">  <span class="function"><span class="keyword">private</span> Registry <span class="title">getRegistry</span><span class="params">(<span class="keyword">final</span> Invoker&lt;?&gt; originInvoker)</span> </span>&#123;
    <span class="comment">// registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;export=dubbo%3A%2F%2F192.168.20.218%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26default.accepts%3D1000%26default.threadpool%3Dfixed%26default.threads%3D100%26default.timeout%3D5000%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26owner%3Duce%26pid%3D12028%26side%3Dprovider%26timestamp%3D1531912729429&amp;owner=uce&amp;pid=12028&amp;registry=zookeeper&amp;timestamp=1531912729343</span>
    URL registryUrl = originInvoker.getUrl();
    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(registryUrl.getProtocol())) &#123;
        String protocol = registryUrl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_DIRECTORY);
        registryUrl = registryUrl.setProtocol(protocol).removeParameter(Constants.REGISTRY_KEY);
    &#125;
    <span class="comment">// zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;export=dubbo%3A%2F%2F192.168.20.218%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26default.accepts%3D1000%26default.threadpool%3Dfixed%26default.threads%3D100%26default.timeout%3D5000%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26owner%3Duce%26pid%3D12028%26side%3Dprovider%26timestamp%3D1531912729429&amp;owner=uce&amp;pid=12028&amp;timestamp=1531912729343</span>
    <span class="keyword">return</span> registryFactory.getRegistry(registryUrl);
&#125;
</code></pre><p>上面代码的意思是： 1.获取originalInvoker中的URL信息 (注册中心的配置信息) 2.将URL中信息中Param中registry参数获取到，并替换URL中的protocol属性，并删除Param中的registry信息，上面代码中的注释为执行前和执行后的的结果。 3.获取protocol 为 zookeeper对应的RegistryFactory接口的扩展对象 ZookeeperRegistryFactory 并执行getRegistry 方法：<br><img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"><br>ZookeeperRegistryFactory的继承结构和对应类中属性如下图所示： <img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册">其中REGISTRIES = new ConcurrentHashMap&lt;String, Registry&gt;(); 代表注册中心的配置，其中可以有多个注册中心配置<br>AbstractRegistryFactory.getRegistry执行代码如下：</p><pre><code class="java">  <span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;
    url = url.setPath(RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>
<span class="class">            .<span class="title">addParameter</span>(<span class="title">Constants</span>.<span class="title">INTERFACE_KEY</span>, <span class="title">RegistryService</span>.<span class="title">class</span>.<span class="title">getName</span>())</span>
<span class="class">            .<span class="title">removeParameters</span>(<span class="title">Constants</span>.<span class="title">EXPORT_KEY</span>, <span class="title">Constants</span>.<span class="title">REFER_KEY</span>)</span>;
    String key = url.toServiceString();   <span class="comment">// zookeeper://192.168.1.157:2181/com.alibaba.dubbo.registry.RegistryService</span>
    <span class="comment">// 锁定注册中心获取过程，保证注册中心单一实例</span>
    LOCK.lock();
    <span class="keyword">try</span> &#123;
        Registry registry = REGISTRIES.get(key);
        <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;
            <span class="keyword">return</span> registry;
        &#125;
        registry = createRegistry(url);
        <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create registry "</span> + url);
        &#125;
        REGISTRIES.put(key, registry);
        <span class="keyword">return</span> registry;
    &#125; <span class="keyword">finally</span> &#123;
        <span class="comment">// 释放锁</span>
        LOCK.unlock();
    &#125;
&#125;
</code></pre><p>1.设置Path属性，添加interface参数信息，及移除export 和 refer 参数信息。执行结果如下： zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.registry.RegistryService&amp;owner=uce&amp;pid=12028&amp;timestamp=1531912729343 2.获取url对应的serviceString信息：zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService，由于我使用的是本地的zookeeper 所以IP为 127.0.0.1 3.顺序地创建注册中心：Registry ZookeeperRegistryFactory.createRegistry(URL url);</p><pre><code class="java">  <span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;
    <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);
&#125;
<span class="comment">// 构造ZookeeperRegistry的调用链如下所示</span>
<span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;
    <span class="keyword">super</span>(url);
    <span class="keyword">if</span> (url.isAnyHost()) &#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);
    &#125;
    String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);
    <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;
        group = Constants.PATH_SEPARATOR + group;
    &#125;
    <span class="keyword">this</span>.root = group;
    zkClient = zookeeperTransporter.connect(url);
    zkClient.addStateListener(<span class="keyword">new</span> StateListener() &#123;
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;
            <span class="keyword">if</span> (state == RECONNECTED) &#123;
                <span class="keyword">try</span> &#123;
                    recover();
                &#125; <span class="keyword">catch</span> (Exception e) &#123;
                    logger.error(e.getMessage(), e);
                &#125;
            &#125;
        &#125;
    &#125;);
&#125;
<span class="function"><span class="keyword">public</span> <span class="title">FailbackRegistry</span><span class="params">(URL url)</span> </span>&#123;
    <span class="keyword">super</span>(url);
    <span class="keyword">int</span> retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);
    <span class="keyword">this</span>.retryFuture = retryExecutor.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;
            <span class="comment">// 检测并连接注册中心</span>
            <span class="keyword">try</span> &#123;
                retry();
            &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// 防御性容错</span>
                logger.error(<span class="string">"Unexpected error occur at failed retry, cause: "</span> + t.getMessage(), t);
            &#125;
        &#125;
    &#125;, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);
&#125;
<span class="function"><span class="keyword">public</span> <span class="title">AbstractRegistry</span><span class="params">(URL url)</span> </span>&#123;
    setUrl(url);
    <span class="comment">// 启动文件保存定时器</span>
    syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, <span class="keyword">false</span>);
    String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(<span class="string">"user.home"</span>) + <span class="string">"/.dubbo/dubbo-registry-"</span> + url.getHost() + <span class="string">".cache"</span>);
    File file = <span class="keyword">null</span>;
    <span class="keyword">if</span> (ConfigUtils.isNotEmpty(filename)) &#123;
        file = <span class="keyword">new</span> File(filename);
        <span class="keyword">if</span> (!file.exists() &amp;&amp; file.getParentFile() != <span class="keyword">null</span> &amp;&amp; !file.getParentFile().exists()) &#123;
            <span class="keyword">if</span> (!file.getParentFile().mkdirs()) &#123;
                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid registry store file "</span> + file + <span class="string">", cause: Failed to create directory "</span> + file.getParentFile() + <span class="string">"!"</span>);
            &#125;
        &#125;
    &#125;
    <span class="keyword">this</span>.file = file;
    loadProperties();
    notify(url.getBackupUrls());
&#125;
</code></pre><p>ZookeeperRegistry 的类继承结构图如图所示：<br><img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"> ZooKeeperRegistry.FailbackRegistry.AbstractRegistry中 1.setUrl设置url属性信息 2.是否启用文件的异步保存 3.注册中心对应的本地文件保存的位置信息：如C:\Users\Administrator/.dubbo/dubbo-registry-127.0.0.1.cache 4.给file赋值 并且加载文件信息到properties属性中 5.notify(url.getBackupUrls) 这段代码不知道什么意思。<br>ZooKeeperRegistry.FailbackRegistry中 1.获取定时任务的时间间隔。 2.开启定时任务定时检测失败的注册，并重新注册。<br>ZooKeeperRegistry 中 1.获取注册中心的group参数 ，默认为/dubbo , 并未root赋予group值 2.zkClient = zookeeperTransporter.connect(url); 链接zookeeper信息并添加状态监听事件，具体再更文详述吧，代码如下：</p><pre><code class="java">  <span class="function"><span class="keyword">public</span> <span class="title">ZkclientZookeeperClient</span><span class="params">(URL url)</span> </span>&#123;
    <span class="keyword">super</span>(url);
    client = <span class="keyword">new</span> ZkClient(url.getBackupAddress());
    client.subscribeStateChanges(<span class="keyword">new</span> IZkStateListener() &#123;
        <span class="meta">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStateChanged</span><span class="params">(KeeperState state)</span> <span class="keyword">throws</span> Exception </span>&#123;
            ZkclientZookeeperClient.<span class="keyword">this</span>.state = state;
            <span class="keyword">if</span> (state == KeeperState.Disconnected) &#123;
                stateChanged(StateListener.DISCONNECTED);
            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == KeeperState.SyncConnected) &#123;
                stateChanged(StateListener.CONNECTED);
            &#125;
        &#125;

        <span class="meta">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNewSession</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;
            stateChanged(StateListener.RECONNECTED);
        &#125;
    &#125;);
&#125;
</code></pre><p>3.添加重连状态的状态监听事件 调用 recover()方法。 至此 ZookeeperRegistry创建完毕。<br>ZookeeperRegistryFactory中最后将registry放入 ZookeeperRegistryFactory.REGISTRIES中 key 为zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService value 为之前创建的ZookeeperRegistry对象。<br>接着返回RegistryProtocol 的export方法 ， 1.上面说到了调用doLocalExport(originInvoker);进行服务暴露的过程及调用getRegistry(originInvoker)方法通过ZookeeperRegistryFactory 工厂生成 ZookeeperRegistry 方法，然后加入到工厂REGISTRIES 缓存中，并返回ZookeeperRegistry 实例的过程。<br>2.接下来RegistryProtocol 的export方法中调用 final URL registedProviderUrl = getRegistedProviderUrl(originInvoker); 获取服务提供者的URL信息 ， 它是从注册中心的URL中获得export参数对应的值转换的URL信息。（去除掉不需要在注册中心上看到的字段） <img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"><br>3.接下来调用registry.register(registedProviderUrl); 进行服务的注册将暴露的服务信息注册到注册中心，并且将已经注册的服务URL缓存到ZookeeperRegistry.registered 已注册服务的缓存中。</p><pre><code class="java">  FailbackRegistry.register
<span class="comment">/**</span>
<span class="comment"> * 进行服务注册逻辑的实现</span>
<span class="comment"> */</span>
<span class="meta">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;
    <span class="keyword">if</span> (destroyed.get())&#123;
        <span class="keyword">return</span>;
    &#125;
    <span class="comment">// 调用AbstractRegistry.register进行服务对应URL的缓存</span>
    <span class="keyword">super</span>.register(url);
    failedRegistered.remove(url);
    failedUnregistered.remove(url);
    <span class="keyword">try</span> &#123;
        <span class="comment">// 向服务器端发送注册请求，将服务注册到注册中心，可以使用各个注册协议(注册中心)的实现 此处使用zookeeper  ZookeeperRegistry.doRegister</span>
        doRegister(url);
    &#125; <span class="keyword">catch</span> (Exception e) &#123;
        Throwable t = e;

        <span class="comment">// 如果开启了启动时检测，则直接抛出异常</span>
        <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)
                &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)
                &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());
        <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;
        <span class="keyword">if</span> (check || skipFailback) &#123;
            <span class="keyword">if</span> (skipFailback) &#123;
                t = t.getCause();
            &#125;
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to register "</span> + url + <span class="string">" to registry "</span> + getUrl().getAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);
        &#125; <span class="keyword">else</span> &#123;
            logger.error(<span class="string">"Failed to register "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);
        &#125;

        <span class="comment">// 将失败的注册请求记录到失败列表，定时重试</span>
        failedRegistered.add(url);
    &#125;
&#125;
AbstractRegistry.register
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;
    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"register url == null"</span>);
    &#125;
    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;
        logger.info(<span class="string">"Register: "</span> + url);
    &#125;
    <span class="comment">// 缓存已经注册的服务</span>
    registered.add(url);
&#125;
ZookeeperRegistry.doRegister
<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;
    <span class="keyword">try</span> &#123;
        <span class="comment">// 此处为具体服务暴露的代码 toUrlPath 根据URL生成写入zk的路径信息</span>
        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));
    &#125; <span class="keyword">catch</span> (Throwable e) &#123;
        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);
    &#125;
&#125;
</code></pre><p>4.由registryProviderUrl获取overrideSubscribeUrl 再构建OverrideListener</p><h4 id="赞赏支持"><a href="#赞赏支持" class="headerlink" title="赞赏支持"></a>赞赏支持</h4><p><img src="https://oscimg.oschina.net/oscnet/b3ce042b0cdf415c14b4721241a95d72154.jpg" alt="Test" title="Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册"></p><div class="post-copyright"><div class="content"><p>本文标题： 推荐系列-Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册</p><p>本文作者： OSChina</p><p>发布时间： 2021年04月15日 09:19</p><p>最后更新： 2022年03月27日 09:29</p><p>原始链接： <a class="post-url" href="/c1aba8a6/" title="推荐系列-Dubbo服务发布之服务暴露&amp;心跳机制&amp;服务注册">https://www.hosiang.cn/c1aba8a6/</a></p><p>版权声明： 本文著作权归作者所有，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a>许可协议，转载请注明出处！</p><footer><a href="https://www.hosiang.cn"><img src="/../images/logo.png" alt="Howe Hsiang"> Howe Hsiang</a></footer></div></div><div class="page-reward"><a id="rewardBtn" href="javascript:;">赏</a></div><div id="reward" class="post-modal reward-lay"><a class="close" href="javascript:;" id="reward-close">×</a> <span class="reward-title"><i class="icon icon-quote-left"></i> 喜欢就赞赏一下呗！ <i class="icon icon-quote-right"></i></span><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="/images/threepay_code.jpg" alt="打赏二维码"></div><div class="reward-select"></div></div></div></div><footer class="article-footer"><div class="post-share"><a href="javascript:" id="share-sub" class="post-share-fab"><i class="fa fa-share-alt" style="padding-top:11px!important"></i></a><div class="post-share-list" id="share-list"><ul class="share-icons"><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.hosiang.cn/c1aba8a6/" data-title="Facebook" rel="external nofollow noopener noreferrer"><i class="fa fa-facebook" style="padding-top:9px!important"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《推荐系列-Dubbo服务发布之服务暴露&心跳机制&服务注册》 — 狂欢马克思&url=https://www.hosiang.cn/c1aba8a6/&via=https://www.hosiang.cn" data-title="Twitter" rel="external nofollow noopener noreferrer"><i class="fa fa-twitter" style="padding-top:9px!important"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.hosiang.cn/c1aba8a6/" data-title="Google+" rel="external nofollow noopener noreferrer"><i class="fa fa-google-plus" style="padding-top:9px!important"></i></a></li><li><a class="qq share-sns" target="_blank" href="https://connect.qq.com/widget/shareqq/index.html?url=https://www.hosiang.cn/c1aba8a6/&title=《推荐系列-Dubbo服务发布之服务暴露&心跳机制&服务注册》 — 狂欢马克思&source=&emsp;&emsp;Dubbo服务发布 Dubbo服务发布影响流程的主要包括三个部分，依次是： 服务暴露 心跳 服务注册 服务暴露是对外提供服务及暴露..." data-title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-qq" style="padding-top:9px!important"></i></a></li><li><a class="weixin share-sns" id="wxFab" href="javascript:" data-title="微信"><i class="fa fa-weixin" style="padding-top:9px!important"></i></a></li><li><a class="weibo share-sns" target="_blank" href="https://service.weibo.com/share/share.php?url=https://www.hosiang.cn/c1aba8a6/&title=《推荐系列-Dubbo服务发布之服务暴露&心跳机制&服务注册》 — 狂欢马克思&pic=https://images.pexels.com/photos/886521/pexels-photo-886521.jpeg?cs=srgb&dl=art-close-up-ecology-886521.jpg&fm=jpg" data-title="微博" rel="external nofollow noopener noreferrer"><i class="fa fa-weibo" style="padding-top:9px!important"></i></a></li></ul></div></div><div class="post-modal wx-share" id="wxShare"><a class="close" href="javascript:" id="wxShare-close">×</a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://www.hosiang.cn/c1aba8a6/" alt="微信分享二维码"></div><div class="mask"></div><ul class="article-footer-menu"><li class="article-footer-tags"><i class="fa fa-tags"></i> <a href="/tags/Popular/" class="color3">Popular</a></li></ul></footer></div></article><aside class="post-toc-pos post-toc-top" id="post-toc"><nav class="post-toc-wrap"><ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Dubbo%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83"><span class="post-toc-text">Dubbo服务发布</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2"><span class="post-toc-text">Dubbo服务暴露</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BF%83%E8%B7%B3%E6%9C%8D%E5%8A%A1"><span class="post-toc-text">心跳服务</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="post-toc-text">服务注册</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B5%9E%E8%B5%8F%E6%94%AF%E6%8C%81"><span class="post-toc-text">赞赏支持</span></a></li></ol></li></ol></nav></aside><nav id="article-nav"><a href="/16d52ba0/" id="article-nav-newer" class="article-nav-link-wrap"><span class="article-nav-title"><i class="fa fa-hand-o-left" aria-hidden="true"></i> 推荐系列-深入理解Object提供的阻塞和唤醒API </span></a><a href="/2a2ed114/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">推荐系列-mybatis源码，从配置到 mappedStatement —— mapper.xml 是如何被解析的-</span> <i class="fa fa-hand-o-right" aria-hidden="true"></i></a></nav><div id="gitalk"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({repo:"bolg-comment",owner:"Hosiang1026",admin:"Hosiang1026",clientID:"37a2dd4473e8970cecc2",clientSecret:"e30efa17d86d9de4f4ab810872dc62a7b2e7e634",pagerDirection:"last",distractionFreeMode:!0,createIssueManually:!1});gitalk.render("gitalk")</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"><script id="_wau78w">var _wau=_wau||[];_wau.push(["small","5dnguv4c2n","78w"])</script><script async src="//waust.at/s.js"></script><p><span id="busuanzi_container_site_uv" style="display:none"><span class="post-count">总字数：<span>1543.2k</span> </span>总访客数：<span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" style="display:none">总访问量：<span id="busuanzi_value_site_pv"></span></span><br><span id="TimeShow">本站</span><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br>Copyright&copy; 2018 - 2022 狂欢马克思 <a href="https://beian.miit.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">京ICP备17060439号</a></p></div></div><script>var now=new Date;function createtime(){var n=new Date("2017/09/18");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",800)</script></footer><script>var mihoConfig={root:"https://www.hosiang.cn",animate:"true",isHome:"false",share:"true",reward:" 1"}</script><div class="sidebar"><div id="sidebar-search" title="Search"><i class="fa fa-search"></i></div><div id="sidebar-category" title="Categories"><i class="fa fa-book"></i></div><div id="sidebar-tag" title="Tags"><i class="fa fa-tags"></i></div><div id="sidebar-top"><span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span></div></div><div class="sidebar-menu-box" id="sidebar-menu-box"><div class="sidebar-menu-box-container"><div id="sidebar-menu-box-categories"><a class="category-link" href="/categories/%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD/">兴趣爱好</a><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/">其他开发</a><a class="category-link" href="/categories/%E5%89%8D%E6%B2%BF%E5%BC%80%E5%8F%91/">前沿开发</a><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a><a class="category-link" href="/categories/%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/">升级版本</a><a class="category-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">博客教程</a><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="category-link" href="/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</a><a class="category-link" href="/categories/%E7%83%AD%E9%97%A8%E6%96%87%E7%AB%A0/">热门文章</a></div><div id="sidebar-menu-box-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:16px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:14px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:14px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Interview/" style="font-size:18px">Interview</a> <a href="/tags/Java/" style="font-size:12px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:16px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:16px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div><a href="javascript:" class="sidebar-menu-box-close">&times;</a></div><div class="mobile-header-menu-nav" id="mobile-header-menu-nav"><div class="mobile-header-menu-container"><span class="title">导航</span><ul class="mobile-header-menu-navbar"><li><a href="/"><i class="fa fa-home"></i><span>主页</span></a></li><li><a href="/archives"><i class="fa fa-archive"></i><span>归档</span></a></li><li><a href="/gitbook"><i class="fa fa-columns"></i><span>笔记</span></a></li><li><a href="/music"><i class="fa fa-music"></i><span>音乐</span></a></li><li><a href="/photo"><i class="fa fa-picture-o"></i><span>相册</span></a></li><li><a href="/collection"><i class="fa fa-envira"></i><span>收藏</span></a></li><li><a href="/about"><i class="fa fa-user"></i><span>关于</span></a></li></ul></div><div class="mobile-header-tag-container"><span class="title">标签</span><div id="mobile-header-container-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:16px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:14px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:14px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Interview/" style="font-size:18px">Interview</a> <a href="/tags/Java/" style="font-size:12px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:16px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:16px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div></div><div class="search-wrap"><span class="search-close">&times;</span> <a href="javascript:" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input class="search-field" placeholder="Search..." id="keywords"> <a id="search-submit" href="javascript:"><i class="fa fa-search"></i></a><div class="search-container" id="search-container"><ul class="search-result" id="search-result"></ul></div></div><div id="search-tpl"><li class="search-result-item"><a href="{url}" class="search-item-li"><span class="search-item-li-title" title="{title}">{title}</span></a></li></div><script src="/js/search.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script><div id="particles"></div><script src="/js/particles.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css"><script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script><script src="/js/animate.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0,scale:.5},log:!1})</script></body></html>