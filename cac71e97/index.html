<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Access-Control-Allow-Origin" content="*"><script type="text/javascript">var start_time=(new Date).getTime()</script><meta http-equiv="Cache-Control" content="no-cache"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="google-site-verification" content="9Wt3lmnrT2bfjaHla5s16adhvcQcBHO7PtNf97n5Od0"><meta name="baidu-site-verification" content="RYlYHsgO7Y"><meta name="sogou_site_verification" content="MSmrTj7lHV"><meta name="shenma-site-verification" content="e4428ccce0f22fad61c3716193bf4bd7_1571416388"><meta name="baidu_union_verify" content="584bb6b4bd24108df082b6d20c7aa9be"><title>推荐系列-深入理解 WKWebView (渲染篇) —— DOM 树的构建 | 狂欢马克思</title><meta name="keywords" content="分享技术经验与交流"><meta name="description" content="&amp;emsp;&amp;emsp;12003字，预计阅读时间24分钟 当客户端 App 主进程创建 WKWebView 对象时，会创建另外两个子进程:渲染进程与网络进程。主进程 WKWebView 发起请求时，先将请求转发给渲染进程，渲染进程再…"><meta property="og:type" content="article"><meta property="og:title" content="推荐系列-深入理解 WKWebView (渲染篇) —— DOM 树的构建"><meta property="og:url" content="https://www.hosiang.cn/cac71e97/index.html"><meta property="og:site_name" content="狂欢马克思"><meta property="og:description" content="&amp;emsp;&amp;emsp;12003字，预计阅读时间24分钟 当客户端 App 主进程创建 WKWebView 对象时，会创建另外两个子进程:渲染进程与网络进程。主进程 WKWebView 发起请求时，先将请求转发给渲染进程，渲染进程再…"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-03-27T03:55:56.000Z"><meta property="article:modified_time" content="2022-03-27T03:57:05.379Z"><meta property="article:author" content="Howe Hsiang"><meta property="article:tag" content="Popular"><meta name="twitter:card" content="summary"><link rel="icon" href="/images/favicon.ico"><link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/font-awesome-animation/0.1.0/font-awesome-animation.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3cd8fa109426bf3f10bd5c362175bace";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 5.4.1"></head><script src="/js/jquery.min.js"></script><script src="/js/pace.min.js"></script><script src="/js/crypto-js.js"></script><script src="/js/cookie.js"></script><script src="/js/calendar.js"></script><script src="/js/festival.js"></script><script>getFestival()</script><body><script>window.onload=function(){document.getElementById("TimeShow").innerHTML="本站耗时 "+((new Date).getTime()-start_time)/1e3+" 秒 "}</script><div id="container"><header id="header"><div id="banner"></div><div id="header-outer"><div id="header-menu" class="header-menu-pos animated"><div class="header-menu-container"><a href="/" class="left"><span class="site-title">狂欢马克思</span></a><nav id="header-menu-nav" class="right"><a href="/" rel="external nofollow"><i class="fa fa-home"></i> <span>主页</span> </a><a href="/archives" rel="external nofollow"><i class="fa fa-archive"></i> <span>归档</span> </a><a href="/gitbook" rel="external nofollow"><i class="fa fa-columns"></i> <span>笔记</span> </a><a href="/photo" rel="external nofollow"><i class="fa fa-picture-o"></i> <span>相册</span> </a><a href="/love" rel="external nofollow"><i class="fa fa-heart"></i> <span>恋爱</span> </a><a href="/collection" rel="external nofollow"><i class="fa fa-envira"></i> <span>收藏</span> </a><a href="/about" rel="external nofollow"><i class="fa fa-user"></i> <span>关于</span></a></nav><a class="mobile-header-menu-button"><i class="fa fa-bars"></i></a></div></div><div id="header-row"><div id="logo"><a href="/"><img src="/../images/logo.png" alt="logo"></a></div><div class="header-info"><div id="header-title"><h2>狂欢马克思</h2></div><div id="header-description"><h3>专注Web开发</h3></div></div><nav class="header-nav"><div class="social"><a title="Github" target="_blank" href="//github.com/Hosiang1026" rel="external nofollow"><i class="fa fa-github fa-2x"></i></a> <a title="QQ" target="_blank" href="//wpa.qq.com/msgrd?v=3&uin=641904695&site=qq&menu=yes" rel="external nofollow"><i class="fa fa-qq fa-2x"></i></a> <a title="Weibo" target="_blank" href="//www.weibo.com/haoxiang969" rel="external nofollow"><i class="fa fa-weibo fa-2x"></i></a></div></nav></div><div id="noticeId" class="show" style="background:rgb(244,247,247,.3)"><marquee id="noticeMar" behavior="scoll" class="notice" direction="left" onmouseover="this.stop()" onmouseout="this.start()"></marquee></div><script type="text/javascript">function browserRedirect(){var i=navigator.userAgent.toLowerCase(),n="ipad"==i.match(/ipad/i),o="iphone os"==i.match(/iphone os/i),a="midp"==i.match(/midp/i),t="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),e="ucweb"==i.match(/ucweb/i),s="android"==i.match(/android/i),d="windows ce"==i.match(/windows ce/i),p="windows mobile"==i.match(/windows mobile/i),r="",c=randomColor(),r=n||o||a||t||e||s||d||p?($("#noticeId").css({"line-height":"1.6em"}),"<font style='color:"+c+"' face='新华宋体'  size='2'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='hitokoto'></span></span></span><span id='YQData'></font> "):($("#noticeId").css({"line-height":"3.6em","margin-top":"20px"}),"<font style='color:"+c+"' face='新华宋体'  size='6'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='hitokoto'></span></span><span id='YQData'></span></font> ");$("#noticeMar").html(r)}function randomColor(){for(var i="0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f".split(","),n="#",o=0;o<6;o++)n+=i[Math.floor(16*Math.random())];return n}$(function(){browserRedirect(),0<$("#hitokoto").length&&getHitokoto()})</script></div></header><script>console.log=function(){}</script><div class="outer"><section id="main" class="body-wrap"><article id="post-深入理解 WKWebView (渲染篇) —— DOM 树的构建" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="post-title" itemprop="name">推荐系列-深入理解 WKWebView (渲染篇) —— DOM 树的构建</h1><div class="post-title-bar"><ul><li><i class="fa fa-book"></i> <a href="/categories/热门文章/">热门文章</a></li><li><i class="fa fa-calendar"></i> 2022-03-27</li><li><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span></li><li><span class="post-count">字数统计: 10k字</span></li><li><span class="post-count">阅读时长: 43分钟</span></li></ul></div></header><div class="article-entry post-content" itemprop="articleBody"><p>&emsp;&emsp;12003字，预计阅读时间24分钟 当客户端 App 主进程创建 WKWebView 对象时，会创建另外两个子进程:渲染进程与网络进程。主进程 WKWebView 发起请求时，先将请求转发给渲染进程，渲染进程再…<br><span id="more"></span></p><pre><code>程序员健身是为了保养还是保命？参与话题讨论赢好礼 &gt;&gt;&gt;

                                                                                        全文12003字，预计阅读时间24分钟 
</code></pre><p>当客户端 App 主进程创建 WKWebView 对象时，会创建另外两个子进程:渲染进程与网络进程。主进程 WKWebView 发起请求时，先将请求转发给渲染进程，渲染进程再转发给网络进程，网络进程请求服务器。如果请求的是一个网页，网络进程会将服务器的响应数据 HTML 文件字符流吐给渲染进程。渲染进程拿到 HTML 文件字符流，首先要进行解析，将 HTML 文件字符流转换成 DOM 树，然后在 DOM 树的基础上，进行渲染操作，也就是布局、绘制。最后渲染进程通知主进程 WKWebView 创建对应的 View 展现视图。整个流程如下图所示:</p><h3 id="一、什么是DOM树"><a href="#一、什么是DOM树" class="headerlink" title="一、什么是DOM树"></a>一、什么是DOM树</h3><p>渲染进程获取到 HTML 文件字符流，会将HTML文件字符流转换成 DOM 树。下图中左侧是一个 HTML 文件，右边就是转换而成的 DOM 树。</p><p>可以看到 DOM 树的根节点是 HTMLDocument，代表整个文档。根节点下面的子节点与 HTML 文件中的标签是一一对应的，比如 HTML 中的</p><head>标签就对应 DOM 树中的 head 节点。同时 HTML 文件中的文本，也成为 DOM 树中的一个节点，比如文本 ‘Hello, World!’，在 DOM 树中就成为div节点的子节点。<br>在 DOM 树中每一个节点都是具有一定方法与属性��对象，这些对象由对应的类创建出来。比如 HTMLDocument 节点，它对应的类是 class HTMLDocument，下面是 HTMLDocument 的部分源码:</head><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">HTMLDocument</span> : <span class="keyword">public</span> Document &#123; <span class="comment">// 继承自 Document</span></span><br><span class="line">   ...</span><br><span class="line">WEBCORE_EXPORT <span class="type">int</span> <span class="title function_">width</span><span class="params">()</span>;</span><br><span class="line">WEBCORE_EXPORT <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span>;</span><br><span class="line">    ...</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从源码中可以看到，HTMLDocument 继承自类 Document，Document 类的部分源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span></span><br><span class="line">  : <span class="keyword">public</span> ContainerNode  <span class="comment">// Document继承自 ContainerNode，ContainerNode继承自Node</span></span><br><span class="line">  , <span class="keyword">public</span> TreeScope</span><br><span class="line">  , <span class="keyword">public</span> ScriptExecutionContext</span><br><span class="line">  , <span class="keyword">public</span> FontSelectorClient</span><br><span class="line">  , <span class="keyword">public</span> FrameDestructionObserver</span><br><span class="line">  , <span class="keyword">public</span> Supplementable&lt;Document&gt;</span><br><span class="line">  , <span class="keyword">public</span> Logger::Observer</span><br><span class="line">  , <span class="keyword">public</span> CanvasObserver &#123;</span><br><span class="line">    WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; <span class="title function_">createElementForBindings</span><span class="params">(const AtomString&amp; tagName)</span>;  <span class="comment">// 创建Element的方法</span></span><br><span class="line">    WEBCORE_EXPORT Ref&lt;Text&gt; <span class="title function_">createTextNode</span><span class="params">(const String&amp; data)</span>; <span class="comment">// 创建文本节点的方法</span></span><br><span class="line">    WEBCORE_EXPORT Ref&lt;Comment&gt; <span class="title function_">createComment</span><span class="params">(const String&amp; data)</span>; <span class="comment">// 创建注释的方法</span></span><br><span class="line">    WEBCORE_EXPORT Ref&lt;Element&gt; <span class="title function_">createElement</span><span class="params">(const QualifiedName&amp;, bool createdByParser)</span>; <span class="comment">// 创建Element方法</span></span><br><span class="line">    ....</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面源码可以看到 Document 继承自 Node，而且还可以看到前端十分熟悉的 createElement、createTextNode 等方法，JavaScript 对这些方法的调用，最后都转换为对应 C++ 方法的调用。<br>类 Document 有这些方法，并不是没有原因的，而是 W3C 组织给出的标准规定的，这个标准就是 DOM(Document Object Model，文档对象模型)。DOM 定义了 DOM 树中每个节点需要实现的接口和属性，下面是 HTMLDocument、Document、HTMLDivElement 的部分 IDL(Interactive Data Language，接口描述语言，与具体平台和语言无关)描述，完整的 IDL 可以参看 W3C 。<br>在 DOM 树中，每一个节点都继承自类 Node，同时 Node 还有一个子类 Element，有的节点直接继承自类 Node，比如文本节点，而有的节点继承自类 Element，比如 div 节点。因此针对上面图中的 DOM 树，执行下面的 JavaScript 语句返回的结果是不一样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  document.childNodes; <span class="comment">// 返回子Node集合，返回DocumentType与HTML节点，都继承自Node</span></span><br><span class="line">document.children; <span class="comment">// 返回子Element集合，只返回HTML节点，DocumentType不继承自Element</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下图给出部分节点的继承关系图:</p><h3 id="二、DOM树构建"><a href="#二、DOM树构建" class="headerlink" title="二、DOM树构建"></a>二、DOM树构建</h3><p>DOM 树的构建流程可以分为4个步骤: 解码、分词、创建节点、添加节点。</p><h4 id="2-1-解码"><a href="#2-1-解码" class="headerlink" title="2.1 解码"></a>2.1 解码</h4><p>渲染进程从网络进程接收过来的是 HTML 字节流，而下一步分词是以字符为单位进行的。由于各种编码规范的存在，比如 ISO-8859-1、UTF-8 等，一个字符常常可能对应一个或者多个编码后的字节，解码的目的就是将 HTML 字节流转换成 HTML 字符流，或者换句话说，就是将原始的 HTML 字节流转换成字符串。</p><h5 id="2-1-1-解码类图"><a href="#2-1-1-解码类图" class="headerlink" title="2.1.1 解码类图"></a>2.1.1 解码类图</h5><p>从类图上看，类 HTMLDocumentParser 处于解码的核心位置，由这个类调用解码器将 HTML 字节流解码成字符流，存储到类 HTMLInputStream 中。</p><h5 id="2-1-2-解码流程"><a href="#2-1-2-解码流程" class="headerlink" title="2.1.2 解码流程"></a>2.1.2 解码流程</h5><p>整个解码流程当中，最关健的是如何找到正确的编码���式。只有找到了正确的编码方式，才能使用对应的解码器进行解码。解码发生的地方如下面源代码所示，这个方法在上图第3个栈帧被调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// HTMLDocumentParser是DecodedDataDocumentParser的子类</span></span><br><span class="line"><span class="keyword">void</span> DecodedDataDocumentParser::appendBytes(DocumentWriter&amp; writer, const uint8_t* data, size_t length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!length)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">decoded</span> <span class="operator">=</span> writer.decoder().decode(data, length); <span class="comment">// 真正解码发生在这里</span></span><br><span class="line"><span class="keyword">if</span> (decoded.isEmpty())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    writer.reportDataReceived();</span><br><span class="line">    append(decoded.releaseImpl());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码第7行 writer.decoder() 返回一个 TextResourceDecoder 对象，解码操作由 TextResourceDecoder::decode 方法完成。下面逐步查看 TextResourceDecoder::decode 方法的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 只保留了最重要的部分</span></span><br><span class="line">String TextResourceDecoder::decode(const <span class="type">char</span>* data, size_t length)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是HTML文件，就从head标签中寻找字符集</span></span><br><span class="line">     <span class="keyword">if</span> ((m_contentType == HTML || m_contentType == XML) &amp;&amp; !m_checkedForHeadCharset) <span class="comment">// HTML and XML</span></span><br><span class="line">         <span class="keyword">if</span> (!checkForHeadCharset(data, length, movedDataToBuffer))</span><br><span class="line">             <span class="keyword">return</span> emptyString();</span><br><span class="line">             </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">     <span class="comment">// m_encoding存储者从HTML文件中找到的编码名称</span></span><br><span class="line">     <span class="keyword">if</span> (!m_codec)</span><br><span class="line">         m_codec = newTextCodec(m_encoding);  <span class="comment">// 创建具体的编码器</span></span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码并返回</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> m_codec-&gt;decode(m_buffer.data() + lengthOfBOM, m_buffer.size() - lengthOfBOM, <span class="literal">false</span>, m_contentType == XML &amp;&amp; !m_useLenientXMLDecoding, m_sawError);</span><br><span class="line">     m_buffer.clear(); <span class="comment">// 清空存储的原始未解码的HTML字节流</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从源码中可以看到，TextResourceDecoder 首先从 HTML 的</p><head>标签中去找编码方式，因为<head>标签可以包含<meta>标签，<meta>标签可以设置 HTML 文件的字符集:</head></head><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  &lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt; &lt;!-- 字符集指定--&gt;</span><br><span class="line">&lt;title&gt;DOM Tree&lt;/title&gt;</span><br><span class="line">&lt;script&gt;window.name = <span class="string">&#x27;Lucy&#x27;</span>;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果能找到对应的字符集，TextResourceDeocder 将其存储在成员变量 m_encoding 当中，并且根据对应的编码创建真正的解码器存储在成员变量 m_codec 中，最终使用 m_codec 对字节流进行解码，并且返回解码后的字符串。如果带有字符集的</p><meta>标签没有找到，TextResourceDeocder 的 m_encoding 有默认值 windows-1252(等同于ISO-8859-1)。<br>下面看一下 TextResourceDecoder 寻找<meta>标签中字符集的流程，也就是上面源码中第8行对 checkForHeadCharset 函数的调用:<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 只保留了关健代码</span></span><br><span class="line">bool TextResourceDecoder::checkForHeadCharset(const <span class="type">char</span>* data, size_t len, bool&amp; movedDataToBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is not completely efficient, since the function might go</span></span><br><span class="line"><span class="comment">// through the HTML head several times.</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="variable">oldSize</span> <span class="operator">=</span> m_buffer.size();</span><br><span class="line">    m_buffer.grow(oldSize + len);</span><br><span class="line">memcpy(m_buffer.data() + oldSize, data, len); <span class="comment">// 将字节流数据拷贝到自己的缓存m_buffer里面</span></span><br><span class="line"></span><br><span class="line">    movedDataToBuffer = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Continue with checking for an HTML meta tag if we were already doing so.</span></span><br><span class="line"><span class="keyword">if</span> (m_charsetParser)</span><br><span class="line"><span class="keyword">return</span> checkForMetaCharset(data, len);  <span class="comment">// 如果已经存在了meta标签解析器，直接开始解析</span></span><br><span class="line"></span><br><span class="line">     ....</span><br><span class="line"></span><br><span class="line">    m_charsetParser = makeUnique&lt;HTMLMetaCharsetParser&gt;(); <span class="comment">// 创建meta标签解析器</span></span><br><span class="line"><span class="keyword">return</span> checkForMetaCharset(data, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面源代码中第11行，类 TextResourceDecoder 内部存储了需要解码的 HTML 字节流，这一步骤很重要，后面会讲到。先看第17行、21行、22行，这3行主要是使用</p><meta>标签解析器解析字符集，使用了懒加载的方式。下面看下 checkForMetaCharset 这个函数的实现:<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  bool TextResourceDecoder::checkForMetaCharset(const <span class="type">char</span>* data, size_t length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!m_charsetParser-&gt;checkForMetaCharset(data, length))  <span class="comment">// 解析meta标签字符集</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    setEncoding(m_charsetParser-&gt;encoding(), EncodingFromMetaTag); <span class="comment">// 找到后设置字符编码名称</span></span><br><span class="line">    m_charsetParser = nullptr;</span><br><span class="line">    m_checkedForHeadCharset = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面源码第3行可以看到，整个解析</p><meta>标签的任务在类 HTMLMetaCharsetParser::checkForMetaCharset 中完成。<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 只保留了关健代码</span></span><br><span class="line">bool HTMLMetaCharsetParser::checkForMetaCharset(const <span class="type">char</span>* data, size_t length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_doneChecking) <span class="comment">// 标志位，避免重复解析</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// We still don&#x27;t have an encoding, and are in the head.</span></span><br><span class="line">    <span class="comment">// The following tags are allowed in &lt;head&gt;:</span></span><br><span class="line"><span class="comment">// SCRIPT|STYLE|META|LINK|OBJECT|TITLE|BASE</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We stop scanning when a tag that is not permitted in &lt;head&gt;</span></span><br><span class="line"><span class="comment">// is seen, rather when &lt;/head&gt; is seen, because that more closely</span></span><br><span class="line"><span class="comment">// matches behavior in other browsers; more details in</span></span><br><span class="line"><span class="comment">// &lt;http://bugs.webkit.org/show_bug.cgi?id=3590&gt;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Additionally, we ignore things that looks like tags in &lt;title&gt;, &lt;script&gt;</span></span><br><span class="line"><span class="comment">// and &lt;noscript&gt;; see &lt;http://bugs.webkit.org/show_bug.cgi?id=4560&gt;,</span></span><br><span class="line"><span class="comment">// &lt;http://bugs.webkit.org/show_bug.cgi?id=12165&gt; and</span></span><br><span class="line"><span class="comment">// &lt;http://bugs.webkit.org/show_bug.cgi?id=12389&gt;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Since many sites have charset declarations after &lt;body&gt; or other tags</span></span><br><span class="line"><span class="comment">// that are disallowed in &lt;head&gt;, we don&#x27;t bail out until we&#x27;ve checked at</span></span><br><span class="line"><span class="comment">// least bytesToCheckUnconditionally bytes of input.</span></span><br><span class="line"></span><br><span class="line">constexpr <span class="type">int</span> <span class="variable">bytesToCheckUnconditionally</span> <span class="operator">=</span> <span class="number">1024</span>;  <span class="comment">// 如果解析了1024个字符还未找到带有字符集的&lt;meta&gt;标签，整个解析也算完成，此时没有解析到正确的字符集，就使用默认编码windows-1252(等同于ISO-8859-1)</span></span><br><span class="line"></span><br><span class="line">bool ignoredSawErrorFlag;</span><br><span class="line">    m_input.append(m_codec-&gt;decode(data, length, <span class="literal">false</span>, <span class="literal">false</span>, ignoredSawErrorFlag)); <span class="comment">// 对字节流进行解码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="type">auto</span> <span class="variable">token</span> <span class="operator">=</span> m_tokenizer.nextToken(m_input)) &#123; <span class="comment">// m_tokenizer进行分词操作，找meta标签也需要进行分词，分词操作后面讲</span></span><br><span class="line"><span class="type">bool</span> <span class="variable">isEnd</span> <span class="operator">=</span> token-&gt;type() == HTMLToken::EndTag;</span><br><span class="line"><span class="keyword">if</span> (isEnd || token-&gt;type() == HTMLToken::StartTag) &#123;</span><br><span class="line">AtomString <span class="title function_">tagName</span><span class="params">(token-&gt;name()</span>);</span><br><span class="line"><span class="keyword">if</span> (!isEnd) &#123;</span><br><span class="line">                m_tokenizer.updateStateFor(tagName);</span><br><span class="line"><span class="keyword">if</span> (tagName == metaTag &amp;&amp; processMeta(*token)) &#123; <span class="comment">// 找到meta标签进行处理</span></span><br><span class="line">                    m_doneChecking = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果找到了带有编码的meta标签，直接返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tagName != scriptTag &amp;&amp; tagName != noscriptTag</span><br><span class="line">                &amp;&amp; tagName != styleTag &amp;&amp; tagName != linkTag</span><br><span class="line">                &amp;&amp; tagName != metaTag &amp;&amp; tagName != objectTag</span><br><span class="line">                &amp;&amp; tagName != titleTag &amp;&amp; tagName != baseTag</span><br><span class="line">                &amp;&amp; (isEnd || tagName != htmlTag)</span><br><span class="line">                &amp;&amp; (isEnd || tagName != headTag)) &#123;</span><br><span class="line">                m_inHeadSection = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!m_inHeadSection &amp;&amp; m_input.numberOfCharactersConsumed() &gt;= bytesToCheckUnconditionally) &#123; <span class="comment">// 如果分词已经进入了&lt;body&gt;标签范围，同时分词数量已经超过了1024，也算成功</span></span><br><span class="line">            m_doneChecking = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面源码第29行，类 HTMLMetaCharsetParser 也有一个解码器 m_codec，解码器是在 HTMLMetaCharsetParser 对象创建时生成，这个解码器的真实类型是 TextCodecLatin1(Latin1编码也就是ISO-8859-1，等同于windows-1252编码)。之所以可以直接使用 TextCodecLatin1 解码器，是因为</p><meta>标签如果设置正确，都是英文字符，完全可以使用 TextCodecLatin1 进行解析出来。这样就避免了为了找到<meta>标签，需要对字节流进行解码，而要解码就必须要找到<meta>标签这种鸡生蛋、蛋生鸡的问题。<br>代码第37行对找到的<meta>标签进行处理，这个函数比较简单，主要是解析<meta>标签当中的属性，然后查看这些属性名中有没有 charset。<p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  bool HTMLMetaCharsetParser::processMeta(HTMLToken&amp; token)</span><br><span class="line">&#123;</span><br><span class="line">    AttributeList attributes;</span><br><span class="line"><span class="keyword">for</span> (auto&amp; attribute : token.attributes()) &#123; <span class="comment">// 获取meta标签属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">attributeName</span> <span class="operator">=</span> StringImpl::create8BitIfPossible(attribute.name);</span><br><span class="line">        <span class="type">String</span> <span class="variable">attributeValue</span> <span class="operator">=</span> StringImpl::create8BitIfPossible(attribute.value);</span><br><span class="line">        attributes.append(std::make_pair(attributeName, attributeValue));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_encoding = encodingFromMetaAttributes(attributes); <span class="comment">// 从属性中找字符集设置属性charset</span></span><br><span class="line"><span class="keyword">return</span> m_encoding.isValid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面分析 TextResourceDecoder::checkForHeadCharset 函数时，讲过第11行 TextResourceDecoder 类存储 HTML 字节流的操作很重要。原因是可能整个 HTML 字节流里面可能确实没有设置 charset 的</p><meta>标签，此时 TextResourceDecoder::checkForHeadCharset 函数就要返回 false，导致 TextResourceDecoder::decode 函数返回空字符串，也就是不进行任何解码。是不是这样呢？真实的情况是，在接收HTML字节流整个过程中由于确实没有找到带有 charset 属性的<meta>标签，那么整个接收期间都不会解码。但是完整的 HTML 字节流会被存储在 TextResourceDecoder 的成员变量 m_buffer 里面，当整个 HTML 字节流接收结束的时，会有如下调用栈:<p></p><p>从调用栈可以看到，当 HTML 字节流接收完成，最终会调用 TextResourceDecoder::flush 方法，这个方法会将 TextResourceDecoder 中有 m_buffer 存储的 HTML 字节流进行解码，由于在接收 HTML 字节流期间未成功找到编码方式，因此 m_buffer 里面存储的就是所有待解码的 HTML 字节流，然后在这里使用默认的编码 windows-1252 对全部字节流进行解码。因此，如果 HTML 字节流中包含汉字，那么如果不指定字符集，最终页面就会出现乱码。解码完成后，会将解码之后的字符流存储到 HTMLDocumentParser 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> DecodedDataDocumentParser::flush(DocumentWriter&amp; writer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">remainingData</span> <span class="operator">=</span> writer.decoder().flush();</span><br><span class="line"><span class="keyword">if</span> (remainingData.isEmpty())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    writer.reportDataReceived();</span><br><span class="line">    append(remainingData.releaseImpl()); <span class="comment">// 解码后的字符流存储到HTMLDocumentParser</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-1-3-解码总结"><a href="#2-1-3-解码总结" class="headerlink" title="2.1.3 解码总结"></a>2.1.3 解码总结</h5><p>整个解码过程可以分为两种情形: 第一种情形是 HTML 字节流可以解析出带有 charset 属性的</p><meta>标签，这样就可以获取相应的编码方式，那么每接收到一个 HML 字节流，都可以使用相应的编码方式进行解码，将解码后的字符流添加到 HTMLInputStream 当中；第二种是 HTML 字节流不能解析带有 charset 属性的<meta>标签，这样每接收到一个 HTML 字节流，都缓存到 TextResourceDecoder 的 m_buffer 缓存，等完整的 HTML 字节流接收完毕，就会使用默认的编码 windows-1252 进行解码。<p></p><h4 id="2-2-分词"><a href="#2-2-分词" class="headerlink" title="2.2 分词"></a>2.2 分词</h4><p>接收到的 HTML 字节流经过解码，成为存储在 HTMLInputStream 中的字符流。分词的过程就是从 HTMLInputStream 中依次取出每一个字符，然后判断字符是否是特殊的 HTML 字符’ &lt;’、’/‘、’&gt;’、’=’ 等。根据这些特殊字符的分割，就能解析出 HTML 标签名以及属性列表，类 HTMLToken 就是存储分词出来的结果。</p><h5 id="2-2-1-分词类图"><a href="#2-2-1-分词类图" class="headerlink" title="2.2.1 分词类图"></a>2.2.1 分词类图</h5><p>从类图中可以看到，分词最重要的是类 HTMLTokenizer 和类 HTMLToken。下面是类 HTMLToken 的主要信息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只保留了主要信息</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">HTMLToken</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">enum</span> <span class="title class_">Type</span> &#123; <span class="comment">// Token的类型</span></span><br><span class="line">         Uninitialized, <span class="comment">// Token初始化时的类型</span></span><br><span class="line">         DOCTYPE, <span class="comment">// 代表Token是DOCType标签</span></span><br><span class="line">         StartTag, <span class="comment">// 代表Token是一个开始标签</span></span><br><span class="line">         EndTag, <span class="comment">// 代表Token是一个结束标签</span></span><br><span class="line">         Comment, <span class="comment">// 代表Token是一个注释</span></span><br><span class="line">         Character, <span class="comment">// 代表Token是文本</span></span><br><span class="line">         EndOfFile, <span class="comment">// 代表Token是文件结尾</span></span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     struct Attribute &#123; <span class="comment">// 存储属性的数据结构</span></span><br><span class="line">         Vector&lt;UChar, <span class="number">32</span>&gt; name; <span class="comment">// 属性名</span></span><br><span class="line">         Vector&lt;UChar, <span class="number">64</span>&gt; value; <span class="comment">// 属性值</span></span><br><span class="line">         <span class="comment">// Used by HTMLSourceTracker.</span></span><br><span class="line">       unsigned startOffset;</span><br><span class="line">         unsigned endOffset;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     typedef Vector&lt;Attribute, <span class="number">10</span>&gt; AttributeList; <span class="comment">// 属性列表</span></span><br><span class="line">     typedef Vector&lt;UChar, <span class="number">256</span>&gt; DataVector; <span class="comment">// 存储Token名</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     Type m_type;</span><br><span class="line">     DataVector m_data;</span><br><span class="line">     <span class="comment">// For StartTag and EndTag</span></span><br><span class="line">     bool m_selfClosing; <span class="comment">// Token是注入&lt;img&gt;一样自结束标签</span></span><br><span class="line">     AttributeList m_attributes;</span><br><span class="line">     Attribute* m_currentAttribute; <span class="comment">// 当前正在解析的属性</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-2-2-分词流程"><a href="#2-2-2-分词流程" class="headerlink" title="2.2.2 分词流程"></a>2.2.2 分词流程</h5><p>上面分词流程中 HTMLDocumentParser::pumpTokenizerLoop 方法是最重要的，从方法名字可以看出这个方法里面包含循环逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 只保留关健代码</span></span><br><span class="line">bool HTMLDocumentParser::pumpTokenizerLoop(SynchronousMode mode, bool parsingFragment, PumpSession&amp; session)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// 分词循环体开始</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (UNLIKELY(mode == AllowYield &amp;&amp; m_parserScheduler-&gt;shouldYieldBeforeToken(session))) <span class="comment">// 避免长时间处于分词循环中，这里根据条件暂时退出循环</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!parsingFragment)</span><br><span class="line">            m_sourceTracker.startToken(m_input.current(), m_tokenizer);</span><br><span class="line"></span><br><span class="line"><span class="type">auto</span> <span class="variable">token</span> <span class="operator">=</span> m_tokenizer.nextToken(m_input.current()); <span class="comment">// 进行分词操作，取出一个token</span></span><br><span class="line"><span class="keyword">if</span> (!token)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 分词没有产生token，就跳出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!parsingFragment)</span><br><span class="line">            m_sourceTracker.endToken(m_input.current(), m_tokenizer);</span><br><span class="line"></span><br><span class="line">        constructTreeFromHTMLToken(token); <span class="comment">// 根据token构建DOM树</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!isStopped());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中第7行会有一个 yield 退出操作，这是为了避免长时间处于分词循环，占用主线程。当退出条件为真时，会从分词循环中返回，返回值为 true。下面是退出判断代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 只保留关健代码</span></span><br><span class="line">bool HTMLParserScheduler::shouldYieldBeforeToken(PumpSession&amp; session)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// numberOfTokensBeforeCheckingForYield是静态变量，定义为4096</span></span><br><span class="line"><span class="comment">// session.processedTokensOnLastCheck表示从上一次退出为止，以及处理过的token个数</span></span><br><span class="line"><span class="comment">// session.didSeeScript表示在分词过程中是否出现过script标签</span></span><br><span class="line"><span class="keyword">if</span> (UNLIKELY(session.processedTokens &gt; session.processedTokensOnLastCheck + numberOfTokensBeforeCheckingForYield || session.didSeeScript))</span><br><span class="line"><span class="keyword">return</span> checkForYield(session);</span><br><span class="line"></span><br><span class="line">        ++session.processedTokens;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool HTMLParserScheduler::checkForYield(PumpSession&amp; session)</span><br><span class="line">    &#123;</span><br><span class="line">        session.processedTokensOnLastCheck = session.processedTokens;</span><br><span class="line">        session.didSeeScript = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Seconds</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> MonotonicTime::now() - session.startTime;</span><br><span class="line"><span class="keyword">return</span> elapsedTime &gt; m_parserTimeLimit; <span class="comment">// m_parserTimeLimit的值默认是500ms，从分词开始超过500ms就要先yield</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果命中了上面的 yield 退出条件，那么什么时候再次进入分词呢？下面的代码展示了再次进入分词的过程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 保留关键代码</span></span><br><span class="line"><span class="keyword">void</span> HTMLDocumentParser::pumpTokenizer(SynchronousMode mode)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shouldResume) <span class="comment">// 从pumpTokenizerLoop中yield退出时返回值为true</span></span><br><span class="line">        m_parserScheduler-&gt;scheduleForResume();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HTMLParserScheduler::scheduleForResume()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!m_suspended);</span><br><span class="line">    m_continueNextChunkTimer.startOneShot(0_s); <span class="comment">// 触发timer(0s后触发)，触发后的响应函数为HTMLParserScheduler::continueNextChunkTimerFired</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保留关健代码</span></span><br><span class="line"><span class="keyword">void</span> HTMLParserScheduler::continueNextChunkTimerFired()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    m_parser.resumeParsingAfterYield(); <span class="comment">// 重新Resume分词过程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HTMLDocumentParser::resumeParsingAfterYield()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// pumpTokenizer can cause this parser to be detached from the Document,</span></span><br><span class="line"><span class="comment">// but we need to ensure it isn&#x27;t deleted yet.</span></span><br><span class="line">    Ref&lt;HTMLDocumentParser&gt; <span class="title function_">protectedThis</span><span class="params">(*<span class="built_in">this</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We should never be here unless we can pump immediately.</span></span><br><span class="line"><span class="comment">// Call pumpTokenizer() directly so that ASSERTS will fire if we&#x27;re wrong.</span></span><br><span class="line">    pumpTokenizer(AllowYield); <span class="comment">// 重新进入分词过程，该函数会调用pumpTokenizerLoop</span></span><br><span class="line">    endIfDelayed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面代码可以看出，再次进入分词过程是通过触发一个 Timer 来实现的，虽然这个 Timer 在0s后触发，但是并不意味着 Timer 的响应函数会立刻执行。如果在此之前主线程已经有其他任务到达了执行时机，会有被执行的机会。<br>继续看 HTMLDocumentParser::pumpTokenizerLoop 函数的第13行，这一行进行分词操作，从解码后的字符流中分出一个 token。实现分词的代码位于 HTMLTokenizer::processToken:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 只保留关键代码</span></span><br><span class="line">bool HTMLTokenizer::processToken(SegmentedString&amp; source)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!m_preprocessor.peek(source, isNullCharacterSkippingState(m_state))) <span class="comment">// 取出source内部指向的字符，赋给m_nextInputCharacter</span></span><br><span class="line"><span class="keyword">return</span> haveBufferedCharacterToken();</span><br><span class="line">    <span class="type">UChar</span> <span class="variable">character</span> <span class="operator">=</span> m_preprocessor.nextInputCharacter(); <span class="comment">// 获取character</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://html.spec.whatwg.org/#tokenization</span></span><br><span class="line"><span class="keyword">switch</span> (m_state) &#123; <span class="comment">// 进行状态转换，m_state初始值为DataState</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法由于内部要做很多状态转换，总共有1200多行，后面会有4个例子���解释状态转换的逻辑。<br>首先来看 InputStreamPreprocessor::peek 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Returns whether we succeeded in peeking at the next character.</span></span><br><span class="line"><span class="comment">// The only way we can fail to peek is if there are no more</span></span><br><span class="line"><span class="comment">// characters in |source| (after collapsing \r\n, etc).</span></span><br><span class="line"> ALWAYS_INLINE bool InputStreamPreprocessor::peek(SegmentedString&amp; source, <span class="type">bool</span> <span class="variable">skipNullCharacters</span> <span class="operator">=</span> <span class="literal">false</span>)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="keyword">if</span> (UNLIKELY(source.isEmpty()))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">     m_nextInputCharacter = source.currentCharacter(); <span class="comment">// 获取字符流source内部指向的当前字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Every branch in this function is expensive, so we have a</span></span><br><span class="line"><span class="comment">// fast-reject branch for characters that don&#x27;t require special</span></span><br><span class="line"><span class="comment">// handling. Please run the parser benchmark whenever you touch</span></span><br><span class="line"><span class="comment">// this function. It&#x27;s very hot.</span></span><br><span class="line">constexpr <span class="type">UChar</span> <span class="variable">specialCharacterMask</span> <span class="operator">=</span> <span class="string">&#x27;\n&#x27;</span> | <span class="string">&#x27;\r&#x27;</span> | <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (LIKELY(m_nextInputCharacter &amp; ~specialCharacterMask)) &#123;</span><br><span class="line">         m_skipNextNewLine = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> processNextInputCharacter(source, skipNullCharacters); <span class="comment">// 跳过空字符，将\r\n换行符合并成\n</span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">bool InputStreamPreprocessor::processNextInputCharacter(SegmentedString&amp; source, bool skipNullCharacters)</span><br><span class="line">    &#123;</span><br><span class="line">    ProcessAgain:</span><br><span class="line">        ASSERT(m_nextInputCharacter == source.currentCharacter());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对\r\n换行符，下面if语句处理\r字符并且设置m_skipNextNewLine=true，后面处理\n就直接忽略</span></span><br><span class="line"><span class="keyword">if</span> (m_nextInputCharacter == <span class="string">&#x27;\n&#x27;</span> &amp;&amp; m_skipNextNewLine) &#123;</span><br><span class="line">            m_skipNextNewLine = <span class="literal">false</span>;</span><br><span class="line">            source.advancePastNewline(); <span class="comment">// 向前移动字符</span></span><br><span class="line"><span class="keyword">if</span> (source.isEmpty())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m_nextInputCharacter = source.currentCharacter();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是\r\n连续的换行符，那么第一次遇到\r字符，将\r字符替换成\n字符，同时设置标志m_skipNextNewLine=true</span></span><br><span class="line"><span class="keyword">if</span> (m_nextInputCharacter == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">            m_nextInputCharacter = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            m_skipNextNewLine = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_skipNextNewLine = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (m_nextInputCharacter || isAtEndOfFile(source))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过空字符</span></span><br><span class="line"><span class="keyword">if</span> (skipNullCharacters &amp;&amp; !m_tokenizer.neverSkipNullCharacters()) &#123;</span><br><span class="line">            source.advancePastNonNewline();</span><br><span class="line"><span class="keyword">if</span> (source.isEmpty())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m_nextInputCharacter = source.currentCharacter();</span><br><span class="line">goto ProcessAgain; <span class="comment">// 跳转到开头</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_nextInputCharacter = replacementCharacter;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于 peek 方法会跳过空字符，同时合并 \r\n 字符为 \n 字符，所以一个字符流 source 如果包含了空格或者 \r\n 换行符，实际上处理起来如下图所示:</p><p>HTMLTokenizer::processToken 内部定义了一个状态机，下面以四种情形来进行解释。<br>Case1：标签</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_STATE(DataState) <span class="comment">// 刚开始解析是DataState状态if (character == &#x27;&amp;&#x27;)            ADVANCE_PAST_NON_NEWLINE_TO(CharacterReferenceInDataState);if (character == &#x27;&lt;&#x27;) &#123;// 整个字符流一开始是&#x27;&lt;&#x27;，那么表示是一个标签的开始if (haveBufferedCharacterToken())                RETURN_IN_CURRENT_STATE(true);            ADVANCE_PAST_NON_NEWLINE_TO(TagOpenState); // 跳转到TagOpenState状态，并取去下一个字符是&#x27;!&quot;        &#125;if (character == kEndOfFileMarker)return emitEndOfFile(source);        bufferCharacter(character);        ADVANCE_TO(DataState);END_STATE()// ADVANCE_PAST_NON_NEWLINE_TO定义#define ADVANCE_PAST_NON_NEWLINE_TO(newState)                   \do &#123;                                                        \if (!m_preprocessor.advancePastNonNewline(source, isNullCharacterSkippingState(newState))) &#123; \ // 如果往下移动取不到下一个字符            m_state = newState;                                 \ // 保存状态return haveBufferedCharacterToken();                \ // 返回        &#125;                                                       \        character = m_preprocessor.nextInputCharacter();        \ // 先取出下一个字符        goto newState;                                          \ // 跳转到指定状态    &#125; while (false)BEGIN_STATE(TagOpenState)if (character == &#x27;!&#x27;) // 满足此条件            ADVANCE_PAST_NON_NEWLINE_TO(MarkupDeclarationOpenState); // 同理，跳转到MarkupDeclarationOpenState状态，并且取出下一个字符&#x27;D&#x27;if (character == &#x27;/&#x27;)            ADVANCE_PAST_NON_NEWLINE_TO(EndTagOpenState);if (isASCIIAlpha(character)) &#123;            m_token.beginStartTag(convertASCIIAlphaToLower(character));            ADVANCE_PAST_NON_NEWLINE_TO(TagNameState);        &#125;if (character == &#x27;?&#x27;) &#123;            parseError();// The spec consumes the current character before switching// to the bogus comment state, but it&#x27;s easier to implement// if we reconsume the current character.            RECONSUME_IN(BogusCommentState);        &#125;        parseError();        bufferASCIICharacter(&#x27;&lt;&#x27;);        RECONSUME_IN(DataState);END_STATE()BEGIN_STATE(MarkupDeclarationOpenState)if (character == &#x27;-&#x27;) &#123;            auto result = source.advancePast(&quot;--&quot;);if (result == SegmentedString::DidMatch) &#123;                m_token.beginComment();                SWITCH_TO(CommentStartState);            &#125;if (result == SegmentedString::NotEnoughCharacters)                RETURN_IN_CURRENT_STATE(haveBufferedCharacterToken());        &#125; else if (isASCIIAlphaCaselessEqual(character, &#x27;d&#x27;)) &#123; // 由于character == &#x27;D&#x27;，满足此条件            auto result = source.advancePastLettersIgnoringASCIICase(&quot;doctype&quot;); // 看解码后的字符流中是否有完整的&quot;doctype&quot;if (result == SegmentedString::DidMatch)                SWITCH_TO(DOCTYPEState); // 如果匹配，则跳转到DOCTYPEState，同时取出当前指向的字符，由于上面source字符流已经移动了&quot;doctype&quot;，因此此时取出的字符为&#x27;&gt;&#x27;if (result == SegmentedString::NotEnoughCharacters) // 如果不匹配                RETURN_IN_CURRENT_STATE(haveBufferedCharacterToken()); // 保存状态，直接返回        &#125; else if (character == &#x27;[&#x27; &amp;&amp; shouldAllowCDATA()) &#123;            auto result = source.advancePast(&quot;[CDATA[&quot;);if (result == SegmentedString::DidMatch)                SWITCH_TO(CDATASectionState);if (result == SegmentedString::NotEnoughCharacters)                RETURN_IN_CURRENT_STATE(haveBufferedCharacterToken());        &#125;        parseError();        RECONSUME_IN(BogusCommentState);END_STATE()#define SWITCH_TO(newState)                                     \do &#123;                                                        \if (!m_preprocessor.peek(source, isNullCharacterSkippingState(newState))) &#123; \            m_state = newState;                                 \return haveBufferedCharacterToken();                \        &#125;                                                       \        character = m_preprocessor.nextInputCharacter();        \ // 取出下一个字符        goto newState;                                          \ // 跳转到指定的state    &#125; while (false)#define RETURN_IN_CURRENT_STATE(expression)                     \do &#123;                                                        \        m_state = currentState;                                 \ // 保存当前状态return expression;                                      \    &#125; while (false)BEGIN_STATE(DOCTYPEState)if (isTokenizerWhitespace(character))        ADVANCE_TO(BeforeDOCTYPENameState);if (character == kEndOfFileMarker) &#123;        parseError();        m_token.beginDOCTYPE();        m_token.setForceQuirks();return emitAndReconsumeInDataState();    &#125;    parseError();    RECONSUME_IN(BeforeDOCTYPENameState);END_STATE()#define RECONSUME_IN(newState)                                  \do &#123;                                                        \ // 直接跳转到指定state        goto newState;                                          \    &#125; while (false) BEGIN_STATE(BeforeDOCTYPENameState)if (isTokenizerWhitespace(character))            ADVANCE_TO(BeforeDOCTYPENameState);if (character == &#x27;&gt;&#x27;) &#123; // character == &#x27;&gt;&#x27;，匹配此处，到���DOCTYPE标签匹配完毕            parseError();            m_token.beginDOCTYPE();            m_token.setForceQuirks();return emitAndResumeInDataState(source);        &#125;if (character == kEndOfFileMarker) &#123;            parseError();            m_token.beginDOCTYPE();            m_token.setForceQuirks();return emitAndReconsumeInDataState();        &#125;        m_token.beginDOCTYPE(toASCIILower(character));        ADVANCE_PAST_NON_NEWLINE_TO(DOCTYPENameState);END_STATE()inline bool HTMLTokenizer::emitAndResumeInDataState(SegmentedString&amp; source)&#123;    saveEndTagNameIfNeeded();    m_state = DataState; // 重置状态为初始状态DataState    source.advancePastNonNewline(); // 移动到下一个字符return true;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DOCTYPE Token 经历了6个状态最终被解析出来，整个过程如下图所示:</p><p>当 Token 解析完毕之后，分词状态又被重置为 DataState，同时需要注意的时，此时字符流 source 内部指向的是下一个字符 ‘&lt;’。<br>上面代码第61行在用字符流 source 匹配字符串 “doctype” 时，可能出现匹配不上的情形。为什么会这样呢？这是因为整个 DOM 树的构建流程，并不是先要解码完成，解码完成之后获取到完整的字符流才进行分词。从前面解码可以知道，解码可能是一边接收字节流，一边进行解码的，因此分词也是这样，只要能解码出一段字符流，就会立即进行分词。整个流程会出现如下图所示:</p><p>由于这个原因，用来分词的字符流可能是不完整的。对于出现不完整情形的 DOCTYPE 分词过程如下图所示:</p><p>上面介绍了解码、分词、解码、分词处理 DOCTYPE 标签的情形，可以看到从逻辑上这种情形与完整解码再分词是一样的。后续介绍时都会只针对完整解码再分词的情形，对于一边解码一边分词的情形，只需要正确的认识 source 字符流内部指针的移动，并不难分析。<br>Case2：标签</p><p></p><html>标签的分词过程和 &lt;!DOCTYPE&gt; 类似，其相关代码如下:</html><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  BEGIN_STATE(TagOpenState)</span><br><span class="line"><span class="keyword">if</span> (character == <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">        ADVANCE_PAST_NON_NEWLINE_TO(MarkupDeclarationOpenState);</span><br><span class="line"><span class="keyword">if</span> (character == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        ADVANCE_PAST_NON_NEWLINE_TO(EndTagOpenState);</span><br><span class="line"><span class="keyword">if</span> (isASCIIAlpha(character)) &#123; <span class="comment">// 在开标签状态下，当前字符为&#x27;h&#x27;</span></span><br><span class="line">        m_token.beginStartTag(convertASCIIAlphaToLower(character)); <span class="comment">// 将&#x27;h&#x27;添加到Token名中</span></span><br><span class="line">        ADVANCE_PAST_NON_NEWLINE_TO(TagNameState); <span class="comment">// 跳转到TagNameState，并移动到下一个字符&#x27;t&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (character == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">        parseError();</span><br><span class="line"><span class="comment">// The spec consumes the current character before switching</span></span><br><span class="line"><span class="comment">// to the bogus comment state, but it&#x27;s easier to implement</span></span><br><span class="line"><span class="comment">// if we reconsume the current character.</span></span><br><span class="line">        RECONSUME_IN(BogusCommentState);</span><br><span class="line">    &#125;</span><br><span class="line">    parseError();</span><br><span class="line">    bufferASCIICharacter(<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">    RECONSUME_IN(DataState);</span><br><span class="line">END_STATE()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEGIN_STATE(TagNameState)</span><br><span class="line"><span class="keyword">if</span> (isTokenizerWhitespace(character))</span><br><span class="line">        ADVANCE_TO(BeforeAttributeNameState);</span><br><span class="line"><span class="keyword">if</span> (character == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        ADVANCE_PAST_NON_NEWLINE_TO(SelfClosingStartTagState);</span><br><span class="line"><span class="keyword">if</span> (character == <span class="string">&#x27;&gt;&#x27;</span>) <span class="comment">// 在这个状态下遇到起始标签终止字符</span></span><br><span class="line"><span class="keyword">return</span> emitAndResumeInDataState(source); <span class="comment">// 当前分词结束，重置分词状态为DataState</span></span><br><span class="line"><span class="keyword">if</span> (m_options.usePreHTML5ParserQuirks &amp;&amp; character == <span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> emitAndReconsumeInDataState();</span><br><span class="line"><span class="keyword">if</span> (character == kEndOfFileMarker) &#123;</span><br><span class="line">        parseError();</span><br><span class="line">        RECONSUME_IN(DataState);</span><br><span class="line">    &#125;</span><br><span class="line">    m_token.appendToName(toASCIILower(character)); <span class="comment">// 将当前字符添加到Token名</span></span><br><span class="line">    ADVANCE_PAST_NON_NEWLINE_TO(TagNameState); <span class="comment">// 继续跳转到当前状态，并移动到下一个字符</span></span><br><span class="line">END_STATE()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Case3：带有属性的标签</p><div><br>HTML 标签可以带有属性，属性由属性名和属性值组成，属性之间以及属性与标签名之间用空格分隔:</div><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &lt;!-- div标签有两个属性，属性名为class和align，它们的值都带有引号 --&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;news&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;Hello,World!&lt;/div&gt;</span><br><span class="line">&lt;!-- 属性值也可以不带引号 --&gt;</span><br><span class="line">&lt;div class=news align=center&gt;Hello,World!&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整个</p><div>标签的解析中，标签名 div 的解析流程和上面的<html>标签解析一样，当在解析标签名的过程中，碰到了空白字符，说明要开始解析属性了，下面是相关代码:</html></div><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_STATE(TagNameState)<span class="keyword">if</span> (isTokenizerWhitespace(character)) <span class="comment">// 在解析TagName时遇到空白字符，标志属性开始        ADVANCE_TO(BeforeAttributeNameState);if (character == &#x27;/&#x27;)        ADVANCE_PAST_NON_NEWLINE_TO(SelfClosingStartTagState);if (character == &#x27;&gt;&#x27;)return emitAndResumeInDataState(source);if (m_options.usePreHTML5ParserQuirks &amp;&amp; character == &#x27;&lt;&#x27;)return emitAndReconsumeInDataState();if (character == kEndOfFileMarker) &#123;        parseError();        RECONSUME_IN(DataState);    &#125;    m_token.appendToName(toASCIILower(character));    ADVANCE_PAST_NON_NEWLINE_TO(TagNameState);END_STATE()#define ADVANCE_TO(newState)                                    \do &#123;                                                        \if (!m_preprocessor.advance(source, isNullCharacterSkippingState(newState))) &#123; \ // 移动到下一个字符            m_state = newState;                                 \return haveBufferedCharacterToken();                \        &#125;                                                       \        character = m_preprocessor.nextInputCharacter();        \        goto newState;                                          \ // 跳转到指定状态    &#125; while (false)BEGIN_STATE(BeforeAttributeNameState)if (isTokenizerWhitespace(character)) // 如果标签名后有连续空格，那么就不停的跳过，在当前状态不停循环        ADVANCE_TO(BeforeAttributeNameState);if (character == &#x27;/&#x27;)        ADVANCE_PAST_NON_NEWLINE_TO(SelfClosingStartTagState);if (character == &#x27;&gt;&#x27;)return emitAndResumeInDataState(source);if (m_options.usePreHTML5ParserQuirks &amp;&amp; character == &#x27;&lt;&#x27;)return emitAndReconsumeInDataState();if (character == kEndOfFileMarker) &#123;        parseError();        RECONSUME_IN(DataState);    &#125;if (character == &#x27;&quot;&#x27; || character == &#x27;\&#x27;&#x27; || character == &#x27;&lt;&#x27; || character == &#x27;=&#x27;)        parseError();    m_token.beginAttribute(source.numberOfCharactersConsumed()); // Token的属性列表增加一个，用来存放新的属性名与属性值    m_token.appendToAttributeName(toASCIILower(character)); // 添加属性名    ADVANCE_PAST_NON_NEWLINE_TO(AttributeNameState); // 跳转到AttributeNameState，并且移动到下一个字符END_STATE()BEGIN_STATE(AttributeNameState)if (isTokenizerWhitespace(character))        ADVANCE_TO(AfterAttributeNameState);if (character == &#x27;/&#x27;)        ADVANCE_PAST_NON_NEWLINE_TO(SelfClosingStartTagState);if (character == &#x27;=&#x27;)        ADVANCE_PAST_NON_NEWLINE_TO(BeforeAttributeValueState); // 在解析属性名的过程中如果碰到=，说明属性名结束，属性值就要开始if (character == &#x27;&gt;&#x27;)return emitAndResumeInDataState(source);if (m_options.usePreHTML5ParserQuirks &amp;&amp; character == &#x27;&lt;&#x27;)return emitAndReconsumeInDataState();if (character == kEndOfFileMarker) &#123;        parseError();        RECONSUME_IN(DataState);    &#125;if (character == &#x27;&quot;&#x27; || character == &#x27;\&#x27;&#x27; || character == &#x27;&lt;&#x27; || character == &#x27;=&#x27;)        parseError();    m_token.appendToAttributeName(toASCIILower(character));    ADVANCE_PAST_NON_NEWLINE_TO(AttributeNameState);END_STATE()BEGIN_STATE(BeforeAttributeValueState)if (isTokenizerWhitespace(character))        ADVANCE_TO(BeforeAttributeValueState);if (character == &#x27;&quot;&#x27;)        ADVANCE_PAST_NON_NEWLINE_TO(AttributeValueDoubleQuotedState); // 有的属性值有引号包围，这里跳转到AttributeValueDoubleQuotedState，并移动到下一个字符if (character == &#x27;&amp;&#x27;)        RECONSUME_IN(AttributeValueUnquotedState);if (character == &#x27;\&#x27;&#x27;)        ADVANCE_PAST_NON_NEWLINE_TO(AttributeValueSingleQuotedState);if (character == &#x27;&gt;&#x27;) &#123;        parseError();return emitAndResumeInDataState(source);    &#125;if (character == kEndOfFileMarker) &#123;        parseError();        RECONSUME_IN(DataState);    &#125;if (character == &#x27;&lt;&#x27; || character == &#x27;=&#x27; || character == &#x27;`&#x27;)        parseError();    m_token.appendToAttributeValue(character); // 有的属性值没有引号包围，添加属性值字符到Token    ADVANCE_PAST_NON_NEWLINE_TO(AttributeValueUnquotedState); // 跳转到AttributeValueUnquotedState，并移动到下一个字符END_STATE()BEGIN_STATE(AttributeValueDoubleQuotedState)if (character == &#x27;&quot;&#x27;) &#123; // 在当前状态下如果遇到引号，说明属性值结束        m_token.endAttribute(source.numberOfCharactersConsumed()); // 结束属性解析        ADVANCE_PAST_NON_NEWLINE_TO(AfterAttributeValueQuotedState); // 跳转到AfterAttributeValueQuotedState，并移动到下一个字符    &#125;if (character == &#x27;&amp;&#x27;) &#123;        m_additionalAllowedCharacter = &#x27;&quot;&#x27;;        ADVANCE_PAST_NON_NEWLINE_TO(CharacterReferenceInAttributeValueState);    &#125;if (character == kEndOfFileMarker) &#123;        parseError();        m_token.endAttribute(source.numberOfCharactersConsumed());        RECONSUME_IN(DataState);    &#125;    m_token.appendToAttributeValue(character); // 将属性值字符添加到Token    ADVANCE_TO(AttributeValueDoubleQuotedState); // 跳转到当前状态END_STATE()BEGIN_STATE(AfterAttributeValueQuotedState)if (isTokenizerWhitespace(character))        ADVANCE_TO(BeforeAttributeNameState); // 属性值解析完毕，如果后面继续跟着空白字符，说明后续还有属性要解析，调回到BeforeAttributeNameStateif (character == &#x27;/&#x27;)        ADVANCE_PAST_NON_NEWLINE_TO(SelfClosingStartTagState);if (character == &#x27;&gt;&#x27;)return emitAndResumeInDataState(source); // 属性值解析完毕，如果遇到&#x27;&gt;&#x27;字符，说明整个标签也要解析完毕了，此时结束当前标签解析，并且重置分词状态为DataState，并移动到下一个字符if (m_options.usePreHTML5ParserQuirks &amp;&amp; character == &#x27;&lt;&#x27;)return emitAndReconsumeInDataState();if (character == kEndOfFileMarker) &#123;        parseError();        RECONSUME_IN(DataState);    &#125;    parseError();    RECONSUME_IN(BeforeAttributeNameState);END_STATE()BEGIN_STATE(AttributeValueUnquotedState)if (isTokenizerWhitespace(character)) &#123; // 当解析不带引号的属性值时遇到空白字符(这与带引号的属性值不一样，带引号的属性值可以包含空白字符)，说明当前属性解析完毕，后面还有其他属性，跳转到BeforeAttributeNameState，并且移动到下一个字符        m_token.endAttribute(source.numberOfCharactersConsumed());        ADVANCE_TO(BeforeAttributeNameState);    &#125;if (character == &#x27;&amp;&#x27;) &#123;        m_additionalAllowedCharacter = &#x27;&gt;&#x27;;        ADVANCE_PAST_NON_NEWLINE_TO(CharacterReferenceInAttributeValueState);    &#125;if (character == &#x27;&gt;&#x27;) &#123; // 解析过程中如果遇到&#x27;&gt;&#x27;字符，说明整个标签也要解析完毕了，此时结束当前标签解析，并且重置分词状态为DataState，并移动到下一个字符        m_token.endAttribute(source.numberOfCharactersConsumed());return emitAndResumeInDataState(source);    &#125;if (character == kEndOfFileMarker) &#123;        parseError();        m_token.endAttribute(source.numberOfCharactersConsumed());        RECONSUME_IN(DataState);    &#125;if (character == &#x27;&quot;&#x27; || character == &#x27;\&#x27;&#x27; || character == &#x27;&lt;&#x27; || character == &#x27;=&#x27; || character == &#x27;`&#x27;)        parseError();    m_token.appendToAttributeValue(character); // 将遇到的属性值字符添加到Token    ADVANCE_PAST_NON_NEWLINE_TO(AttributeValueUnquotedState); // 跳转到当前状态，并且移动到下一个字符END_STATE()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从代码中可以看到，当属性值带引号和不带引号时，解析的逻辑是不一样的。当属性值带有引号时，属性值里面是可以包含空白字符的。如果属性值不带引号，那么一旦碰到空白字符，说明这个属性就解析结束了，会进入下一个属性的解析当中。</p><p>Case4：纯文本解析<br>这里的纯文本指起始标签与结束标签之间的任何纯文字，包括脚本文、CSS 文本等等，如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  &lt;!-- div标签中的纯文本 Hello,Word! --&gt;</span><br><span class="line">&lt;div class=news align=center&gt;Hello,World!&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- script标签中的纯文本 window.name = <span class="string">&#x27;Lucy&#x27;</span>; --&gt;</span><br><span class="line">&lt;script&gt;window.name = <span class="string">&#x27;Lucy&#x27;</span>;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>纯文本的解析过程比较简单，就是不停的在 DataState 状态上跳转，缓存遇到的字符，直到遇见一个结束标签的 ‘&lt;’ 字符，相关代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  BEGIN_STATE(DataState)</span><br><span class="line"><span class="keyword">if</span> (character == <span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">        ADVANCE_PAST_NON_NEWLINE_TO(CharacterReferenceInDataState);</span><br><span class="line"><span class="keyword">if</span> (character == <span class="string">&#x27;&lt;&#x27;</span>) &#123; <span class="comment">// 如果在解析文本的过程中遇到开标签，分两种情况</span></span><br><span class="line"><span class="keyword">if</span> (haveBufferedCharacterToken()) <span class="comment">// 第一种，如果缓存了文本字符就直接按当前DataState返回，并不移动字符，所以下次再进入分词操作时取到的字符仍为&#x27;&lt;&#x27;</span></span><br><span class="line">            RETURN_IN_CURRENT_STATE(<span class="literal">true</span>);</span><br><span class="line">        ADVANCE_PAST_NON_NEWLINE_TO(TagOpenState); <span class="comment">// 第二种，如果没有缓存任何文本字符，直接进入TagOpenState状态，进入到起始标签解析过程，并且移动下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (character == kEndOfFileMarker)</span><br><span class="line"><span class="keyword">return</span> emitEndOfFile(source);</span><br><span class="line">    bufferCharacter(character); <span class="comment">// 缓存遇到的字符</span></span><br><span class="line">    ADVANCE_TO(DataState); <span class="comment">// 循环跳转到当前DataState状态，并且移动到下一个字符</span></span><br><span class="line">END_STATE()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于流程比较简单，下面只给出解析div标签中纯文本的结果:</p><h5 id="2-3-创建节点与添加节点"><a href="#2-3-创建节点与添加节点" class="headerlink" title="2.3 创建节点与添加节点"></a>2.3 创建节点与添加节点</h5><h5 id="2-3-1-相关类图"><a href="#2-3-1-相关类图" class="headerlink" title="2.3.1 相关类图"></a>2.3.1 相关类图</h5><h5 id="2-3-2-创建、添加流程"><a href="#2-3-2-创建、添加流程" class="headerlink" title="2.3.2 创建、添加流程"></a>2.3.2 创建、添加流程</h5><p>上面的分词循环中，每分出一个 Token，就会根据 Token 创建对应的 Node，然后将 Node 添加到 DOM 树上(HTMLDocumentParser::pumpTokenizerLoop 方法在上面分词中有介绍)。</p><p>上面方法中首先看 HTMLTreeBuilder::constructTree，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 只保留关健代码</span></span><br><span class="line"><span class="keyword">void</span> HTMLTreeBuilder::constructTree(AtomHTMLToken&amp;&amp; token)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shouldProcessTokenInForeignContent(token))</span><br><span class="line">        processTokenInForeignContent(WTFMove(token));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        processToken(WTFMove(token)); <span class="comment">// HTMLToken在这里被处理</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    m_tree.executeQueuedTasks(); <span class="comment">// HTMLContructionSiteTask在这里被执行，有时候也直接在创建的过程中直接执行，然后这个方法发现队列为空就���直��返回</span></span><br><span class="line"><span class="comment">// The tree builder might have been destroyed as an indirect result of executing the queued tasks.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HTMLConstructionSite::executeQueuedTasks()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_taskQueue.isEmpty()) <span class="comment">// 队列为空，就直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy the task queue into a local variable in case executeTask</span></span><br><span class="line"><span class="comment">// re-enters the parser.</span></span><br><span class="line">    <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> WTFMove(m_taskQueue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (auto&amp; task : queue) <span class="comment">// 这里的task就是HTMLContructionSiteTask</span></span><br><span class="line">        executeTask(task); <span class="comment">// 执行task</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We might be detached now.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中 HTMLTreeBuilder::processToken 就是处理 Token 生成对应 Node 的地方，代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> HTMLTreeBuilder::processToken(AtomHTMLToken&amp;&amp; token)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (token.type()) &#123;</span><br><span class="line"><span class="keyword">case</span> HTMLToken::Uninitialized:</span><br><span class="line">        ASSERT_NOT_REACHED();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> HTMLToken::DOCTYPE: <span class="comment">// HTML中的DOCType标签</span></span><br><span class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</span><br><span class="line">        processDoctypeToken(WTFMove(token));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> HTMLToken::StartTag: <span class="comment">// 起始HTML标签</span></span><br><span class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</span><br><span class="line">        processStartTag(WTFMove(token));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> HTMLToken::EndTag: <span class="comment">// 结束HTML标签</span></span><br><span class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</span><br><span class="line">        processEndTag(WTFMove(token));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> HTMLToken::Comment: <span class="comment">// HTML中的注释</span></span><br><span class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</span><br><span class="line">        processComment(WTFMove(token));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> HTMLToken::Character: <span class="comment">// HTML中的纯文本</span></span><br><span class="line">        processCharacter(WTFMove(token));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> HTMLToken::EndOfFile: <span class="comment">// HTML结束标志</span></span><br><span class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</span><br><span class="line">        processEndOfFile(WTFMove(token));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到上面代码对7类 Token 做了处理，由于处理的流程都是类似的，这里分析5 个节点case的创建添加过程，分别是 &lt;!DOCTYPE&gt; 标签，</p><html>起始标签，<title>起始标签，<title>文本，<title>结束标签，剩下的过程都使用图表示。<br>Case1：!DOCTYPE 标签</title></title></title></html><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 只保留关健代码</span></span><br><span class="line"><span class="keyword">void</span> HTMLTreeBuilder::processDoctypeToken(AtomHTMLToken&amp;&amp; token)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(token.type() == HTMLToken::DOCTYPE);</span><br><span class="line"><span class="keyword">if</span> (m_insertionMode == InsertionMode::Initial) &#123; <span class="comment">// m_insertionMode的初始值就是InsertionMode::Initial</span></span><br><span class="line">        m_tree.insertDoctype(WTFMove(token)); <span class="comment">// 插入DOCTYPE标签</span></span><br><span class="line">        m_insertionMode = InsertionMode::BeforeHTML; <span class="comment">// 插入DOCTYPE标签之后，m_insertionMode设置为InsertionMode::BeforeHTML，表示下面要开是HTML标签插入</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只保留关健代码</span></span><br><span class="line"><span class="keyword">void</span> HTMLConstructionSite::insertDoctype(AtomHTMLToken&amp;&amp; token)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// m_attachmentRoot就是Document对象，文档根节点</span></span><br><span class="line"><span class="comment">// DocumentType::create方法创建出DOCTYPE节点</span></span><br><span class="line"><span class="comment">// attachLater方法内部创建出HTMLContructionSiteTask</span></span><br><span class="line">    attachLater(m_attachmentRoot, DocumentType::create(m_document, token.name(), publicId, systemId));</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只保留关健代码</span></span><br><span class="line"><span class="keyword">void</span> HTMLConstructionSite::attachLater(ContainerNode&amp; parent, Ref&lt;Node&gt;&amp;&amp; child, bool selfClosing)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    HTMLConstructionSiteTask <span class="title function_">task</span><span class="params">(HTMLConstructionSiteTask::Insert)</span>; <span class="comment">// 创建HTMLConstructionSiteTask</span></span><br><span class="line">    task.parent = &amp;parent; <span class="comment">// task持有当前节点的父节点</span></span><br><span class="line">    task.child = WTFMove(child); <span class="comment">// task持有需要操作的节点</span></span><br><span class="line">    task.selfClosing = selfClosing; <span class="comment">// 是否自关闭节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add as a sibling of the parent if we have reached the maximum depth allowed.</span></span><br><span class="line"><span class="comment">// m_openElements就是HTMLElementStack，在这里还看不到它的作用，后面会讲。这里可以看到这个stack里面加入的对象个数是有限制的，最大不超过512个。</span></span><br><span class="line"><span class="comment">// 所以如果一个HTML标签嵌套过多的子标签，就会触发这里的操作</span></span><br><span class="line"><span class="keyword">if</span> (m_openElements.stackDepth() &gt; m_maximumDOMTreeDepth &amp;&amp; task.parent-&gt;parentNode())</span><br><span class="line">        task.parent = task.parent-&gt;parentNode(); <span class="comment">// 满足条件，就会将当前节点添加到爷爷节点，而不是父节点</span></span><br><span class="line"></span><br><span class="line">    ASSERT(task.parent);</span><br><span class="line">    m_taskQueue.append(WTFMove(task)); <span class="comment">// 将task添加到Queue当中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从代码可以看到，这里只是创建了 DOCTYPE 节点，还没有真正添加。真正执行添加的操作，需要执行 HTMLContructionSite::executeQueuedTasks，这个方法在一开始有列出来。下面就来看下每个 Task 如何被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 方法位于HTMLContructionSite.cpp</span></span><br><span class="line"><span class="keyword">static</span> inline <span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">(HTMLConstructionSiteTask&amp; task)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (task.operation) &#123; <span class="comment">// HTMLConstructionSiteTask存储了自己要做的操作，构建DOM树一般都是Insert操作</span></span><br><span class="line"><span class="keyword">case</span> HTMLConstructionSiteTask::Insert:</span><br><span class="line">        executeInsertTask(task); <span class="comment">// 这里执行insert操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// All the cases below this point are only used by the adoption agency.</span></span><br><span class="line"><span class="keyword">case</span> HTMLConstructionSiteTask::InsertAlreadyParsedChild:</span><br><span class="line">        executeInsertAlreadyParsedChildTask(task);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> HTMLConstructionSiteTask::Reparent:</span><br><span class="line">        executeReparentTask(task);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> HTMLConstructionSiteTask::TakeAllChildrenAndReparent:</span><br><span class="line">        executeTakeAllChildrenAndReparentTask(task);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT_NOT_REACHED();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只保留关健代码，方法位于HTMLContructionSite.cpp</span></span><br><span class="line"><span class="keyword">static</span> inline <span class="keyword">void</span> <span class="title function_">executeInsertTask</span><span class="params">(HTMLConstructionSiteTask&amp; task)</span></span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(task.operation == HTMLConstructionSiteTask::Insert);</span><br><span class="line"></span><br><span class="line">    insert(task); <span class="comment">// 继续调用插入方法</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只保留关健代码，方法位于HTMLContructionSite.cpp</span></span><br><span class="line"><span class="keyword">static</span> inline <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(HTMLConstructionSiteTask&amp; task)</span></span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    ASSERT(!task.child-&gt;parentNode());</span><br><span class="line"><span class="keyword">if</span> (task.nextChild)</span><br><span class="line">        task.parent-&gt;parserInsertBefore(*task.child, *task.nextChild);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        task.parent-&gt;parserAppendChild(*task.child); <span class="comment">// 调用父节点方法继续插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只保留关健代码</span></span><br><span class="line"><span class="keyword">void</span> ContainerNode::parserAppendChild(Node&amp; newChild)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    executeNodeInsertionWithScriptAssertion(*<span class="built_in">this</span>, newChild, ChildChange::Source::Parser, ReplacedAllChildren::No, [&amp;] &#123;</span><br><span class="line"><span class="keyword">if</span> (&amp;document() != &amp;newChild.document())</span><br><span class="line">            document().adoptNode(newChild);</span><br><span class="line"></span><br><span class="line">        appendChildCommon(newChild); <span class="comment">// 在Block回调中调用此方法继续插入</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终调用的是这个方法进行插入</span></span><br><span class="line"><span class="keyword">void</span> ContainerNode::appendChildCommon(Node&amp; child)</span><br><span class="line">&#123;</span><br><span class="line">    ScriptDisallowedScope::InMainThread scriptDisallowedScope;</span><br><span class="line"></span><br><span class="line">    child.setParentNode(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_lastChild) &#123; <span class="comment">// 父节点已经插入子节点，运行在这里</span></span><br><span class="line">        child.setPreviousSibling(m_lastChild);</span><br><span class="line">        m_lastChild-&gt;setNextSibling(&amp;child);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        m_firstChild = &amp;child; <span class="comment">// 如果父节点是首次插入子节点，运行在这里</span></span><br><span class="line"></span><br><span class="line">    m_lastChild = &amp;child; <span class="comment">// 更新m_lastChild</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过执行上面方法之后，原来只有一个根节点的 DOM 树变成了下面的样子:</p><p>Case2：html 起始标签</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// processStartTag内部有很多状态处理，这里只保留关健代码</span></span><br><span class="line"><span class="keyword">void</span> HTMLTreeBuilder::processStartTag(AtomHTMLToken&amp;&amp; token)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(token.type() == HTMLToken::StartTag);</span><br><span class="line"><span class="keyword">switch</span> (m_insertionMode) &#123;</span><br><span class="line"><span class="keyword">case</span> InsertionMode::Initial:</span><br><span class="line">        defaultForInitial();</span><br><span class="line">        ASSERT(m_insertionMode == InsertionMode::BeforeHTML);</span><br><span class="line">        FALLTHROUGH;</span><br><span class="line"><span class="keyword">case</span> InsertionMode::BeforeHTML:</span><br><span class="line"><span class="keyword">if</span> (token.name() == htmlTag) &#123; <span class="comment">// html标签在这里处理</span></span><br><span class="line">            m_tree.insertHTMLHtmlStartTagBeforeHTML(WTFMove(token));</span><br><span class="line">            m_insertionMode = InsertionMode::BeforeHead; <span class="comment">// 插入完html标签，m_insertionMode = InsertionMode::BeforeHead，表明即将处理head标签</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只保留关健代码</span></span><br><span class="line"><span class="keyword">void</span> HTMLConstructionSite::insertHTMLHtmlStartTagBeforeHTML(AtomHTMLToken&amp;&amp; token)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">auto</span> <span class="variable">element</span> <span class="operator">=</span> HTMLHtmlElement::create(m_document); <span class="comment">// 创建html节点</span></span><br><span class="line">    setAttributes(element, token, m_parserContentPolicy);</span><br><span class="line">    attachLater(m_attachmentRoot, element.copyRef()); <span class="comment">// 同样调用了attachLater方法，与DOCTYPE类似</span></span><br><span class="line">    m_openElements.pushHTMLHtmlElement(HTMLStackItem::create(element.copyRef(), WTFMove(token))); <span class="comment">// 注意这里，这里向HTMLElementStack中压入了正在插入的html起始标签</span></span><br><span class="line"></span><br><span class="line">    executeQueuedTasks(); <span class="comment">// 这里在插入操作直接执行了task，外面HTMLTreeBuilder::constructTree方法调用的executeQueuedTasks方法就会直接返回</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行上面代码之后，DOM 树变成了如下图所示:</p><p>Case3：title 起始标签<br>当插入</p><title>起始标签之后，DOM 树以及 HTMLElementStack m_openElements 如下图所示:</title><p></p><p>Case4：title 标签文本</p><p></p><title>标签的文本作为文本节点插入，生成文本节点的代码如下:</title><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只保留关健代码 void HTMLConstructionSite::insertTextNode(const String&amp; characters, WhitespaceMode whitespaceMode) &#123; HTMLConstructionSiteTask task(HTMLConstructionSiteTask::Insert); task.parent = &amp;currentNode(); // 直接取HTMLElementStack m_openElements的栈顶节点，此时节点是title</span></span><br></pre></td></tr></table></figure><p>unsigned currentPosition = 0; unsigned lengthLimit = shouldUseLengthLimit(*task.parent) ? Text::defaultLengthLimit : std::numeric_limits<unsigned>::max(); // 限制文本节点最大包含的字符个数为65536<br>// 可以看到如果文本过长，会将分割成多个文本节点 while (currentPosition &lt; characters.length()) { AtomString charactersAtom = m_whitespaceCache.lookup(characters, whitespaceMode); auto textNode = Text::createWithLengthLimit(task.parent-&gt;document(), charactersAtom.isNull() ? characters : charactersAtom.string(), currentPosition, lengthLimit); // If we have a whole string of unbreakable characters the above could lead to an infinite loop. Exceeding the length limit is the lesser evil. if (!textNode-&gt;length()) { String substring = characters.substring(currentPosition); AtomString substringAtom = m_whitespaceCache.lookup(substring, whitespaceMode); textNode = Text::create(task.parent-&gt;document(), substringAtom.isNull() ? substring : substringAtom.string()); // 生成文本节点 }</unsigned></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      currentPosition += textNode-&gt;length(); <span class="comment">// 下一个文本节点包含的字符起点</span></span><br><span class="line">    ASSERT(currentPosition &lt;= characters.length());</span><br><span class="line">    task.child = WTFMove(textNode);</span><br><span class="line"></span><br><span class="line">    executeTask(task); <span class="comment">// 直接执行Task插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">从代码可以看到，如果一个节点后面跟的文本字符过多，会被分割成多个文本节点插入。下面的例子将 &lt;title&gt; 节点后面的文本字符个数设置成<span class="number">85248</span>，使用 Safari 查看确实生成了<span class="number">2</span>个文本节点:</span><br><span class="line"></span><br><span class="line">![图片](https:<span class="comment">//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/584362db5ed04e2fb9d761f8d6f2d83c~tplv-k3u1fbpfcp-zoom-1.image)</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">**Case5：结束标签**</span><br><span class="line"></span><br><span class="line">当遇到 &lt;title&gt; 结束标签，代码处理如下:</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 代码内部有很多状态处理，这里只保留关健代码 void HTMLTreeBuilder::processEndTag(AtomHTMLToken&amp;&amp; token) { ASSERT(token.type() == HTMLToken::EndTag); switch (m_insertionMode) { …<br>case InsertionMode::Text: // 由于遇到title结束标签之前插入了文本，因此此时的插入模式就是InsertionMode::Text</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  m_tree.openElements().pop(); <span class="comment">// 因为遇到了title结束标签，整个标签已经处理完毕，从HTMLElementStack栈中弹出栈顶元素title</span></span><br><span class="line">m_insertionMode = m_originalInsertionMode; <span class="comment">// 恢复之前的插入模式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>break;<br>}<br>每当遇到一个标签的结束标签，都会像上面一样将 HTMLElementStack m_openElementsStack 的栈顶元素弹出。执行上面代码之后，DOM 树与 HTMLElementStack 如下图所示:</p><h3 id="三、内存中的DOM树"><a href="#三、内存中的DOM树" class="headerlink" title="三、内存中的DOM树"></a>三、内存中的DOM树</h3><p>当整个 DOM 树构建完成之后，DOM 树和 HTMLElementStack m_openElements 如下图所示:</p><p>从上图可以看到，当构建完 DOM，HTMLElementStack m_openElements 并没有将栈完全清空，而是保留了2个节点: html 节点与 body 节点。这可以从 Xcode 的控制台输出看到:</p><p>同时可以看到，内存中的 DOM 树结构和文章开头画的逻辑上的 DOM 树结构是不一样的。逻辑上的 DOM 树父节点有多少子节点，就有多少指向子节点的指针，而内存中�� DOM 树，不管父节点有多少子节点，始终只有2个指针指向子节点: m_firstChild 与 m_lastChild。同时，内存中的 DOM 树兄弟节点之间也相互有指针引用，而逻辑上的 DOM 树结构是没有的。<br>举个例子，如果一棵 DOM 树只有1个父节点，100个子节点，那么使用逻辑上的 DOM 树结构，父节点就需要100个指向子节点的指针。如果一个指针占8字节，那么总共占用800字节。使用上面内存中 DOM 树的表示方式，父节点需要2个指向子节点的指针，同时兄弟节点之间需要198个指针，一共200个指针，总共占用1600字节。相比逻辑上的 DOM 树结构，内存上并不占优势，但是内存中的 DOM 树结构，无论父节点有多少子节点，只需要2个指针就可以了，不需要添加子节点时，频繁动态申请内存，创建新的指向子节点的指针。<br>———- END ———-<br>百度 Geek 说<br>百度官方技术公众号上线啦！<br>技术干货 · 行业资讯 · 线上沙龙 · 行业大会<br>招聘信息 · 内推信息 · 技术书籍 · 百度周边</p><div class="post-copyright"><div class="content"><p>本文标题： 推荐系列-深入理解 WKWebView (渲染篇) —— DOM 树的构建</p><p>本文作者： OSChina</p><p>发布时间： 2022年03月27日 11:55</p><p>最后更新： 2022年03月27日 11:57</p><p>原始链接： <a class="post-url" href="/cac71e97/" title="推荐系列-深入理解 WKWebView (渲染篇) —— DOM 树的构建">https://www.hosiang.cn/cac71e97/</a></p><p>版权声明： 本文著作权归作者所有，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a>许可协议，转载请注明出处！</p><footer><a href="https://www.hosiang.cn"><img src="/../images/logo.png" alt="Howe Hsiang"> Howe Hsiang</a></footer></div></div><div class="page-reward"><a id="rewardBtn" href="javascript:;">赏</a></div><div id="reward" class="post-modal reward-lay"><a class="close" href="javascript:;" id="reward-close">×</a> <span class="reward-title"><i class="icon icon-quote-left"></i> 喜欢就赞赏一下呗！ <i class="icon icon-quote-right"></i></span><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="/images/threepay_code.jpg" alt="打赏二维码"></div><div class="reward-select"></div></div></div></div><footer class="article-footer"><div class="post-share"><a href="javascript:" id="share-sub" class="post-share-fab"><i class="fa fa-share-alt" style="padding-top:11px!important"></i></a><div class="post-share-list" id="share-list"><ul class="share-icons"><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.hosiang.cn/cac71e97/" data-title="Facebook" rel="external nofollow noopener noreferrer"><i class="fa fa-facebook" style="padding-top:9px!important"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《推荐系列-深入理解 WKWebView (渲染篇) —— DOM 树的构建》 — 狂欢马克思&url=https://www.hosiang.cn/cac71e97/&via=https://www.hosiang.cn" data-title="Twitter" rel="external nofollow noopener noreferrer"><i class="fa fa-twitter" style="padding-top:9px!important"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.hosiang.cn/cac71e97/" data-title="Google+" rel="external nofollow noopener noreferrer"><i class="fa fa-google-plus" style="padding-top:9px!important"></i></a></li><li><a class="qq share-sns" target="_blank" href="https://connect.qq.com/widget/shareqq/index.html?url=https://www.hosiang.cn/cac71e97/&title=《推荐系列-深入理解 WKWebView (渲染篇) —— DOM 树的构建》 — 狂欢马克思&source=&emsp;&emsp;12003字，预计阅读时间24分钟 当客户端 App 主进程创建 WKWebView 对象时，会创建另外两个子进程:渲染进程与网络..." data-title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-qq" style="padding-top:9px!important"></i></a></li><li><a class="weixin share-sns" id="wxFab" href="javascript:" data-title="微信"><i class="fa fa-weixin" style="padding-top:9px!important"></i></a></li><li><a class="weibo share-sns" target="_blank" href="https://service.weibo.com/share/share.php?url=https://www.hosiang.cn/cac71e97/&title=《推荐系列-深入理解 WKWebView (渲染篇) —— DOM 树的构建》 — 狂欢马克思&pic=https://api.ixiaowai.cn/gqapi/gqapi.php" data-title="微博" rel="external nofollow noopener noreferrer"><i class="fa fa-weibo" style="padding-top:9px!important"></i></a></li></ul></div></div><div class="post-modal wx-share" id="wxShare"><a class="close" href="javascript:" id="wxShare-close">×</a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://www.hosiang.cn/cac71e97/" alt="微信分享二维码"></div><div class="mask"></div><ul class="article-footer-menu"><li class="article-footer-tags"><i class="fa fa-tags"></i> <a href="/tags/Popular/" class="color3">Popular</a></li></ul></footer></div></article><aside class="post-toc-pos post-toc-top" id="post-toc"><nav class="post-toc-wrap"><ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFDOM%E6%A0%91"><span class="post-toc-text">一、什么是DOM树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E3%80%81DOM%E6%A0%91%E6%9E%84%E5%BB%BA"><span class="post-toc-text">二、DOM树构建</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-%E8%A7%A3%E7%A0%81"><span class="post-toc-text">2.1 解码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-1-%E8%A7%A3%E7%A0%81%E7%B1%BB%E5%9B%BE"><span class="post-toc-text">2.1.1 解码类图</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-2-%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="post-toc-text">2.1.2 解码流程</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-3-%E8%A7%A3%E7%A0%81%E6%80%BB%E7%BB%93"><span class="post-toc-text">2.1.3 解码总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-%E5%88%86%E8%AF%8D"><span class="post-toc-text">2.2 分词</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-2-1-%E5%88%86%E8%AF%8D%E7%B1%BB%E5%9B%BE"><span class="post-toc-text">2.2.1 分词类图</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-2-2-%E5%88%86%E8%AF%8D%E6%B5%81%E7%A8%8B"><span class="post-toc-text">2.2.2 分词流程</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-3-%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E4%B8%8E%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="post-toc-text">2.3 创建节点与添加节点</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-3-1-%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9B%BE"><span class="post-toc-text">2.3.1 相关类图</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-3-2-%E5%88%9B%E5%BB%BA%E3%80%81%E6%B7%BB%E5%8A%A0%E6%B5%81%E7%A8%8B"><span class="post-toc-text">2.3.2 创建、添加流程</span></a></li></ol></li></ol></li></ol></nav></aside><nav id="article-nav"><a href="/b34be646/" id="article-nav-newer" class="article-nav-link-wrap"><span class="article-nav-title"><i class="fa fa-hand-o-left" aria-hidden="true"></i> 推荐系列-轻松上手使用gs_dump和gs_dumpall命令导出数据 </span></a><a href="/f83cb87b/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">推荐系列-Apache SeaTunnel (Incubating) 2.1.0 发布，内核重构-全面支持 Flink</span> <i class="fa fa-hand-o-right" aria-hidden="true"></i></a></nav><div id="gitalk"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({repo:"bolg-comment",owner:"Hosiang1026",admin:"Hosiang1026",clientID:"37a2dd4473e8970cecc2",clientSecret:"e30efa17d86d9de4f4ab810872dc62a7b2e7e634",pagerDirection:"last",distractionFreeMode:!0,createIssueManually:!1});gitalk.render("gitalk")</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"><script id="_wau78w">var _wau=_wau||[];_wau.push(["small","5dnguv4c2n","78w"])</script><script async src="//waust.at/s.js"></script><p><span id="busuanzi_container_site_uv" style="display:none"><span class="post-count">总字数：<span>1546.7k</span> </span>总访客数：<span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" style="display:none">总访问量：<span id="busuanzi_value_site_pv"></span></span><br><span id="TimeShow">本站</span><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br>Copyright&copy; 2018 - 2022 狂欢马克思 <a href="https://beian.miit.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">京ICP备17060439号</a></p></div></div><script>var now=new Date;function createtime(){var n=new Date("2017/09/18");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",800)</script></footer><script>var mihoConfig={root:"https://www.hosiang.cn",animate:"true",isHome:"false",share:"true",reward:" 1"}</script><div class="sidebar"><div id="sidebar-search" title="Search"><i class="fa fa-search"></i></div><div id="sidebar-category" title="Categories"><i class="fa fa-book"></i></div><div id="sidebar-tag" title="Tags"><i class="fa fa-tags"></i></div><div id="sidebar-top"><span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span></div></div><div class="sidebar-menu-box" id="sidebar-menu-box"><div class="sidebar-menu-box-container"><div id="sidebar-menu-box-categories"><a class="category-link" href="/categories/%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD/">兴趣爱好</a><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/">其他开发</a><a class="category-link" href="/categories/%E5%89%8D%E6%B2%BF%E5%BC%80%E5%8F%91/">前沿开发</a><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a><a class="category-link" href="/categories/%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/">升级版本</a><a class="category-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">博客教程</a><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="category-link" href="/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</a><a class="category-link" href="/categories/%E7%83%AD%E9%97%A8%E6%96%87%E7%AB%A0/">热门文章</a></div><div id="sidebar-menu-box-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:16px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:14px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:14px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Interview/" style="font-size:18px">Interview</a> <a href="/tags/Java/" style="font-size:12px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:16px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:16px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div><a href="javascript:" class="sidebar-menu-box-close">&times;</a></div><div class="mobile-header-menu-nav" id="mobile-header-menu-nav"><div class="mobile-header-menu-container"><span class="title">导航</span><ul class="mobile-header-menu-navbar"><li><a href="/"><i class="fa fa-home"></i><span>主页</span></a></li><li><a href="/archives"><i class="fa fa-archive"></i><span>归档</span></a></li><li><a href="/gitbook"><i class="fa fa-columns"></i><span>笔记</span></a></li><li><a href="/photo"><i class="fa fa-picture-o"></i><span>相册</span></a></li><li><a href="/love"><i class="fa fa-heart"></i><span>恋爱</span></a></li><li><a href="/collection"><i class="fa fa-envira"></i><span>收藏</span></a></li><li><a href="/about"><i class="fa fa-user"></i><span>关于</span></a></li></ul></div><div class="mobile-header-tag-container"><span class="title">标签</span><div id="mobile-header-container-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:16px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:14px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:14px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Interview/" style="font-size:18px">Interview</a> <a href="/tags/Java/" style="font-size:12px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:16px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:16px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div></div><div class="search-wrap"><span class="search-close">&times;</span> <a href="javascript:" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input class="search-field" placeholder="Search..." id="keywords"> <a id="search-submit" href="javascript:"><i class="fa fa-search"></i></a><div class="search-container" id="search-container"><ul class="search-result" id="search-result"></ul></div></div><div id="search-tpl"><li class="search-result-item"><a href="{url}" class="search-item-li"><span class="search-item-li-title" title="{title}">{title}</span></a></li></div><script src="/js/search.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script><div id="particles"></div><script src="/js/particles.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css"><script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script><script src="/js/animate.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0,scale:.5},log:!1})</script></body></html>