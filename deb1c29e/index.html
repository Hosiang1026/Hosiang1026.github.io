<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Access-Control-Allow-Origin" content="*"><script type="text/javascript">var start_time=(new Date).getTime()</script><meta http-equiv="Cache-Control" content="no-cache"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="google-site-verification" content="9Wt3lmnrT2bfjaHla5s16adhvcQcBHO7PtNf97n5Od0"><meta name="baidu-site-verification" content="RYlYHsgO7Y"><meta name="sogou_site_verification" content="MSmrTj7lHV"><meta name="shenma-site-verification" content="e4428ccce0f22fad61c3716193bf4bd7_1571416388"><meta name="baidu_union_verify" content="584bb6b4bd24108df082b6d20c7aa9be"><title>推荐系列-DolphinDB内存管理详解 | 狂欢马克思</title><meta name="keywords" content="分享技术经验与交流"><meta name="description" content="&amp;emsp;&amp;emsp;DolphinDB是一款支持多用户多任务并发操作的高性能分布式时序数据库软件(distributed time-series database)。针对大数据的高效的内存管理是其性能优异的原因之一。本教程涉及的内存管理包括…"><meta property="og:type" content="article"><meta property="og:title" content="推荐系列-DolphinDB内存管理详解"><meta property="og:url" content="https://www.hosiang.cn/deb1c29e/index.html"><meta property="og:site_name" content="狂欢马克思"><meta property="og:description" content="&amp;emsp;&amp;emsp;DolphinDB是一款支持多用户多任务并发操作的高性能分布式时序数据库软件(distributed time-series database)。针对大数据的高效的内存管理是其性能优异的原因之一。本教程涉及的内存管理包括…"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic2.zhimg.com/80/v2-1c40f4e2f1e0967033dfff9b207fecb5_720w.jpg"><meta property="og:image" content="https://pic2.zhimg.com/80/v2-1c40f4e2f1e0967033dfff9b207fecb5_720w.jpg"><meta property="og:image" content="https://pic2.zhimg.com/80/v2-1c40f4e2f1e0967033dfff9b207fecb5_720w.jpg"><meta property="og:image" content="https://pic2.zhimg.com/80/v2-1c40f4e2f1e0967033dfff9b207fecb5_720w.jpg"><meta property="article:published_time" content="2021-04-15T02:08:52.000Z"><meta property="article:modified_time" content="2022-05-11T09:29:46.232Z"><meta property="article:author" content="Howe Hsiang"><meta property="article:tag" content="Popular"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic2.zhimg.com/80/v2-1c40f4e2f1e0967033dfff9b207fecb5_720w.jpg"><link rel="icon" href="/images/favicon.ico"><link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.bootcss.com/font-awesome-animation/0.1.0/font-awesome-animation.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3cd8fa109426bf3f10bd5c362175bace";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.2.0"></head><script src="/js/jquery.min.js"></script><script src="/js/pace.min.js"></script><script src="/js/crypto-js.js"></script><script src="/js/cookie.js"></script><script src="/js/calendar.js"></script><script src="/js/festival.js"></script><script>getFestival()</script><body><script>window.onload=function(){document.getElementById("TimeShow").innerHTML="本站耗时 "+((new Date).getTime()-start_time)/1e3+" 秒 "}</script><div id="container"><header id="header"><div id="banner"></div><div id="header-outer"><div id="header-menu" class="header-menu-pos animated"><div class="header-menu-container"><a href="/" class="left"><span class="site-title">狂欢马克思</span></a><nav id="header-menu-nav" class="right"><a href="/" rel="external nofollow"><i class="fa fa-home"></i> <span>主页</span> </a><a href="/archives" rel="external nofollow"><i class="fa fa-archive"></i> <span>归档</span> </a><a href="/gitbook" rel="external nofollow"><i class="fa fa-columns"></i> <span>笔记</span> </a><a href="/music" rel="external nofollow"><i class="fa fa-music"></i> <span>音乐</span> </a><a href="/photo" rel="external nofollow"><i class="fa fa-picture-o"></i> <span>相册</span> </a><a href="/collection" rel="external nofollow"><i class="fa fa-envira"></i> <span>收藏</span> </a><a href="/about" rel="external nofollow"><i class="fa fa-user"></i> <span>关于</span></a></nav><a class="mobile-header-menu-button"><i class="fa fa-bars"></i></a></div></div><div id="header-row"><div id="logo"><a href="/"><img src="/../images/logo.png" alt="logo"></a></div><div class="header-info"><div id="header-title"><h2>狂欢马克思</h2></div><div id="header-description"><h3>专注Web开发</h3></div></div><nav class="header-nav"><div class="social"><a title="Github" target="_blank" href="//github.com/Hosiang1026" rel="external nofollow"><i class="fa fa-github fa-2x"></i></a> <a title="QQ" target="_blank" href="//wpa.qq.com/msgrd?v=3&uin=641904695&site=qq&menu=yes" rel="external nofollow"><i class="fa fa-qq fa-2x"></i></a> <a title="Weibo" target="_blank" href="//www.weibo.com/haoxiang969" rel="external nofollow"><i class="fa fa-weibo fa-2x"></i></a></div></nav></div><div id="noticeId" class="show" style="background:rgb(244,247,247,.3)"><marquee id="noticeMar" behavior="scoll" class="notice" direction="left" onmouseover="this.stop()" onmouseout="this.start()"></marquee></div><script type="text/javascript">function browserRedirect(){var i=navigator.userAgent.toLowerCase(),n="ipad"==i.match(/ipad/i),o="iphone os"==i.match(/iphone os/i),a="midp"==i.match(/midp/i),t="rv:1.2.3.4"==i.match(/rv:1.2.3.4/i),e="ucweb"==i.match(/ucweb/i),s="android"==i.match(/android/i),d="windows ce"==i.match(/windows ce/i),p="windows mobile"==i.match(/windows mobile/i),r="",c=randomColor(),r=n||o||a||t||e||s||d||p?($("#noticeId").css({"line-height":"1.6em"}),"<font style='color:"+c+"' face='新华宋体'  size='2'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='hitokoto'></span></span></span><span id='YQData'></font> "):($("#noticeId").css({"line-height":"3.6em","margin-top":"20px"}),"<font style='color:"+c+"' face='新华宋体'  size='6'>官宣：<span id='weekend'></span><span id='msg'></span><span id='timer'></span><span id='hitokoto'></span></span><span id='YQData'></span></font> ");$("#noticeMar").html(r)}function randomColor(){for(var i="0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f".split(","),n="#",o=0;o<6;o++)n+=i[Math.floor(16*Math.random())];return n}$(function(){browserRedirect(),0<$("#hitokoto").length&&getHitokoto()})</script></div></header><script>console.log=function(){}</script><div class="outer"><section id="main" class="body-wrap"><article id="post-DolphinDB内存管理详解" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="post-title" itemprop="name">推荐系列-DolphinDB内存管理详解</h1><div class="post-title-bar"><ul><li><i class="fa fa-book"></i> <a href="/categories/热门文章/">热门文章</a></li><li><i class="fa fa-calendar"></i> 2021-04-15</li><li><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span></li><li><span class="post-count">字数统计: 4.9k字</span></li><li><span class="post-count">阅读时长: 18分钟</span></li></ul></div></header><div class="article-entry post-content" itemprop="articleBody"><p>&amp;emsp;&amp;emsp;DolphinDB是一款支持多用户多任务并发操作的高性能分布式时序数据库软件(distributed time-series database)。针对大数据的高效的内存管理是其性能优异的原因之一。本教程涉及的内存管理包括…</p><span id="more"></span><pre><code>                                                                                                                                                                                    DolphinDB是一款支持多用户多任务并发操作的高性能分布式时序数据库软件(distributed time-series database)。针对大数据的高效的内存管理是其性能优异的原因之一。本教程涉及的内存管理包括以下方面： 
</code></pre><p>变量的内存管理：为用户提供与回收编程环境所需内存。<br>分布式表的缓存管理：多个session共享分区表数据，以提高内存使用率。<br>流数据缓存：流数据发送节点提供持久化和发送队列缓存，订阅节点提供接收数据队列缓存。<br>DFS数据库写入缓存：写入DFS的数据先写到WAL和缓存，通过批量写入提升吞吐量。</p><h4 id="1-内存管理�����"><a href="#1-内存管理�����" class="headerlink" title="1. 内存管理�����"></a>1. 内存管理�����</h4><p>DolphinDB向操作系统申请内存块，自行进行管理。当申请的内存块闲置时，系统会定期检查并释放。目前vector和table以及所有字符串的内存分配都已经纳入DolphinDB的内存管理系统。<br>通过参数maxMemSize设定节点的最大内存使用量：该参数制定节点的最大可使用内存。如果设置太小，会严重限制集群的性能，如果设置太大，例如超过物理内存，可能会触发操作系统强制关闭进程。若机器内存为16GB，并且只部署1个节点，建议将该参数设置为12GB左右。<br>以512MB为单位向操作系统申请内存块：当用户查询操作或者编程换进所需要内存时，DolphinDB会以512MB为单位向操作系统申请内存。如果操作系统无法提供大块的连续内存，则会尝试256MB，128MB等更小的内存块。<br>系统充分利用可用内存缓存数据库数据：当节点的内存使用总量小于maxMemSize时，DolphinDB会尽可能多的缓存数据库分区数据，以便提升用户下次访问该数据块的速度。当内存不足时，系统自动会剔除部分缓存。<br>每隔30秒扫描一次，空闲的内存块还给操作系统：当用户使用释放内存中变量，或者使用函数clearAllCache释放缓存时，如果内存块完全空闲，则会整体还给操作系统，如果仍有小部分内存在使用，比如512MB的内存块中仍有10MB在使用，则不会归还操作系统。</p><h4 id="2-变量的内存管理"><a href="#2-变量的内存管理" class="headerlink" title="2. 变量的内存管理"></a>2. 变量的内存管理</h4><p>2.1 创建变量<br>在DolphinDB节点上，先创建一个用户user1，然后登陆。创建一个vector，含有1亿个INT类型元素，约400MB。<br>示例1. 创建vector变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   login(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>)  <span class="comment">//创建用户需要登陆admin</span></span><br><span class="line">createUser(<span class="string">&quot;user1&quot;</span>,<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">login(<span class="string">&quot;user1&quot;</span>,<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">v = <span class="number">1.</span><span class="number">.100000000</span></span><br><span class="line">sum(mem().blockSize - mem().freeSize) <span class="comment">//输出内存占用结果</span></span><br></pre></td></tr></table></figure><p>结果为: 402,865,056，内存占用400MB左右，符合预期。<br>再创建一个table，1000万行，5列，每列4字节，约200MB。<br>示例2. 创建table变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  n = <span class="number">10000000</span></span><br><span class="line">t = table(n:n,[<span class="string">&quot;tag1&quot;</span>,<span class="string">&quot;tag2&quot;</span>,<span class="string">&quot;tag3&quot;</span>,<span class="string">&quot;tag4&quot;</span>,<span class="string">&quot;tag5&quot;</span>],[INT,INT,INT,INT,INT])</span><br><span class="line">(mem().blockSize - mem().freeSize).sum()</span><br></pre></td></tr></table></figure><p>结果为：612,530,448，约600MB，符合预期。<br>2.2 释放变量<br>可通过undef函数，释放变量的内存。<br>示例3. 使用undef函数或者赋值为NULL释放变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undef(`v)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = NULL</span><br></pre></td></tr></table></figure><p>除了手动释放变量，当session关闭时，比如关闭GUI和其他API连接，都会触发对该session的所有内存进行回收。当通过web notebook连接时，10分钟内无操作，系统会关闭session，自动回收内存。</p><h4 id="3-分布式表的缓存管理"><a href="#3-分布式表的缓存管理" class="headerlink" title="3. 分布式表的缓存管理"></a>3. 分布式表的缓存管理</h4><p>DolphinDB对分布式表是以分区为单位管理的。分布式表的缓存是全局共享的，不同的session或读事务在大部分情况下，会看到同一份数据copy（版本可能会有所不同），这样极大的节省了内存的使用。<br>历史数据库都是以分布式表的形式存在数据库中，用户平时查询操作也往往直接与分布式表交互。分布式表的内存管理有如下特点：</p><p>内存以分区列为单位进行管理。<br>数据只加载到所在的节点，不会在节点间转移。<br>多个用户访问相同分区时，使用同一份缓存。<br>内存使用不超过maxMemSize情况下，尽量多缓存数据。<br>缓存数据达到maxMemSize时，系统自动回收。</p><p>以下多个示例是基于以下集群：部署于2个节点，采用单副本模式。按天分30个区，每个分区1000万行，11列（1列DATE类型，1列INT类型，9列LONG类型），所以每个分区的每列(LONG类型）数据量为1000万行 * 8字节&#x2F;列 &#x3D; 80M，每个分区共1000万行 * 80字节&#x2F;行 &#x3D; 800M，整个表共3亿行，大小为24GB。</p><p>3.1 内存以分区列为单位进行管理<br>DolphinDB采用列式存储，当用户对分布式表的数据进行查询时，加载数据的原则是，只把用户所要求的分区和列加载到内存中。<br>示例4. 计算分区2019.01.01最大的tag1的值。该分区储存在node1上，可以在controller上通过函数getClusterChunksStatus()查看分区分布情况，而且由上面可知，每列约80MB。在node1上执行如下代码，并查看内存占用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  select <span class="title function_">max</span><span class="params">(tag1)</span> from <span class="title function_">loadTable</span><span class="params">(dbName,tableName)</span> <span class="type">where</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">2019.01</span><span class="number">.01</span></span><br><span class="line">sum(mem().blockSize - mem().freeSize) </span><br></pre></td></tr></table></figure><p>输出结果为84,267,136。我们只查询1个分区的一列数据，所以把该列数据全部加载到内存，其他的列不加载。<br>示例5. 在node1 上查询 2019.01.01的前100条数据，并观察内存占用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  select top <span class="number">100</span> * from <span class="title function_">loadTable</span><span class="params">(dbName,tableName)</span> <span class="type">where</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">2019.01</span><span class="number">.01</span></span><br><span class="line">sum(mem().blockSize - mem().freeSize)</span><br></pre></td></tr></table></figure><p>输出结果为839,255,392。虽然我们只取100条数据，但是DolphinDB加载数据的最小单位是分区列，所以需要加载每个列的全部数据，也就是整个分区的全部数据，约800MB。</p><p>3.2 数据只加载到所在的节点<br>在数据量大的情况下，节点间转移数据是非常耗时的操作。DolphinDB的数据是分布式存储的，当执行计算任务时，把任务发送到数据所在的节点，而不是把数据转移到计算所在的节点，这样大大降低数据在节点间的转移，提升计算效率。<br>示例6. 在node1上计算两个分区中tag1的最大值。其中分区2019.01.02数组存储在node1上，分区2019.01.03数据存储在node2上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  select <span class="title function_">max</span><span class="params">(tag1)</span> from <span class="title function_">loadTable</span><span class="params">(dbName,tableName)</span> where day in [<span class="number">2019.01</span><span class="number">.02</span>,<span class="number">2019.01</span><span class="number">.03</span>]</span><br><span class="line">sum(mem().blockSize - mem().freeSize) </span><br></pre></td></tr></table></figure><p>输出结果为84,284,096。在node2上用查看内存占用结果为84,250,624。每个节点存储的数据都为80M左右，也就是node1上存储了分区2019.01.02的数据，node2上存储了2019.01.03的数据。<br>示例7. 在node1上查询分区2019.01.02和2019.01.03的所有数据，我们预期node1加载2019.01.02数据，node2加载2019.01.03的数据，都是800M左右，执行如下代码并观察内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  select top <span class="number">100</span> * from <span class="title function_">loadTable</span><span class="params">(dbName,tableName)</span> where day in [<span class="number">2019.01</span><span class="number">.02</span>,<span class="number">2019.01</span><span class="number">.03</span>]</span><br><span class="line">sum(mem().blockSize - mem().freeSize)</span><br></pre></td></tr></table></figure><p>node1上输出结果为839,279,968。node2上输出结果为839,246,496。结果符合预期。</p><p>3.3 多个用户访问相同分区时，使用同一份缓存<br>DolphinDB支持海量数据的并发查询。为了高效利用内存，对相同分区的数据，内存中只保留同一份副本。<br>示例8. 打开两个GUI，分别连接node1和node2，查询分区2019.01.01的数据，该分区的数据存储在node1上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  select * from <span class="title function_">loadTable</span><span class="params">(dbName,tableName)</span> <span class="type">where</span> <span class="variable">date</span> <span class="operator">=</span> <span class="number">2019.01</span><span class="number">.01</span></span><br><span class="line">sum(mem().blockSize - mem().freeSize)</span><br></pre></td></tr></table></figure><p>上面的代码不管执行几次，node1上内存显示一直是839,101,024，而node2上无内存占用。因为分区数据只存储在node1上，所以node1会加载所有数据，而node2不占用任何内存。<br>3.4 节点内存占用情况与缓存数据的关系<br>3.4.1 节点内存使用不超过maxMemSize情况下，尽量多缓存数据<br>通常情况下，最近访问的数据往往更容易再次被访问，因此DolphinDB在内存允许的情况下（内存占用不超过用户设置的maxMemSize），尽量多缓存数据，来提升后续数据的访问效率。<br>示例9. 数据节点设置的maxMemSize&#x3D;8。连续加载9个分区，每个分区约800M，总内存占用约7.2GB，观察内存的变化趋势。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  days = chunksOfEightDays();</span><br><span class="line"><span class="keyword">for</span>(d in days)&#123;</span><br><span class="line">    select * from <span class="title function_">loadTable</span><span class="params">(dbName,tableName)</span> where  = day</span><br><span class="line">    <span class="title function_">sum</span><span class="params">(mem()</span>.blockSize - mem().freeSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存随��加载分区数的增加变化规律如下图所示：<br><img src="https://pic2.zhimg.com/80/v2-1c40f4e2f1e0967033dfff9b207fecb5_720w.jpg" alt="Test" title="DolphinDB内存管理详解"><br>当遍历每个分区数据时，在内存使用量不超过maxMemSize的情况下，分区数据会全部缓存到内存中，以在用户下次访问时，直接从内存中提供数据，而不需要再次从磁盘加载。<br> <br>3.4.2 节点内存使用达到maxMemSize时，系统自动回收<br>如果DolphinDB server使用的内存，没有超过用户设置的maxMemSize，则不会回收内存。当总的内存使用达到maxMemSize时，DolphinDB 会采用LRU的内存回收策略， 来腾出足够的内存给用户。<br>示例10. 上面用例只加载了8天的数据，此时我们继续共遍历15天数据，查看缓存达到maxMemSize时，内存的占用情况。如下图所示：<br><img src="https://pic2.zhimg.com/80/v2-1c40f4e2f1e0967033dfff9b207fecb5_720w.jpg" alt="Test" title="DolphinDB内存管理详解"><br>如上图所示，当缓存的数据超过maxMemSize时，系统自动回收内存，总的内存使用量仍然小于用户设置的最大内存量8GB。<br>示例11. 当缓存数据接近用户设置的maxMemSize时，继续申请Session变量的内存空间，查看系统内存占用。此时先查看系统的内存使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(mem().blockSize - mem().freeSize)</span><br></pre></td></tr></table></figure><p>输出结果为7,550,138,448。内存占用超过7GB，而用户设置的最大内存使用量为8GB，此时我们继续申请4GB空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  v = <span class="number">1.</span><span class="number">.1000000000</span></span><br><span class="line">sum(mem().blockSize - mem().freeSize)</span><br></pre></td></tr></table></figure><p>输出结果为8,196,073,856。约为8GB，也就是如果用户定义变量，也会触发缓存数据的内存回收，以保证有足够的内存提供给用户使用。</p><h4 id="4-流数据消息缓存队列"><a href="#4-流数据消息缓存队列" class="headerlink" title="4. 流数据消息缓存队列"></a>4. 流数据消息缓存队列</h4><p>当数据进入流数据系统时，首先写入流表，然后写入持久化队列和发送队列（假设用户设置为异步持久化），持久化队列异步写入磁盘，将发送队列发送到订阅端。<br>当订阅端收到数据后，先放入接受队列，然后用户定义的handler从接收队列中取数据并处理。如果handler处理缓慢，会导致接收队列有数据堆积，占用内存。如下图所示：<br><img src="https://pic2.zhimg.com/80/v2-1c40f4e2f1e0967033dfff9b207fecb5_720w.jpg" alt="Test" title="DolphinDB内存管理详解"><br>流数据内存相关的配置选项：</p><p>maxPersistenceQueueDepth: 流表持久化队列的最大消息数。对于异步持久化的发布流表，先将数据放到持久化队列中，再异步持久化到磁盘上。该选项默认设置为1000万。在磁盘写入成为瓶颈时，队列会堆积数据。<br>maxPubQueueDepthPerSite: 最大消息发布队列深度。针对某个订阅节点，发布节点建立一个消息发布队列，该队列中的消息发送到订阅端。默认值为1000万，当网络出现拥塞时，该发送队列会堆积数据。<br>maxSubQueueDepth: 订阅节点上最大的每个订阅线程最大的可接收消息的队列深度。订阅的消息，会先放入订阅消息队列。默认设置为1000万，当handler处理速度较慢，不能及时处理订阅到的消息时，该队列会有数据堆积。<br>流表的capacity：在函数enableTablePersistence()中第四个参数指定，该值表示流表中保存在内存中的最大行数，达到该值时，从内存中删除一半数据。当流数据节点中，流表比较多时，要整体合理设置该值，防止内存不足。</p><p>运行过程，可以通过函数getStreamingStat()来查看流表的大小以及各个队列的深度。</p><h4 id="5-为写入DFS数据库提供缓存"><a href="#5-为写入DFS数据库提供缓存" class="headerlink" title="5. 为写入DFS数据库提供缓存"></a>5. 为写入DFS数据库提供缓存</h4><p>DolphinDB为了提高读写的吞吐量和降低读写的延迟，采用先写入WAL和缓存的通用做法，等累积到一定数量时，批量写入。这样减少和磁盘文件的交互次数，提升写入性能，可提升写入速度30%以上。因此，也需要一定的内存空间来临时缓存这些数据，如下图所示：<br><img src="https://pic2.zhimg.com/80/v2-1c40f4e2f1e0967033dfff9b207fecb5_720w.jpg" alt="Test" title="DolphinDB内存管理详解"><br>当事务t1，t2，t3都完成时，将三个事务的数据一次性写入到DFS的数据库磁盘上。Cache Engine空间一般推荐为maxMemSize的1&#x2F;8~1&#x2F;4，可根据最大内存和写入数据量适当调整。CacheEngine的大小可以通过配置参数chunkCacheEngineMemSize来配置。</p><p>chunkCacheEngineMemSize：指定cache engine的容量。cache engine开启后，写入数据时，系统会先把数据写入缓存，当缓存中的数据量达到chunkCacheEngineMemSize的30%时，才会写入磁盘。</p><h4 id="6-高效使用内存"><a href="#6-高效使用内存" class="headerlink" title="6. 高效使用内存"></a>6. 高效使用内存</h4><p>在企业的生产环境中，DolphinDB往往作为流数据中心以及历史数据仓库，为业务人员提供数据查询和计算。当用户较多时，不当的使用容易造成Server端内存耗尽，抛出”out of memory” 异常。可遵循以下建议，尽量避免内存的不合理使用。</p><p>合理均匀分区：DolphinDB是以分区为单位加载数据，因此，分区大小对内存影响巨大。合理均匀的分区，不管对内存使用还是对性能而言，都有积极的作用。因此，在创建数据库的时候，根据数据规模，合理规划分区大小。每个分区的常用字段数据量约100MB左右为宜。<br>及时释放数据量较大的变量：若用户创建数据量较大的变量，例如v &#x3D; 1..10000000，或者将含有大量数据的查询结果赋值给一个变量t &#x3D; select * from t where date &#x3D; 2010.01.01，v和t将会在用户的session占用大量的内存。如果不及时释放，当其他用户申请内存时，就有可能因为内存不足而抛出异常。<br>只查询需要的列：避免使用select *，如果用select <em>会把该分区所有列加载到内存。实际中，往往只需要几列。因此为避免内存浪费，尽量明确写出所有查询的列，而不是用</em>代替。<br>数据查询尽可能使用分区过滤条件：DolphinDB按照分区进行数据检索，如果不加分区过滤条件，则会全部扫描所有数据，数据量大时，内存很快被耗尽。有多个过滤条件的话，要优先写分区的过滤条件。<br>尽快释放不再需要的变量或者session：根据以上分析可知，用户的私有变量在创建的session里面保存。session关闭的时候，会回收这些内存。因此，尽早使用undef函数或者关闭session来释放内存。<br>合理配置流数据的缓存区：一般情况下流数据的容量(capacity)会直接影响发布节点的内存占用。比如，capacity设置1000万条，那么流数据表在超过1000万条时，会回收约一半的内存占用，也就是内存中会保留500万条左右。因此，应根据发布节点的最大内存，合理设计流表的capacity。尤其是在多张发布表的情况，更需要谨慎设计。</p><h4 id="7-内存监���及常见问题"><a href="#7-内存监���及常见问题" class="headerlink" title="7. 内存监���及常见问题"></a>7. 内存监���及常见问题</h4><p>7.1 内存监控<br>7.1.1 controller上监控集群中节点内存占用<br>在controller上提供函数getClusterPerf()函数，显示集群中各个节点的内存占用情况。包括:<br>MemAlloc：节点上分配的总内存，近似于向操作系统申请的内存总和。<br>MemUsed：节点已经使用的内存。该内存包括变量、分布式表缓存以及各种缓存队列等。<br>MemLimit：节点可使用的最大内存限制，即用户配置的maxMemSize。<br> <br>7.1.2 mem()函数监控某个节点内存占用<br>mem()函数可以显示整个节点的内存分配和占用情况。该函数输出4列，其中列blockSize表示分配的内存块大小，freeSize表示剩余的内存块大小，通过sum(mem().blockSize - mem().freeSize) 得到节点所使用的总的内存大小。<br>7.1.3 监控节点上不同session的内存占用<br>可通过函数getSessionMemoryStat()查看节点上每个session占用的内存量，该内存只包含session内定义的变量。当节点上内存占用太高时，可以通过该函数排查哪个用户使用了大量的内存。<br>7.1.4 查看某个对象占用的内存大小<br>通过函数memSize来查看某个对象占用内存的具体大小，单位为字节。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  v=<span class="number">1.</span><span class="number">.1000000</span></span><br><span class="line">memSize(v)</span><br></pre></td></tr></table></figure><p>输出：4000000。<br>7.2 常见问题<br>7.2.1 监控显示节点内存占用太高<br>通过上面的分析可知，DolphinDB会在内存允许的情况下，会尽可能多的缓存数据。因此，如果只显示节点内存占用太高，接近maxMemSize，而没有其他内存相关的错误，那么这种情况是正常的。 如果出现”out of memory”等类似的错误，首先可以通过函数getSessionMemoryStat()查看各个session占用的内存大小，其次通过函数clearAllCache()来手动释放节点的缓存数据。<br>7.2.2 MemAlloc显示值跟操作系统实际显示值有差异<br>DolphinDB是C++程序，本身需要一些基础的数据结构和内存开销，MemAlloc显示内存不包括这些内存，如果两者显示相差不大，几百MB以内，都属于正常现象。<br>7.2.3 查询时，报告”out of memory”<br>该异常往往是由于query所需的内存大于系统可提供的内存导致的。可能由以下原因导致:</p><p>查询没有加分区过滤条件或者条件太宽，导致单个query涉及的数据量太大。<br>分区不均匀。可能某个分区过大，该分区的数据超过节点配置的最大内存。<br>某个session持有大的变量，导致节点可用的内存很小。</p><p>7.2.4 查询时，DolphinDB进程退出,没有coredump产生<br>这种情况往往是由于给节点分配的内存超过��统物理内存的限制，操作系统把DolphinDB强制退出。Linux上可以通过操作系统的日志查看原因。<br>7.2.5 执行clearAllCache()函数后，MemUsed没有明显降低<br>可以通过getSessionMemoryStst()查看各个session占用的内存大小。可能是由于某个session持有占用大量内存的变量不释放，导致该部分内存一直不能回收。</p><div class="post-copyright"><div class="content"><p>本文标题： 推荐系列-DolphinDB内存管理详解</p><p>本文作者： OSChina</p><p>发布时间： 2021年04月15日 10:08</p><p>最后更新： 2022年05月11日 17:29</p><p>原始链接： <a class="post-url" href="/deb1c29e/" title="推荐系列-DolphinDB内存管理详解">https://www.hosiang.cn/deb1c29e/</a></p><p>版权声明： 本文著作权归作者所有，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a>许可协议，转载请注明出处！</p><footer><a href="https://www.hosiang.cn"><img src="/../images/logo.png" alt="Howe Hsiang"> Howe Hsiang</a></footer></div></div><div class="page-reward"><a id="rewardBtn" href="javascript:;">赏</a></div><div id="reward" class="post-modal reward-lay"><a class="close" href="javascript:;" id="reward-close">×</a> <span class="reward-title"><i class="icon icon-quote-left"></i> 喜欢就赞赏一下呗！ <i class="icon icon-quote-right"></i></span><div class="reward-content"><div class="reward-code"><img id="rewardCode" src="/images/threepay_code.jpg" alt="打赏二维码"></div><div class="reward-select"></div></div></div></div><footer class="article-footer"><div class="post-share"><a href="javascript:" id="share-sub" class="post-share-fab"><i class="fa fa-share-alt" style="padding-top:11px!important"></i></a><div class="post-share-list" id="share-list"><ul class="share-icons"><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.hosiang.cn/deb1c29e/" data-title="Facebook" rel="external nofollow noopener noreferrer"><i class="fa fa-facebook" style="padding-top:9px!important"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《推荐系列-DolphinDB内存管理详解》 — 狂欢马克思&url=https://www.hosiang.cn/deb1c29e/&via=https://www.hosiang.cn" data-title="Twitter" rel="external nofollow noopener noreferrer"><i class="fa fa-twitter" style="padding-top:9px!important"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.hosiang.cn/deb1c29e/" data-title="Google+" rel="external nofollow noopener noreferrer"><i class="fa fa-google-plus" style="padding-top:9px!important"></i></a></li><li><a class="qq share-sns" target="_blank" href="https://connect.qq.com/widget/shareqq/index.html?url=https://www.hosiang.cn/deb1c29e/&title=《推荐系列-DolphinDB内存管理详解》 — 狂欢马克思&source=&amp;emsp;&amp;emsp;DolphinDB是一款支持多用户多任务并发操作的高性能分布式时序数据库软件(distributed time-s..." data-title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-qq" style="padding-top:9px!important"></i></a></li><li><a class="weixin share-sns" id="wxFab" href="javascript:" data-title="微信"><i class="fa fa-weixin" style="padding-top:9px!important"></i></a></li><li><a class="weibo share-sns" target="_blank" href="https://service.weibo.com/share/share.php?url=https://www.hosiang.cn/deb1c29e/&title=《推荐系列-DolphinDB内存管理详解》 — 狂欢马克思&pic=https://pic2.zhimg.com/80/v2-1c40f4e2f1e0967033dfff9b207fecb5_720w.jpg" data-title="微博" rel="external nofollow noopener noreferrer"><i class="fa fa-weibo" style="padding-top:9px!important"></i></a></li></ul></div></div><div class="post-modal wx-share" id="wxShare"><a class="close" href="javascript:" id="wxShare-close">×</a><p>扫一扫，分享到微信</p><img src="//api.qrserver.com/v1/create-qr-code/?data=https://www.hosiang.cn/deb1c29e/" alt="微信分享二维码"></div><div class="mask"></div><ul class="article-footer-menu"><li class="article-footer-tags"><i class="fa fa-tags"></i> <a href="/tags/Popular/" class="color3">Popular</a></li></ul></footer></div></article><aside class="post-toc-pos post-toc-top" id="post-toc"><nav class="post-toc-wrap"><ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD"><span class="post-toc-text">1. 内存管理�����</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="post-toc-text">2. 变量的内存管理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E7%9A%84%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86"><span class="post-toc-text">3. 分布式表的缓存管理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-%E6%B5%81%E6%95%B0%E6%8D%AE%E6%B6%88%E6%81%AF%E7%BC%93%E5%AD%98%E9%98%9F%E5%88%97"><span class="post-toc-text">4. 流数据消息缓存队列</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-%E4%B8%BA%E5%86%99%E5%85%A5DFS%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BC%93%E5%AD%98"><span class="post-toc-text">5. 为写入DFS数据库提供缓存</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98"><span class="post-toc-text">6. 高效使用内存</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-%E5%86%85%E5%AD%98%E7%9B%91%EF%BF%BD%EF%BF%BD%EF%BF%BD%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="post-toc-text">7. 内存监���及常见问题</span></a></li></ol></nav></aside><nav id="article-nav"><a href="/d056fdd5/" id="article-nav-newer" class="article-nav-link-wrap"><span class="article-nav-title"><i class="fa fa-hand-o-left" aria-hidden="true"></i> 推荐系列-鸿蒙内核源码分析(fork篇) - fork是如何做到调用一次,返回两次的 - - 百篇博客分析HarmonyOS源码 - v45.03 </span></a><a href="/f696668e/" id="article-nav-older" class="article-nav-link-wrap"><span class="article-nav-title">推荐系列-Redux 中间件 到底怎么工作的呢-</span> <i class="fa fa-hand-o-right" aria-hidden="true"></i></a></nav><div id="gitalk"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({repo:"bolg-comment",owner:"Hosiang1026",admin:"Hosiang1026",clientID:"37a2dd4473e8970cecc2",clientSecret:"e30efa17d86d9de4f4ab810872dc62a7b2e7e634",pagerDirection:"last",distractionFreeMode:!0,createIssueManually:!1});gitalk.render("gitalk")</script></section></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"><script id="_wau78w">var _wau=_wau||[];_wau.push(["small","5dnguv4c2n","78w"])</script><script async src="//waust.at/s.js"></script><p><span id="busuanzi_container_site_uv" style="display:none"><span class="post-count">总字数：<span>1786.9k</span> </span>总访客数：<span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" style="display:none">总访问量：<span id="busuanzi_value_site_pv"></span></span><br><span id="TimeShow">本站</span><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br>Copyright&copy; 2018 - 2022 狂欢马克思 <a href="https://beian.miit.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">京ICP备17060439号</a></p></div></div><script>var now=new Date;function createtime(){var n=new Date("2017/09/18");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",800)</script></footer><script>var mihoConfig={root:"https://www.hosiang.cn",animate:"true",isHome:"false",share:"true",reward:" 1"}</script><div class="sidebar"><div id="sidebar-search" title="Search"><i class="fa fa-search"></i></div><div id="sidebar-category" title="Categories"><i class="fa fa-book"></i></div><div id="sidebar-tag" title="Tags"><i class="fa fa-tags"></i></div><div id="sidebar-top"><span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span></div></div><div class="sidebar-menu-box" id="sidebar-menu-box"><div class="sidebar-menu-box-container"><div id="sidebar-menu-box-categories"><a class="category-link" href="/categories/%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD/">兴趣爱好</a><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96%E5%BC%80%E5%8F%91/">其他开发</a><a class="category-link" href="/categories/%E5%89%8D%E6%B2%BF%E5%BC%80%E5%8F%91/">前沿开发</a><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/">前端开发</a><a class="category-link" href="/categories/%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/">升级版本</a><a class="category-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">博客教程</a><a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="category-link" href="/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/">日常记录</a><a class="category-link" href="/categories/%E7%83%AD%E9%97%A8%E6%96%87%E7%AB%A0/">热门文章</a></div><div id="sidebar-menu-box-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:17.5px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:15px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12.5px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Java/" style="font-size:12.5px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:17.5px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12.5px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:17.5px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div><a href="javascript:" class="sidebar-menu-box-close">&times;</a></div><div class="mobile-header-menu-nav" id="mobile-header-menu-nav"><div class="mobile-header-menu-container"><span class="title">导航</span><ul class="mobile-header-menu-navbar"><li><a href="/"><i class="fa fa-home"></i><span>主页</span></a></li><li><a href="/archives"><i class="fa fa-archive"></i><span>归档</span></a></li><li><a href="/gitbook"><i class="fa fa-columns"></i><span>笔记</span></a></li><li><a href="/music"><i class="fa fa-music"></i><span>音乐</span></a></li><li><a href="/photo"><i class="fa fa-picture-o"></i><span>相册</span></a></li><li><a href="/collection"><i class="fa fa-envira"></i><span>收藏</span></a></li><li><a href="/about"><i class="fa fa-user"></i><span>关于</span></a></li></ul></div><div class="mobile-header-tag-container"><span class="title">标签</span><div id="mobile-header-container-tags"><a href="/tags/Ajax/" style="font-size:10px">Ajax</a> <a href="/tags/AliGenie/" style="font-size:10px">AliGenie</a> <a href="/tags/Alipay/" style="font-size:10px">Alipay</a> <a href="/tags/Android/" style="font-size:10px">Android</a> <a href="/tags/Blockchain/" style="font-size:17.5px">Blockchain</a> <a href="/tags/CQRS/" style="font-size:10px">CQRS</a> <a href="/tags/Database/" style="font-size:15px">Database</a> <a href="/tags/Docker/" style="font-size:10px">Docker</a> <a href="/tags/EasyUI/" style="font-size:10px">EasyUI</a> <a href="/tags/Guitar/" style="font-size:10px">Guitar</a> <a href="/tags/Hackintosh/" style="font-size:12.5px">Hackintosh</a> <a href="/tags/Hexo/" style="font-size:15px">Hexo</a> <a href="/tags/IntelliJ-IDEA/" style="font-size:10px">IntelliJ IDEA</a> <a href="/tags/Java/" style="font-size:12.5px">Java</a> <a href="/tags/Kali-Linux/" style="font-size:10px">Kali Linux</a> <a href="/tags/Life/" style="font-size:17.5px">Life</a> <a href="/tags/Mac-OS/" style="font-size:12.5px">Mac OS</a> <a href="/tags/MultiThread/" style="font-size:10px">MultiThread</a> <a href="/tags/NodeJS/" style="font-size:10px">NodeJS</a> <a href="/tags/Popular/" style="font-size:20px">Popular</a> <a href="/tags/Python/" style="font-size:10px">Python</a> <a href="/tags/SaaS/" style="font-size:10px">SaaS</a> <a href="/tags/Servlet/" style="font-size:10px">Servlet</a> <a href="/tags/Spring/" style="font-size:17.5px">Spring</a> <a href="/tags/Upgrade/" style="font-size:10px">Upgrade</a> <a href="/tags/Web/" style="font-size:10px">Web</a> <a href="/tags/Windows/" style="font-size:10px">Windows</a> <a href="/tags/Work/" style="font-size:10px">Work</a> <a href="/tags/iOS/" style="font-size:10px">iOS</a></div></div></div><div class="search-wrap"><span class="search-close">&times;</span> <a href="javascript:" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i> </a><input class="search-field" placeholder="Search..." id="keywords"> <a id="search-submit" href="javascript:"><i class="fa fa-search"></i></a><div class="search-container" id="search-container"><ul class="search-result" id="search-result"></ul></div></div><div id="search-tpl"><li class="search-result-item"><a href="{url}" class="search-item-li"><span class="search-item-li-title" title="{title}">{title}</span></a></li></div><script src="/js/search.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script><div id="particles"></div><script src="/js/particles.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css"><script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script><script src="/js/animate.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0,scale:.5},log:!1})</script></body></html>