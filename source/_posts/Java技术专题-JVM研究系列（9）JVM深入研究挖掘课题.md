---
title: 推荐系列-Java技术专题-JVM研究系列（9）JVM深入研究挖掘课题
categories: 热门文章
tags:
  - Popular
author: OSChina
top: 746
cover_picture: 'https://oscimg.oschina.net/oscnet/up-c848b6a082d833145c3095b03a263c2d0ff.png'
abbrlink: 694c2384
date: 2021-04-15 09:48:03
---

&emsp;&emsp;JVM执行引擎的效率提升 JVM是如何在保证可移植性的前提下提供高执行效率的？ Java跨平台性 Java程序最为常见的执行方式，是预先编译为一种名为 Java 字节码的中间代码格式。这种代码格式无法...
<!-- more -->

                                                                                                                                                                                        ### JVM执行引擎的效率提升 
#### JVM是如何在保证可移植性的前提下提供高执行效率的？ 
![Test](https://oscimg.oschina.net/oscnet/up-c848b6a082d833145c3095b03a263c2d0ff.png  'Java技术专题-JVM研究系列（9）JVM深入研究挖掘课题') 
 
### Java跨平台性 
 
### Java执行方式 
 
 
 解释执行就好比同声传译，JVM一边理解输入的字节码一边解释字节码生成机器码向CPU发出指令序列； 
 即时编译则是“磨刀不误砍柴工”，JVM 会在运行过程中将 热点代码编译成为可直接执行二进制代码。 
 
 
 
### Java异常捕获 
![Test](https://oscimg.oschina.net/oscnet/up-c848b6a082d833145c3095b03a263c2d0ff.png  'Java技术专题-JVM研究系列（9）JVM深入研究挖掘课题') 
 
 编译生成的Java字节码中，每个方法都附带一个异常表。异常表中的每一行均定义了一条异常执行路径，其中包括规定捕获范围的起始字节码索引、终止（不包含）字节码索引，异常处理代码的起始字节码索引，以及所捕获的异常类型。 
 当程序触发异常时，JVM会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某行异常表条目的捕获范围内，JVM 会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，JVM 会将控制流转移至该条目所指向的异常处理代码。 
 上述异常捕获机制还被用于 finally 从句的实现。通常，Java程序的编译器javac会复制多份 finally 代码块，放置于生成的 Java 字节码之中，然后通过生成多行异常表条目，来实现完整的 finally 逻辑。 
 
 
![Test](https://oscimg.oschina.net/oscnet/up-c848b6a082d833145c3095b03a263c2d0ff.png  'Java技术专题-JVM研究系列（9）JVM深入研究挖掘课题') 
### Java反射调用 
![Test](https://oscimg.oschina.net/oscnet/up-c848b6a082d833145c3095b03a263c2d0ff.png  'Java技术专题-JVM研究系列（9）JVM深入研究挖掘课题') 
 
 默认情况下，反射调用首先会被委派给native方法来进行。可想而知，其运行效率低下。当某个反射调用的调用次数达到 15 之后，JDK 代码断定该调用属于热点调用。 
 继而，JDK 将动态生成直接调用目标方法的字节码，并将反射调用的委派对象由原本的 native 方法实现切换至该动态生成的实现。这种方式的运行效率相对于 native 方法来说要高很多。 
 之所以 JDK 不从��开始便采用动态生成字节码的方式，主要是因为生成过程需要耗费一定的时间。对于那些整个生命周期中仅执行数次的反射调用，动态生成字节码将得不偿失。 
 然而，即便是直接调用目标方法的动态实现，其峰值性能也无法跟真正的直接调用相媲美。这背后涉及到即时编译中的虚方法内联。 
 
 
### JVM垃圾回收 
![Test](https://oscimg.oschina.net/oscnet/up-c848b6a082d833145c3095b03a263c2d0ff.png  'Java技术专题-JVM研究系列（9）JVM深入研究挖掘课题') 
 
 ```java 
   目前 JVM 的主流垃圾回收器采取的都是可达性分析算法。

  ``` 
  
 
 
 
垃圾回收的另一基础思想则是分代回收。JVM 会将新生成的对象划为新生代，而将在多次垃圾回收中存活下来的对象划为老年代。JVM 会为不同的分代设置不同的回收算法，从而达到新生代多收集、快收集，老年代少收集、全收集的目标。 
### Java内存模型 
 
 
 
这些规则所体现的最为重要的属性便是可见性，即对某一变量的访问能否被同一线程的其他操作，或者不同线程所观测到。 
 
### JVM对象锁 
 
 
 
 

                                        