---
title: 推荐系列-高并发下如何保证接口的幂等性-
categories: 热门文章
tags:
  - Popular
author: OSChina
top: 2094
cover_picture: 'https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png'
abbrlink: d1f20ef7
date: 2021-04-15 09:46:45
---

&emsp;&emsp;前言 接口幂等性问题，对于开发人员来说，是一个跟语言无关的公共问题。本文分享了一些解决这类问题非常实用的办法，绝大部分内容我在项目中实践过的，给有需要的小伙伴一个参考。 不知道你有...
<!-- more -->

                                                                                                                                                                                         
  
   
    
   
   
  #### 前言 
   
 ```java 
  接口幂等性
  ``` 
 问题，对于开发人员来说，是一个跟语言无关的公共问题。本文分享了一些解决这类问题非常实用的办法，绝大部分内容我在项目中实践过的，给有需要的小伙伴一个参考。 
  不知道你有没有遇到过这些场景： 
   
    
    
      有时我们在填写某些 
      
 ```java 
  form表单
  ``` 
 时，保存按钮不小心快速点了两次，表中竟然产生了两条重复的数据，只是id不一样。 
     
    
    
      我们在项目中为了解决 
      
 ```java 
  接口超时
  ``` 
 问题，通常会引入了 
      
 ```java 
  重试机制
  ``` 
 。第一次请求接口超时了，请求方没能及时获取返回结果（此时有可能已经成功了），为了避免返回错误的结果（这种情况不可能直接返回失败吧？），于是会对该请求重试几次，这样也会产生重复的数据。 
     
    
    
      mq消费者在读取消息时，有时候会读取到 
      
 ```java 
  重复消息
  ``` 
 （至于什么原因这里先不说，有兴趣的小伙伴，可以找我私聊），如果处理不好，也会产生重复的数据。 
     
   
  没错，这些都是幂等性问题。 
   
 ```java 
  接口幂等性
  ``` 
 是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 
  这类问题多发于接口的： 
   
    
     
      
 ```java 
  insert
  ``` 
 操作，这种情况下多次请求，可能会产生重复数据。 
     
    
     
      
 ```java 
  update
  ``` 
 操作，如果只是单纯的更新数据，比如： 
      
 ```java 
  update user set status=1 where id=1
  ``` 
 ，是没有问题的。如果还有计算，比如： 
      
 ```java 
  update user set status=status+1 where id=1
  ``` 
 ，这种情况下多次请求，可能会导致数据错误。 
     
   
  那么我们要如何保证接口���等性？本文将会告诉你答案。 
   
  #### 1. insert前先select 
  通常情况下，在保存数据的接口中，我们为了防止产生重复数据，一般会在 
 ```java 
  insert
  ``` 
 前，先根据 
 ```java 
  name
  ``` 
 或 
 ```java 
  code
  ``` 
 字段 
 ```java 
  select
  ``` 
 一下数据。如果该数据已存在，则执行 
 ```java 
  update
  ``` 
 操作，如果不存在，才执行   
 ```java 
  insert
  ``` 
 操作。 
  ![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
  该方案可能是我们平时在防止产生重复数据时，使用最多的方案。但是该方案不适用于并发场景，在并发场景中，要配合其他方案一起使用，否则同样会产生重复数据。我在这里提一下，是为了避免大家踩坑。 
   
  #### 2. 加悲观锁 
  在支付场景中，用户A的账号余额有150元，想转出100元，正常情况下用户A的余额只剩50元。一般情况下，sql是这样的： 
   
    
 ```java 
  update user amount = amount-100 where id=123;
  ``` 
  
   
   
 ```java 
  
  ``` 
  
  如果出现多次相同的请求，可能会导致用户A的余额变成负数。这种情况，用户A来可能要哭了。于此同时，系统开发人员可能也要哭了，因为这是很严重的系统bug。 
  为了解决这个问题，可以加悲观锁，将用户A的那行数据锁住，在同一时刻只允许一个请求获得锁，更新数据，其他的请求则等待。 
  通常情况下通过如下sql锁住单行数据： 
   
    
 ```java 
  select * from user id=123 for update;
  ``` 
  
   
   
 ```java 
  
  ``` 
  
  具体流程如下： 
  ![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
  具体步骤： 
   
    
    
      多个请求同时根据id查询用户信息。 
     
    
    
      判断余额是否不足100，如果余额不足，则直接返回余额不足。 
     
    
    
      如果余额充足，则通过for update再次查询用户信息，并且尝试获取锁。 
     
    
    
      只有第一个请求能获取到行锁，其余没有获取锁的请求，则等待下一次获取锁的机会。 
     
    
    
      第一个请求获取到锁之后，判断余额是否不足100，如果余额足够，则进行update操作。 
     
    
    
      如果余额不足，说明是重复请求，则直接返回成功。 
     
   
   
    
   
   
   
   悲观锁需要在同一个事务操作过程中锁住一行数据，如果事务耗时比较长，会造成大量的请求等待，影响接口性能。 
   
  
    此外，每次请求接口很难保证都有相同的返回值，所以不适合幂等性设计场景，但是在防重场景中是可以的使用的。 
   
   
   在这里顺便说一下， 
    
 ```java 
  防重设计
  ``` 
  
    和  
    
 ```java 
  幂等设计
  ``` 
  
   ，其实是有区别的。 
   防重设计主要为了避免产生重复数据，对接口返回没有太多要求。 
   而幂等设计除了避免产生重复数据之外，还要求每次请求都返回一样的结果。 
   
   
  #### 3. 加乐观锁 
  既然悲观锁有性能问题，为了提升接口性能，我们可以使用乐观锁。需要在表中增加一个 
 ```java 
  timestamp
  ``` 
 或者 
 ```java 
  version
  ``` 
 字段，这里以 
 ```java 
  version
  ``` 
 字段为例。 
  在更新数据之前先查询一下数据： 
   
    
 ```java 
  select id,amount,version from user id=123;
  ``` 
  
   
   
 ```java 
  
  ``` 
  
  如果数据存在，假设查到的 
 ```java 
  version
  ``` 
 等于 
 ```java 
  1
  ``` 
 ，再使用 
 ```java 
  id
  ``` 
 和 
 ```java 
  version
  ``` 
 字段作为查询条件更新数据： 
   
    
 ```java 
  update user set amount=amount+100,version=version+1
  ``` 
  
 ```java 
  where id=123 and version=1;
  ``` 
  
   
   
 ```java 
  
  ``` 
  
  更新数据的同时 
 ```java 
  version+1
  ``` 
 ，然后判断本次 
 ```java 
  update
  ``` 
 操作的影响行数，如果大于0，则说明本次更新成功，如果等于0，则说明本次更新没有让数据变更。 
  由于第一次请求 
 ```java 
  version
  ``` 
 等于 
 ```java 
  1
  ``` 
 是可以成功的，操作成功后 
 ```java 
  version
  ``` 
 变成 
 ```java 
  2
  ``` 
 了。这时如果并发的请求过来，再执行相同的sql： 
   
    
 ```java 
   update user set amount=amount+100,version=version+1
  ``` 
  
 ```java 
  where id=123 and version=1;
  ``` 
  
   
  该 
 ```java 
  update
  ``` 
 操作不会真正更新数据，最终sql的执行结果影响行数是 
 ```java 
  0
  ``` 
 ，因为 
 ```java 
  version
  ``` 
 已经变成 
 ```java 
  2
  ``` 
 了， 
 ```java 
  where
  ``` 
 中的 
 ```java 
  version=1
  ``` 
 肯定无法满足条件。但为了保证接口幂等性，接口可以直接返回成功，因为 
 ```java 
  version
  ``` 
 值已经修改了，那么前面必定已经成功过一次，后面都是重复的请求。 
  具体流程如下：![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
  具体步骤： 
   
    
    
      先根据id查询用户信息，包含version字段 
     
    
    
      根据id和version字段值作为where条件的参数，更新用户信息，同时version+1 
     
    
    
      判断操作影响行数，如果影响1行，则说明是一次请求，可以做其他数据操作。 
     
    
    
      如果影响0行，说明是重复请求，则直接返回成功。 
     
   
   
  #### 4. 加唯一索引 
  绝大数情况下，为了防止重复数据的产生，我们都会在表中加唯一索引，这是一个非常简单，并且有效的方案。 
   
    
 ```java 
  alter table `order` add UNIQUE KEY `un_code` (`code`);
  ``` 
  
   
   
 ```java 
  
  ``` 
  
  加了唯一索引之后，第一次请求数据可以插入成功。但后面的相同请求，插入数据时会报 
 ```java 
  Duplicate entry '002' for key 'order.un_code
  ``` 
 异常，表示唯一索引有冲突。 
  虽说抛异常对数据来说没有影响，不会造成错误数据。但是为了保证接口幂等性，我们需要对该异常进行捕获，然后返回成功。 
  如果是 
 ```java 
  java
  ``` 
 程序需要捕获： 
 ```java 
  DuplicateKeyException
  ``` 
 异常，如果使用了 
 ```java 
  spring
  ``` 
 框架还需要捕获： 
 ```java 
  MySQLIntegrityConstraintViolationException
  ``` 
 异常。 
  具体流程图如下： 
   
   ![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
   
  具体步骤： 
   
    
    
      用户通过浏览器发起请求，服务端收集数据。 
     
    
    
      将该数据插入mysql 
     
    
    
      判断是否执行成功，如果成功，则操作其他数据（可能还有其他的业务逻辑）。 
     
    
    
      如果执行失败，捕获唯一索引冲突异常，直接返回成功。 
     
   
   
  #### 5. 建防重表 
  有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，直接在表中加唯一索引，显然是不太合适的。 
  针对这种情况，我们可以通过 
 ```java 
  建防重表
  ``` 
 来解决问题。 
  该表可以只包含两个字段： 
 ```java 
  id
  ``` 
  和  
 ```java 
  唯一索引
  ``` 
 ，唯一索引可以是多个字段比如：name、code等组合起来的唯一标识，例如：susan_0001。 
  具体流程图如下： 
  ![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
  具体步骤： 
   
    
    
      用户通过浏览器发起请求，服务端收集数据。 
     
    
    
      将该数据插入mysql防重�� 
     
    
    
      判断是否执行成功，如果成功，则做mysql其他的数据操作（可能还有其他的业务逻辑）。 
     
    
    
      如果执行失败，捕获唯一索引冲突异常，直接返回成功。 
     
   
   
   
  #### 6. 根据状态机 
  很多时候业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态。如果这些状态的值是有规律的，按照业务节点正好是从小到大，我们就能通过它来保证接口的幂等性。 
  假如id=123的订单状态是 
 ```java 
  已支付
  ``` 
 ，现在要变成 
 ```java 
  完成
  ``` 
 状态。 
   
    
 ```java 
  update `order` set status=3 where id=123 and status=2;
  ``` 
  
   
   
 ```java 
  
  ``` 
  
  第一次请求时，该订单的状态是 
 ```java 
  已支付
  ``` 
 ，值是 
 ```java 
  2
  ``` 
 ，所以该 
 ```java 
  update
  ``` 
 语句可以正常更新数据，sql执行结果的影响行数是 
 ```java 
  1
  ``` 
 ，订单状态变成了 
 ```java 
  3
  ``` 
 。 
  后面有相同的请求过来，再执行相同的sql时，由于订单状态变成了 
 ```java 
  3
  ``` 
 ，再用 
 ```java 
  status=2
  ``` 
 作为条件，无法查询出需要更新的数据，所以最终sql执行结果的影响行数是 
 ```java 
  0
  ``` 
 ，即不会真正的更新数据。但为了保证接口幂等性，影响行数是 
 ```java 
  0
  ``` 
 时，接口也可以直接返回成功。 
  具体流程图如下： 
  ![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
  具体步骤： 
   
    
    
      用户通过浏览器发起请求，服务端收集数据。 
     
    
    
      根据id和当前状态作为条件，更新成下一个状态 
     
    
    
      判断操作影响行数，如果影响了1行，说明当前操作成功，可以进行其他数据操作。 
     
    
    
      如果影响了0行，说明是重复请求，直接返回成功。 
     
   
   
   
  #### 7. 加分布式锁 
  其实前面介绍过的 
 ```java 
  加唯一索引
  ``` 
 或者 
 ```java 
  加防重表
  ``` 
 ，本质是使用了 
 ```java 
  数据库
  ``` 
 的 
 ```java 
  分布式锁
  ``` 
 ，也属于分布式锁的一种。但由于 
 ```java 
  数据库分布式锁
  ``` 
 的性能不太好，我们可以改用： 
 ```java 
  redis
  ``` 
 或 
 ```java 
  zookeeper
  ``` 
 。 
  鉴于现在很多公司分布式配置中心改用 
 ```java 
  apollo
  ``` 
 或 
 ```java 
  nacos
  ``` 
 ，已经很少用 
 ```java 
  zookeeper
  ``` 
 了，我们以 
 ```java 
  redis
  ``` 
 为例介绍分布式锁。 
  目前主要有三种方式实现redis的分布式锁： 
   
    
    
      setNx命令 
     
    
    
      set命令 
     
    
    
      Redission框架 
     
   
  每种方案各有利弊，具体实现细节我就不说了，有兴趣的朋友可以加我微信找我私聊。 
  具体流程图如下： 
  ![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
  具体步骤： 
   
    
    
      用户通过浏览器发起请求，服务端会收集数据，并且生成订单号code作为唯一业务字段。 
     
    
    
      使用redis的set命令，将该订单code设置到redis中，同时设置超时时间。 
     
    
    
      判断是否设置成功，如果设置成功，说明是第一次请求，则进行数据操作。 
     
    
    
      如果设置失败，说明是重复请求，则直接返回成功。 
     
   
   
   
  #### 8. 获取token 
  除了上述方案之外，还有最后一种使用 
 ```java 
  token
  ``` 
 的方案。该方案跟之前的所有方案都有点不一样，需要两次请求才能完成一次业务操作。 
   
    
    
      第一次请求获取 
      
 ```java 
  token
  ``` 
  
     
    
    
      第二次请求带着这个 
      
 ```java 
  token
  ``` 
 ，完成业务操作。 
     
   
  具体流程图如下： 
  第一步，先获取token。 
  
 ![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
  
   
  第二步，做具体业务操作。 
  
 ![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
  
   
  具体步骤： 
   
    
    
      用户访问页面时，浏览器自动发起获取token请求。 
     
    
    
      服务端生成token，保存到redis中，然后返回给浏览器。 
     
    
    
      用户通过浏览器发起请求时，携带该token。 
     
    
    
      在redis中查询该token是否存在，如果不存在，说明是第一次请求，做则后续的数据操作。 
     
    
    
      如果存在，说明是重复请求，则直接返回成功。 
     
    
    
      在redis中token会在过期时间之后，被自动删除。 
     
   
  以上方案是针对幂等设计的。 
  如果是防重设计，流程图要改改： 
   
   ![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
   
   
  
  
 ##### 最后说一句(求关注，别白嫖我) 
 如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。 
 求一键三连：点赞、转发、在看。 
 关注公众号：【苏三说技术】，在公众号中回复：面试、代码神器、开发手册、时间管理有超赞的粉丝福利，另外回复：加群，可以跟很多BAT大厂的前辈交流和学习。 
  个人公众号 
 ![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
  个人微信 
 ![Test](https://oscimg.oschina.net/oscnet/6145b329-fa68-4e01-9307-a98fe0959137.png  '高并发下如何保证接口的幂等性-') 
  
 
本文分享自微信公众号 - 苏三说技术（gh_9f551dfec941）。如有侵权，请联系 support@oschina.cn 删除。本文参与“OSC源创计划”，欢迎正在阅读的你也加入，一起分享。
                                        